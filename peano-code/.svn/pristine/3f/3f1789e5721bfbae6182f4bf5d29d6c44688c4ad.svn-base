#include "tarch/plotter/pointdata/vtk/VTKBinaryFileWriter.h"
#include <stdio.h>
#include <fstream>
#include <iomanip>


tarch::logging::Log tarch::plotter::pointdata::vtk::VTKBinaryFileWriter::_log( "tarch::plotter::pointdata::vtk::VTKBinaryFileWriter" );


const std::string tarch::plotter::pointdata::vtk::VTKBinaryFileWriter::HEADER =
"# vtk DataFile Version 2.0\n "\
"Generated by Peano3 output component $Revision: 1.2 $ Author: Denys Korzh, Tobias Weinzierl\n "\
"BINARY\n ";

tarch::plotter::pointdata::vtk::VTKBinaryFileWriter::VTKBinaryFileWriter(const int precision):
  _writtenToFile(false),
  _precision(precision),
  _doubleOrFloat(setDoubleOrFloatString(precision)),
  _currentPointNumber(0) {
}



tarch::plotter::pointdata::vtk::VTKBinaryFileWriter::~VTKBinaryFileWriter() {
}


tarch::plotter::pointdata::Writer::PointDataWriter*    tarch::plotter::pointdata::vtk::VTKBinaryFileWriter::createPointDataWriter( const std::string& identifier, int recordsPerPoint ) {
  return new PointDataWriter(*this,identifier,recordsPerPoint);
}


bool tarch::plotter::pointdata::vtk::VTKBinaryFileWriter::isOpen() {
  return !_writtenToFile;
}


void tarch::plotter::pointdata::vtk::VTKBinaryFileWriter::clear() {
  _writtenToFile       = false;
  _currentPointNumber  = 0;
}



void tarch::plotter::pointdata::vtk::VTKBinaryFileWriter::writeToFile( const std::string& filename ) {
  assertion( !_writtenToFile );

  if (filename.rfind(".vtk")==std::string::npos) {
    logWarning( "writeToFile()", "filename should end with .vtu but is " << filename );
  }

  std::ofstream out;
  out.open( filename.c_str(), std::ios::binary );
  if ( (!out.fail()) && out.is_open() ) {
    _log.debug( "close()", "opened data file " + filename );
    //out << std::setprecision(_precision);

    out << HEADER << std::endl << std::endl;
    out << "DATASET UNSTRUCTURED_GRID" << std::endl
       << "POINTS " << _currentPointNumber << " " << _doubleOrFloat << std::endl;
    out << _streamPositions.rdbuf() << std::endl << std::endl;

    out << "CELLS " << _currentPointNumber
        << " " << 2*_currentPointNumber << std::endl;

    int itmp;
    int rone = 1;
    rone = byteSwapForParaviewBinaryFiles(rone);
    for(int i = 0; i < _currentPointNumber; i++) {
      out.write( reinterpret_cast<char*>(&rone) , sizeof(float));
      itmp = byteSwapForParaviewBinaryFiles(i);
      out.write( reinterpret_cast<char*>(&itmp) , sizeof(float));
    }
    out << std::endl << std::endl;

    out << "CELL_TYPES " << _currentPointNumber << std::endl;
    for (int i=0; i < _currentPointNumber; i++)
      out.write( reinterpret_cast<char*>(&rone) , sizeof(float));
    out << std::endl << std::endl;

    out << "POINT_DATA " << _currentPointNumber << std::endl << std::endl;
    out << _streamData.rdbuf() << std::endl;

    _log.debug( "close()", "data written to " + filename );
  }
  else {
  	_log.error( "close()", "unable to write output file " + filename );
  }

  _writtenToFile = true;
}


void tarch::plotter::pointdata::vtk::VTKBinaryFileWriter::validateDataWriterIdentifier( const std::string& identifier ) const {
  if (identifier.empty()) {
    logWarning(
      "validateDataWriterIdentifier(string)",
      "identifier for vtk file is empty. Spaces are not allowed for vtk data field identifiers and some vtk visualisers might crash."
    );
  }
  if (identifier.find(' ')!=std::string::npos) {
    logWarning(
      "validateDataWriterIdentifier(string)",
      "identifier \"" << identifier << "\" contains spaces. Spaces are not allowed for vtk data field identifiers and some vtk visualisers might crash."
    );
  }
}


int tarch::plotter::pointdata::vtk::VTKBinaryFileWriter::plotPoint(const tarch::la::Vector<2,double>& position) {
  assertion1( _currentPointNumber>=0, _currentPointNumber );

  tarch::la::Vector<3,double> p;
  p(0) = position(0);
  p(1) = position(1);
  p(2) = 0.0;

  return plotPoint(p);
}


int tarch::plotter::pointdata::vtk::VTKBinaryFileWriter::plotPoint(const tarch::la::Vector<3,double>& position) {
  assertion( _currentPointNumber>=0 );

  assertion1( position(0)==position(0), position );
  assertion1( position(1)==position(1), position );
  assertion1( position(2)==position(2), position );

  _currentPointNumber++;
  if (_precision < 7){
    float tmp;
    tmp = position(0);
    tmp = byteSwapForParaviewBinaryFiles(tmp);
    _streamPositions.write( reinterpret_cast<char*>(&tmp) , sizeof(tmp));
    tmp = position(1);
    tmp = byteSwapForParaviewBinaryFiles(tmp);
    _streamPositions.write( reinterpret_cast<char*>(&tmp) , sizeof(tmp));
    tmp = position(2);
    tmp = byteSwapForParaviewBinaryFiles(tmp);
    _streamPositions.write( reinterpret_cast<char*>(&tmp) , sizeof(tmp));
  } else {
    double tmp;
    tmp = position(0);
    tmp = byteSwapForParaviewBinaryFiles(tmp);
    _streamPositions.write( reinterpret_cast<char*>(&tmp) , sizeof(tmp));
    tmp = position(1);
    tmp = byteSwapForParaviewBinaryFiles(tmp);
    _streamPositions.write( reinterpret_cast<char*>(&tmp) , sizeof(tmp));
    tmp = position(2);
    tmp = byteSwapForParaviewBinaryFiles(tmp);
    _streamPositions.write( reinterpret_cast<char*>(&tmp) , sizeof(tmp));
  }


  return _currentPointNumber-1;
}


void tarch::plotter::pointdata::vtk::VTKBinaryFileWriter::close() {
}
