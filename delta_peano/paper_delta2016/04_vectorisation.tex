\clearpage
\section{Particle storage and vectorisation}
\label{section:vectorisation}

There are three different types of data sets in our minimalistic DEM codes: 
geometric data, behavioural data and meta data. 
Behavioural data is collision data.
It is modelled as struct with location and a normal vector.
Sets $\mathbb{C}$ of collision points are modelled as (dynamic) array of structs
(AoS) augmented with a copy of the collision partner as detailed before.
Spacetrees are our meta data.
The geometry data finally determines how straightforward and fast the collision
detection is. Collision detection is the computationally heavy activity in the
algorithm.
While other DEM discussions speak of a computational phase \cite{Wachs2012, Wachs2012a, Rycroft2012, Parteli2013}, we
prefer the term activity, as the collision detections are split among the grid traversal
and interwoven with other activities.

\begin{figure}
 \begin{center}
  \includegraphics[width=0.5\textwidth]{sketches/data-structure.pdf}
 \end{center}
 \caption{
   Right: The two layer data layout of our DEM code with an AoS on the particle
   level but SoA for the vector entries with replicated vector entries.
 }
 \label{figure:data-structure}
\end{figure}

We propose to realise the geometric data in two layers (Figure
\ref{figure:data-structure}).
A hull struct holds all particle properties such as velocities, rotation, mass,
geometric centre and mass centre.
Vertices refer to these hulls with arrays of structures (AoS).
Hulls link with pointers to the actual geometric data. 
This data is realised as structure of array, i.e.~there is a sequence of
x-coordinates, a sequence of y-coordinates and a sequence of z-coordinates.
These sequences are blown up with redundant data.
The first three entries in the x array hold the x coordinates of the three
vertices of the first triangle of the particle mesh.
The entries four through six hold the coordinates of the second triangle and so
forth. 
The degree of redundancy is determined by the particle mesh.

We accept the increased memory consumption of such a structure but in return are
able to avoid any indirect addressing, process all geometry data in the
collision checks in a stream-like fashion and can align all vector entries. 
SoA data are notouriously difficult to handle if subsets of a dataset are to be
transferred or data is to be reordered \cite{Eichenberger2004}.
In our particle handling, a particle is an atomic unity.
It is never teared apart or resorted during the simulation run.
A particle mesh is topologically invariant.

The remainder of this section discusses a function \texttt{findCollisions} that
is passed two particle meshes and identifies all
contact points. Such an operation runs over all triangles in $\mathbb{T}_A$ and the inner loop running over all triangles in $\mathbb{T}_B$. A sphere-to-sphere pre-check is often added to the computation as a cheap overhead that shortens simulation runtime during sparse-particle scenarios. The center of the sphere is defined to be the center of the non-spherical particle while the radius of the sphere is at least the radius of the particle plus the epsilon margin. 

\input{04a_brute-force}
\input{04b_penalty}

%We can concurrently determine the distance between multiple triangle pairs as long as we use the same number of Newton steps: Up to four or eight triangle pair distances can be determined at the same time; depending on the vector width. Such a speed-up statement however has to be read carefully. 
%While the concurrency potential is high due to , it is not clear a priori how many Newton steps are required. A high number of Newton steps can render the penalty method slower than the brute force approach.
\input{04c_hybrid}
