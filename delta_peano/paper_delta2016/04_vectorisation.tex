\section{Particle storage and vectorisation}
\label{section:vectorisation}

There are three different types of data sets in our minimalistic DEM codes: 
geometric data, behavioural data and meta data. 
Behavioural data is collision data.
It is modelled as struct with location and normal vector.
Sets $\mathbb{C}$ of collision points are modelled as (dynamic) array of structs
(AoS) augmented with a copy of the collision partner as detailed before.
Spacetrees are our meta data.
The geometry data finally determines how straightforward and fast the collision
detection is---collision detection is the computationally heavy activity in the
algorithm.
While other DEM discussions speak of a computational phase \cite{xxxx}, we
prefer activity, as the collision detections are split among the grid traversal
and interwoven with other activities.


\begin{figure}
 \begin{center}
  \includegraphics[width=0.5\textwidth]{sketches/data-structure.pdf}
 \end{center}
 \caption{
   Right: The two layer data layout of our DEM code with an AoS on the particle
   level but SoA for the vector entries with replicated vector entries.
 }
 \label{figure:data-structure}
\end{figure}


We propose to realise the geometric data in two layers (Figure
\ref{figure:data-structure}).
A hull struct holds all particle properties such as velocities, rotation, mass,
geometric centre and mass centre.
Vertices refer to these hulls with arrays of structures (AoS).
Hulls link with pointers to the actual geometric data. 
This data is realised as structure of array, i.e.~there is a sequence of
x-coordinates, a sequence of y-coordinates and a sequence of z-coordinates.
These sequences are blown up with redundant data.
The first three entries in the x array hold the x coordinates of the three
vertices of the first triangle of the particle mesh.
The entries four through six hold the coordinates of the second triangle and so
forth. 
The degree of redundancy is determined by the particle mesh.


We accept the increased memory consumption of such a structure but in return are
able to avoid any indirect addressing, process all geometry data in the
collision checks in a stream-like fashion and can align all vector entries. 
SoA data are notouriously difficult to handle if subsets of a dataset are to be
transferred or data is to be reordered.
In our particle handling, a particle is an atomic unity.
It is never teared apart or resorted.
A particle mesh is topologically invariant.

The remainder of this section discusses a function \texttt{findCollisions} that
is passed two particles or two particle meshes respectively and identifies all
contact points. 
Such an operation with quadratic complexity is often wrapped into an additional
check that compares bounding boxes and thus may skip comparisons
\cite{mattutis}.
We abstain from such a check as the spacetree realises a related optimisation.
The following text thus discusses a nested loop with the outer loop
running over all triangles in $\mathbb{T}_A$ and the inner loop running over all
triangles in $\mathbb{T}_B$. 

\input{04a_brute-force}
\input{04b_penalty}
\input{04c_hybrid}
