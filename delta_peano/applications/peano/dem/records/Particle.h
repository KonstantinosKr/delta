#ifndef _DEM_RECORDS_PARTICLE_H
#define _DEM_RECORDS_PARTICLE_H

#include "peano/utils/Globals.h"
#include "tarch/compiler/CompilerSpecificSettings.h"
#include "peano/utils/PeanoOptimisations.h"
#ifdef Parallel
	#include "tarch/parallel/Node.h"
#endif
#ifdef Parallel
	#include <mpi.h>
#endif
#include "tarch/logging/Log.h"
#include "tarch/la/Vector.h"
#include <bitset>
#include <complex>
#include <string>
#include <iostream>

namespace dem {
   namespace records {
      class Particle;
      class ParticlePacked;
   }
}

#if !defined(Dim2) && !defined(Dim3)
   /**
    * @author This class is generated by DaStGen
    * 		   DataStructureGenerator (DaStGen)
    * 		   2007-2009 Wolfgang Eckhardt
    * 		   2012      Tobias Weinzierl
    *
    * 		   build date: 09-02-2014 14:40
    *
    * @date   26/08/2016 13:52
    */
   class dem::records::Particle { 
      
      public:
         
         typedef dem::records::ParticlePacked Packed;
         
         struct PersistentRecords {
            #ifdef UseManualAlignment
            tarch::la::Vector<DIMENSIONS,double> _centre __attribute__((aligned(VectorisationAlignment)));
            #else
            tarch::la::Vector<DIMENSIONS,double> _centre;
            #endif
            #ifdef UseManualAlignment
            tarch::la::Vector<DIMENSIONS,double> _velocity __attribute__((aligned(VectorisationAlignment)));
            #else
            tarch::la::Vector<DIMENSIONS,double> _velocity;
            #endif
            double _diameter;
            double _radius;
            double _epsilon;
            double _mass;
            double _hMin;
            #ifdef UseManualAlignment
            tarch::la::Vector<DIMENSIONS,double> _centreOfMass __attribute__((aligned(VectorisationAlignment)));
            #else
            tarch::la::Vector<DIMENSIONS,double> _centreOfMass;
            #endif
            int _globalParticleNumber;
            int _numberOfTriangles;
            #ifdef UseManualAlignment
            tarch::la::Vector<DIMENSIONS,int> _vertices __attribute__((aligned(VectorisationAlignment)));
            #else
            tarch::la::Vector<DIMENSIONS,int> _vertices;
            #endif
            /**
             * Generated
             */
            PersistentRecords();
            
            /**
             * Generated
             */
            PersistentRecords(const tarch::la::Vector<DIMENSIONS,double>& centre, const tarch::la::Vector<DIMENSIONS,double>& velocity, const double& diameter, const double& radius, const double& epsilon, const double& mass, const double& hMin, const tarch::la::Vector<DIMENSIONS,double>& centreOfMass, const int& globalParticleNumber, const int& numberOfTriangles, const tarch::la::Vector<DIMENSIONS,int>& vertices);
            
            
            /**
             * Generated and optimized
             * 
             * If you realise a for loop using exclusively arrays (vectors) and compile 
             * with -DUseManualAlignment you may add 
             * \code
             #pragma vector aligned
             #pragma simd
             \endcode to this for loop to enforce your compiler to use SSE/AVX.
             * 
             * The alignment is tied to the unpacked records, i.e. for packed class
             * variants the machine's natural alignment is switched off to recude the  
             * memory footprint. Do not use any SSE/AVX operations or 
             * vectorisation on the result for the packed variants, as the data is misaligned. 
             * If you rely on vectorisation, convert the underlying record 
             * into the unpacked version first. 
             * 
             * @see convert()
             */
            inline tarch::la::Vector<DIMENSIONS,double> getCentre() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               return _centre;
            }
            
            
            
            /**
             * Generated and optimized
             * 
             * If you realise a for loop using exclusively arrays (vectors) and compile 
             * with -DUseManualAlignment you may add 
             * \code
             #pragma vector aligned
             #pragma simd
             \endcode to this for loop to enforce your compiler to use SSE/AVX.
             * 
             * The alignment is tied to the unpacked records, i.e. for packed class
             * variants the machine's natural alignment is switched off to recude the  
             * memory footprint. Do not use any SSE/AVX operations or 
             * vectorisation on the result for the packed variants, as the data is misaligned. 
             * If you rely on vectorisation, convert the underlying record 
             * into the unpacked version first. 
             * 
             * @see convert()
             */
            inline void setCentre(const tarch::la::Vector<DIMENSIONS,double>& centre) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               _centre = (centre);
            }
            
            
            
            /**
             * Generated and optimized
             * 
             * If you realise a for loop using exclusively arrays (vectors) and compile 
             * with -DUseManualAlignment you may add 
             * \code
             #pragma vector aligned
             #pragma simd
             \endcode to this for loop to enforce your compiler to use SSE/AVX.
             * 
             * The alignment is tied to the unpacked records, i.e. for packed class
             * variants the machine's natural alignment is switched off to recude the  
             * memory footprint. Do not use any SSE/AVX operations or 
             * vectorisation on the result for the packed variants, as the data is misaligned. 
             * If you rely on vectorisation, convert the underlying record 
             * into the unpacked version first. 
             * 
             * @see convert()
             */
            inline tarch::la::Vector<DIMENSIONS,double> getVelocity() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               return _velocity;
            }
            
            
            
            /**
             * Generated and optimized
             * 
             * If you realise a for loop using exclusively arrays (vectors) and compile 
             * with -DUseManualAlignment you may add 
             * \code
             #pragma vector aligned
             #pragma simd
             \endcode to this for loop to enforce your compiler to use SSE/AVX.
             * 
             * The alignment is tied to the unpacked records, i.e. for packed class
             * variants the machine's natural alignment is switched off to recude the  
             * memory footprint. Do not use any SSE/AVX operations or 
             * vectorisation on the result for the packed variants, as the data is misaligned. 
             * If you rely on vectorisation, convert the underlying record 
             * into the unpacked version first. 
             * 
             * @see convert()
             */
            inline void setVelocity(const tarch::la::Vector<DIMENSIONS,double>& velocity) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               _velocity = (velocity);
            }
            
            
            
            inline double getDiameter() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               return _diameter;
            }
            
            
            
            inline void setDiameter(const double& diameter) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               _diameter = diameter;
            }
            
            
            
            inline double getRadius() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               return _radius;
            }
            
            
            
            inline void setRadius(const double& radius) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               _radius = radius;
            }
            
            
            
            inline double getEpsilon() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               return _epsilon;
            }
            
            
            
            inline void setEpsilon(const double& epsilon) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               _epsilon = epsilon;
            }
            
            
            
            inline double getMass() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               return _mass;
            }
            
            
            
            inline void setMass(const double& mass) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               _mass = mass;
            }
            
            
            
            inline double getHMin() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               return _hMin;
            }
            
            
            
            inline void setHMin(const double& hMin) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               _hMin = hMin;
            }
            
            
            
            /**
             * Generated and optimized
             * 
             * If you realise a for loop using exclusively arrays (vectors) and compile 
             * with -DUseManualAlignment you may add 
             * \code
             #pragma vector aligned
             #pragma simd
             \endcode to this for loop to enforce your compiler to use SSE/AVX.
             * 
             * The alignment is tied to the unpacked records, i.e. for packed class
             * variants the machine's natural alignment is switched off to recude the  
             * memory footprint. Do not use any SSE/AVX operations or 
             * vectorisation on the result for the packed variants, as the data is misaligned. 
             * If you rely on vectorisation, convert the underlying record 
             * into the unpacked version first. 
             * 
             * @see convert()
             */
            inline tarch::la::Vector<DIMENSIONS,double> getCentreOfMass() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               return _centreOfMass;
            }
            
            
            
            /**
             * Generated and optimized
             * 
             * If you realise a for loop using exclusively arrays (vectors) and compile 
             * with -DUseManualAlignment you may add 
             * \code
             #pragma vector aligned
             #pragma simd
             \endcode to this for loop to enforce your compiler to use SSE/AVX.
             * 
             * The alignment is tied to the unpacked records, i.e. for packed class
             * variants the machine's natural alignment is switched off to recude the  
             * memory footprint. Do not use any SSE/AVX operations or 
             * vectorisation on the result for the packed variants, as the data is misaligned. 
             * If you rely on vectorisation, convert the underlying record 
             * into the unpacked version first. 
             * 
             * @see convert()
             */
            inline void setCentreOfMass(const tarch::la::Vector<DIMENSIONS,double>& centreOfMass) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               _centreOfMass = (centreOfMass);
            }
            
            
            
            inline int getGlobalParticleNumber() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               return _globalParticleNumber;
            }
            
            
            
            inline void setGlobalParticleNumber(const int& globalParticleNumber) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               _globalParticleNumber = globalParticleNumber;
            }
            
            
            
            inline int getNumberOfTriangles() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               return _numberOfTriangles;
            }
            
            
            
            inline void setNumberOfTriangles(const int& numberOfTriangles) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               _numberOfTriangles = numberOfTriangles;
            }
            
            
            
            /**
             * Generated and optimized
             * 
             * If you realise a for loop using exclusively arrays (vectors) and compile 
             * with -DUseManualAlignment you may add 
             * \code
             #pragma vector aligned
             #pragma simd
             \endcode to this for loop to enforce your compiler to use SSE/AVX.
             * 
             * The alignment is tied to the unpacked records, i.e. for packed class
             * variants the machine's natural alignment is switched off to recude the  
             * memory footprint. Do not use any SSE/AVX operations or 
             * vectorisation on the result for the packed variants, as the data is misaligned. 
             * If you rely on vectorisation, convert the underlying record 
             * into the unpacked version first. 
             * 
             * @see convert()
             */
            inline tarch::la::Vector<DIMENSIONS,int> getVertices() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               return _vertices;
            }
            
            
            
            /**
             * Generated and optimized
             * 
             * If you realise a for loop using exclusively arrays (vectors) and compile 
             * with -DUseManualAlignment you may add 
             * \code
             #pragma vector aligned
             #pragma simd
             \endcode to this for loop to enforce your compiler to use SSE/AVX.
             * 
             * The alignment is tied to the unpacked records, i.e. for packed class
             * variants the machine's natural alignment is switched off to recude the  
             * memory footprint. Do not use any SSE/AVX operations or 
             * vectorisation on the result for the packed variants, as the data is misaligned. 
             * If you rely on vectorisation, convert the underlying record 
             * into the unpacked version first. 
             * 
             * @see convert()
             */
            inline void setVertices(const tarch::la::Vector<DIMENSIONS,int>& vertices) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               _vertices = (vertices);
            }
            
            
            
         };
         
      private: 
         public:

         PersistentRecords _persistentRecords;
         private:

         
      public:
         /**
          * Generated
          */
         Particle();
         
         /**
          * Generated
          */
         Particle(const PersistentRecords& persistentRecords);
         
         /**
          * Generated
          */
         Particle(const tarch::la::Vector<DIMENSIONS,double>& centre, const tarch::la::Vector<DIMENSIONS,double>& velocity, const double& diameter, const double& radius, const double& epsilon, const double& mass, const double& hMin, const tarch::la::Vector<DIMENSIONS,double>& centreOfMass, const int& globalParticleNumber, const int& numberOfTriangles, const tarch::la::Vector<DIMENSIONS,int>& vertices);
         
         /**
          * Generated
          */
         ~Particle();
         
         
         /**
          * Generated and optimized
          * 
          * If you realise a for loop using exclusively arrays (vectors) and compile 
          * with -DUseManualAlignment you may add 
          * \code
          #pragma vector aligned
          #pragma simd
          \endcode to this for loop to enforce your compiler to use SSE/AVX.
          * 
          * The alignment is tied to the unpacked records, i.e. for packed class
          * variants the machine's natural alignment is switched off to recude the  
          * memory footprint. Do not use any SSE/AVX operations or 
          * vectorisation on the result for the packed variants, as the data is misaligned. 
          * If you rely on vectorisation, convert the underlying record 
          * into the unpacked version first. 
          * 
          * @see convert()
          */
         inline tarch::la::Vector<DIMENSIONS,double> getCentre() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            return _persistentRecords._centre;
         }
         
         
         
         /**
          * Generated and optimized
          * 
          * If you realise a for loop using exclusively arrays (vectors) and compile 
          * with -DUseManualAlignment you may add 
          * \code
          #pragma vector aligned
          #pragma simd
          \endcode to this for loop to enforce your compiler to use SSE/AVX.
          * 
          * The alignment is tied to the unpacked records, i.e. for packed class
          * variants the machine's natural alignment is switched off to recude the  
          * memory footprint. Do not use any SSE/AVX operations or 
          * vectorisation on the result for the packed variants, as the data is misaligned. 
          * If you rely on vectorisation, convert the underlying record 
          * into the unpacked version first. 
          * 
          * @see convert()
          */
         inline void setCentre(const tarch::la::Vector<DIMENSIONS,double>& centre) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            _persistentRecords._centre = (centre);
         }
         
         
         
         inline double getCentre(int elementIndex) const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            assertion(elementIndex>=0);
            assertion(elementIndex<DIMENSIONS);
            return _persistentRecords._centre[elementIndex];
            
         }
         
         
         
         inline void setCentre(int elementIndex, const double& centre) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            assertion(elementIndex>=0);
            assertion(elementIndex<DIMENSIONS);
            _persistentRecords._centre[elementIndex]= centre;
            
         }
         
         
         
         /**
          * Generated and optimized
          * 
          * If you realise a for loop using exclusively arrays (vectors) and compile 
          * with -DUseManualAlignment you may add 
          * \code
          #pragma vector aligned
          #pragma simd
          \endcode to this for loop to enforce your compiler to use SSE/AVX.
          * 
          * The alignment is tied to the unpacked records, i.e. for packed class
          * variants the machine's natural alignment is switched off to recude the  
          * memory footprint. Do not use any SSE/AVX operations or 
          * vectorisation on the result for the packed variants, as the data is misaligned. 
          * If you rely on vectorisation, convert the underlying record 
          * into the unpacked version first. 
          * 
          * @see convert()
          */
         inline tarch::la::Vector<DIMENSIONS,double> getVelocity() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            return _persistentRecords._velocity;
         }
         
         
         
         /**
          * Generated and optimized
          * 
          * If you realise a for loop using exclusively arrays (vectors) and compile 
          * with -DUseManualAlignment you may add 
          * \code
          #pragma vector aligned
          #pragma simd
          \endcode to this for loop to enforce your compiler to use SSE/AVX.
          * 
          * The alignment is tied to the unpacked records, i.e. for packed class
          * variants the machine's natural alignment is switched off to recude the  
          * memory footprint. Do not use any SSE/AVX operations or 
          * vectorisation on the result for the packed variants, as the data is misaligned. 
          * If you rely on vectorisation, convert the underlying record 
          * into the unpacked version first. 
          * 
          * @see convert()
          */
         inline void setVelocity(const tarch::la::Vector<DIMENSIONS,double>& velocity) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            _persistentRecords._velocity = (velocity);
         }
         
         
         
         inline double getVelocity(int elementIndex) const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            assertion(elementIndex>=0);
            assertion(elementIndex<DIMENSIONS);
            return _persistentRecords._velocity[elementIndex];
            
         }
         
         
         
         inline void setVelocity(int elementIndex, const double& velocity) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            assertion(elementIndex>=0);
            assertion(elementIndex<DIMENSIONS);
            _persistentRecords._velocity[elementIndex]= velocity;
            
         }
         
         
         
         inline double getDiameter() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            return _persistentRecords._diameter;
         }
         
         
         
         inline void setDiameter(const double& diameter) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            _persistentRecords._diameter = diameter;
         }
         
         
         
         inline double getRadius() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            return _persistentRecords._radius;
         }
         
         
         
         inline void setRadius(const double& radius) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            _persistentRecords._radius = radius;
         }
         
         
         
         inline double getEpsilon() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            return _persistentRecords._epsilon;
         }
         
         
         
         inline void setEpsilon(const double& epsilon) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            _persistentRecords._epsilon = epsilon;
         }
         
         
         
         inline double getMass() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            return _persistentRecords._mass;
         }
         
         
         
         inline void setMass(const double& mass) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            _persistentRecords._mass = mass;
         }
         
         
         
         inline double getHMin() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            return _persistentRecords._hMin;
         }
         
         
         
         inline void setHMin(const double& hMin) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            _persistentRecords._hMin = hMin;
         }
         
         
         
         /**
          * Generated and optimized
          * 
          * If you realise a for loop using exclusively arrays (vectors) and compile 
          * with -DUseManualAlignment you may add 
          * \code
          #pragma vector aligned
          #pragma simd
          \endcode to this for loop to enforce your compiler to use SSE/AVX.
          * 
          * The alignment is tied to the unpacked records, i.e. for packed class
          * variants the machine's natural alignment is switched off to recude the  
          * memory footprint. Do not use any SSE/AVX operations or 
          * vectorisation on the result for the packed variants, as the data is misaligned. 
          * If you rely on vectorisation, convert the underlying record 
          * into the unpacked version first. 
          * 
          * @see convert()
          */
         inline tarch::la::Vector<DIMENSIONS,double> getCentreOfMass() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            return _persistentRecords._centreOfMass;
         }
         
         
         
         /**
          * Generated and optimized
          * 
          * If you realise a for loop using exclusively arrays (vectors) and compile 
          * with -DUseManualAlignment you may add 
          * \code
          #pragma vector aligned
          #pragma simd
          \endcode to this for loop to enforce your compiler to use SSE/AVX.
          * 
          * The alignment is tied to the unpacked records, i.e. for packed class
          * variants the machine's natural alignment is switched off to recude the  
          * memory footprint. Do not use any SSE/AVX operations or 
          * vectorisation on the result for the packed variants, as the data is misaligned. 
          * If you rely on vectorisation, convert the underlying record 
          * into the unpacked version first. 
          * 
          * @see convert()
          */
         inline void setCentreOfMass(const tarch::la::Vector<DIMENSIONS,double>& centreOfMass) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            _persistentRecords._centreOfMass = (centreOfMass);
         }
         
         
         
         inline double getCentreOfMass(int elementIndex) const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            assertion(elementIndex>=0);
            assertion(elementIndex<DIMENSIONS);
            return _persistentRecords._centreOfMass[elementIndex];
            
         }
         
         
         
         inline void setCentreOfMass(int elementIndex, const double& centreOfMass) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            assertion(elementIndex>=0);
            assertion(elementIndex<DIMENSIONS);
            _persistentRecords._centreOfMass[elementIndex]= centreOfMass;
            
         }
         
         
         
         inline int getGlobalParticleNumber() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            return _persistentRecords._globalParticleNumber;
         }
         
         
         
         inline void setGlobalParticleNumber(const int& globalParticleNumber) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            _persistentRecords._globalParticleNumber = globalParticleNumber;
         }
         
         
         
         inline int getNumberOfTriangles() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            return _persistentRecords._numberOfTriangles;
         }
         
         
         
         inline void setNumberOfTriangles(const int& numberOfTriangles) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            _persistentRecords._numberOfTriangles = numberOfTriangles;
         }
         
         
         
         /**
          * Generated and optimized
          * 
          * If you realise a for loop using exclusively arrays (vectors) and compile 
          * with -DUseManualAlignment you may add 
          * \code
          #pragma vector aligned
          #pragma simd
          \endcode to this for loop to enforce your compiler to use SSE/AVX.
          * 
          * The alignment is tied to the unpacked records, i.e. for packed class
          * variants the machine's natural alignment is switched off to recude the  
          * memory footprint. Do not use any SSE/AVX operations or 
          * vectorisation on the result for the packed variants, as the data is misaligned. 
          * If you rely on vectorisation, convert the underlying record 
          * into the unpacked version first. 
          * 
          * @see convert()
          */
         inline tarch::la::Vector<DIMENSIONS,int> getVertices() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            return _persistentRecords._vertices;
         }
         
         
         
         /**
          * Generated and optimized
          * 
          * If you realise a for loop using exclusively arrays (vectors) and compile 
          * with -DUseManualAlignment you may add 
          * \code
          #pragma vector aligned
          #pragma simd
          \endcode to this for loop to enforce your compiler to use SSE/AVX.
          * 
          * The alignment is tied to the unpacked records, i.e. for packed class
          * variants the machine's natural alignment is switched off to recude the  
          * memory footprint. Do not use any SSE/AVX operations or 
          * vectorisation on the result for the packed variants, as the data is misaligned. 
          * If you rely on vectorisation, convert the underlying record 
          * into the unpacked version first. 
          * 
          * @see convert()
          */
         inline void setVertices(const tarch::la::Vector<DIMENSIONS,int>& vertices) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            _persistentRecords._vertices = (vertices);
         }
         
         
         
         inline int getVertices(int elementIndex) const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            assertion(elementIndex>=0);
            assertion(elementIndex<DIMENSIONS);
            return _persistentRecords._vertices[elementIndex];
            
         }
         
         
         
         inline void setVertices(int elementIndex, const int& vertices) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            assertion(elementIndex>=0);
            assertion(elementIndex<DIMENSIONS);
            _persistentRecords._vertices[elementIndex]= vertices;
            
         }
         
         
         /**
          * Generated
          */
         std::string toString() const;
         
         /**
          * Generated
          */
         void toString(std::ostream& out) const;
         
         
         PersistentRecords getPersistentRecords() const;
         /**
          * Generated
          */
         ParticlePacked convert() const;
         
         
      #ifdef Parallel
         protected:
            static tarch::logging::Log _log;
            
         public:
            
            /**
             * Global that represents the mpi datatype.
             * There are two variants: Datatype identifies only those attributes marked with
             * parallelise. FullDatatype instead identifies the whole record with all fields.
             */
            static MPI_Datatype Datatype;
            static MPI_Datatype FullDatatype;
            
            /**
             * Initializes the data type for the mpi operations. Has to be called
             * before the very first send or receive operation is called.
             */
            static void initDatatype();
            
            static void shutdownDatatype();
            
            /**
             * @param communicateSleep -1 Data exchange through blocking mpi
             * @param communicateSleep  0 Data exchange through non-blocking mpi, i.e. pending messages are received via polling until MPI_Test succeeds
             * @param communicateSleep >0 Same as 0 but in addition, each unsuccessful MPI_Test is follows by an usleep
             */
            void send(int destination, int tag, bool exchangeOnlyAttributesMarkedWithParallelise, int communicateSleep);
            
            void receive(int source, int tag, bool exchangeOnlyAttributesMarkedWithParallelise, int communicateSleep);
            
            static bool isMessageInQueue(int tag, bool exchangeOnlyAttributesMarkedWithParallelise);
            
            #endif
               
            };
            
            #ifndef DaStGenPackedPadding
              #define DaStGenPackedPadding 1      // 32 bit version
              // #define DaStGenPackedPadding 2   // 64 bit version
            #endif
            
            
            #ifdef PackedRecords
               #pragma pack (push, DaStGenPackedPadding)
            #endif
            
            /**
             * @author This class is generated by DaStGen
             * 		   DataStructureGenerator (DaStGen)
             * 		   2007-2009 Wolfgang Eckhardt
             * 		   2012      Tobias Weinzierl
             *
             * 		   build date: 09-02-2014 14:40
             *
             * @date   26/08/2016 13:52
             */
            class dem::records::ParticlePacked { 
               
               public:
                  
                  struct PersistentRecords {
                     tarch::la::Vector<DIMENSIONS,double> _centre;
                     tarch::la::Vector<DIMENSIONS,double> _velocity;
                     double _diameter;
                     double _radius;
                     double _epsilon;
                     double _mass;
                     double _hMin;
                     tarch::la::Vector<DIMENSIONS,double> _centreOfMass;
                     int _globalParticleNumber;
                     int _numberOfTriangles;
                     tarch::la::Vector<DIMENSIONS,int> _vertices;
                     /**
                      * Generated
                      */
                     PersistentRecords();
                     
                     /**
                      * Generated
                      */
                     PersistentRecords(const tarch::la::Vector<DIMENSIONS,double>& centre, const tarch::la::Vector<DIMENSIONS,double>& velocity, const double& diameter, const double& radius, const double& epsilon, const double& mass, const double& hMin, const tarch::la::Vector<DIMENSIONS,double>& centreOfMass, const int& globalParticleNumber, const int& numberOfTriangles, const tarch::la::Vector<DIMENSIONS,int>& vertices);
                     
                     
                     /**
                      * Generated and optimized
                      * 
                      * If you realise a for loop using exclusively arrays (vectors) and compile 
                      * with -DUseManualAlignment you may add 
                      * \code
                      #pragma vector aligned
                      #pragma simd
                      \endcode to this for loop to enforce your compiler to use SSE/AVX.
                      * 
                      * The alignment is tied to the unpacked records, i.e. for packed class
                      * variants the machine's natural alignment is switched off to recude the  
                      * memory footprint. Do not use any SSE/AVX operations or 
                      * vectorisation on the result for the packed variants, as the data is misaligned. 
                      * If you rely on vectorisation, convert the underlying record 
                      * into the unpacked version first. 
                      * 
                      * @see convert()
                      */
                     inline tarch::la::Vector<DIMENSIONS,double> getCentre() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                        return _centre;
                     }
                     
                     
                     
                     /**
                      * Generated and optimized
                      * 
                      * If you realise a for loop using exclusively arrays (vectors) and compile 
                      * with -DUseManualAlignment you may add 
                      * \code
                      #pragma vector aligned
                      #pragma simd
                      \endcode to this for loop to enforce your compiler to use SSE/AVX.
                      * 
                      * The alignment is tied to the unpacked records, i.e. for packed class
                      * variants the machine's natural alignment is switched off to recude the  
                      * memory footprint. Do not use any SSE/AVX operations or 
                      * vectorisation on the result for the packed variants, as the data is misaligned. 
                      * If you rely on vectorisation, convert the underlying record 
                      * into the unpacked version first. 
                      * 
                      * @see convert()
                      */
                     inline void setCentre(const tarch::la::Vector<DIMENSIONS,double>& centre) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                        _centre = (centre);
                     }
                     
                     
                     
                     /**
                      * Generated and optimized
                      * 
                      * If you realise a for loop using exclusively arrays (vectors) and compile 
                      * with -DUseManualAlignment you may add 
                      * \code
                      #pragma vector aligned
                      #pragma simd
                      \endcode to this for loop to enforce your compiler to use SSE/AVX.
                      * 
                      * The alignment is tied to the unpacked records, i.e. for packed class
                      * variants the machine's natural alignment is switched off to recude the  
                      * memory footprint. Do not use any SSE/AVX operations or 
                      * vectorisation on the result for the packed variants, as the data is misaligned. 
                      * If you rely on vectorisation, convert the underlying record 
                      * into the unpacked version first. 
                      * 
                      * @see convert()
                      */
                     inline tarch::la::Vector<DIMENSIONS,double> getVelocity() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                        return _velocity;
                     }
                     
                     
                     
                     /**
                      * Generated and optimized
                      * 
                      * If you realise a for loop using exclusively arrays (vectors) and compile 
                      * with -DUseManualAlignment you may add 
                      * \code
                      #pragma vector aligned
                      #pragma simd
                      \endcode to this for loop to enforce your compiler to use SSE/AVX.
                      * 
                      * The alignment is tied to the unpacked records, i.e. for packed class
                      * variants the machine's natural alignment is switched off to recude the  
                      * memory footprint. Do not use any SSE/AVX operations or 
                      * vectorisation on the result for the packed variants, as the data is misaligned. 
                      * If you rely on vectorisation, convert the underlying record 
                      * into the unpacked version first. 
                      * 
                      * @see convert()
                      */
                     inline void setVelocity(const tarch::la::Vector<DIMENSIONS,double>& velocity) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                        _velocity = (velocity);
                     }
                     
                     
                     
                     inline double getDiameter() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                        return _diameter;
                     }
                     
                     
                     
                     inline void setDiameter(const double& diameter) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                        _diameter = diameter;
                     }
                     
                     
                     
                     inline double getRadius() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                        return _radius;
                     }
                     
                     
                     
                     inline void setRadius(const double& radius) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                        _radius = radius;
                     }
                     
                     
                     
                     inline double getEpsilon() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                        return _epsilon;
                     }
                     
                     
                     
                     inline void setEpsilon(const double& epsilon) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                        _epsilon = epsilon;
                     }
                     
                     
                     
                     inline double getMass() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                        return _mass;
                     }
                     
                     
                     
                     inline void setMass(const double& mass) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                        _mass = mass;
                     }
                     
                     
                     
                     inline double getHMin() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                        return _hMin;
                     }
                     
                     
                     
                     inline void setHMin(const double& hMin) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                        _hMin = hMin;
                     }
                     
                     
                     
                     /**
                      * Generated and optimized
                      * 
                      * If you realise a for loop using exclusively arrays (vectors) and compile 
                      * with -DUseManualAlignment you may add 
                      * \code
                      #pragma vector aligned
                      #pragma simd
                      \endcode to this for loop to enforce your compiler to use SSE/AVX.
                      * 
                      * The alignment is tied to the unpacked records, i.e. for packed class
                      * variants the machine's natural alignment is switched off to recude the  
                      * memory footprint. Do not use any SSE/AVX operations or 
                      * vectorisation on the result for the packed variants, as the data is misaligned. 
                      * If you rely on vectorisation, convert the underlying record 
                      * into the unpacked version first. 
                      * 
                      * @see convert()
                      */
                     inline tarch::la::Vector<DIMENSIONS,double> getCentreOfMass() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                        return _centreOfMass;
                     }
                     
                     
                     
                     /**
                      * Generated and optimized
                      * 
                      * If you realise a for loop using exclusively arrays (vectors) and compile 
                      * with -DUseManualAlignment you may add 
                      * \code
                      #pragma vector aligned
                      #pragma simd
                      \endcode to this for loop to enforce your compiler to use SSE/AVX.
                      * 
                      * The alignment is tied to the unpacked records, i.e. for packed class
                      * variants the machine's natural alignment is switched off to recude the  
                      * memory footprint. Do not use any SSE/AVX operations or 
                      * vectorisation on the result for the packed variants, as the data is misaligned. 
                      * If you rely on vectorisation, convert the underlying record 
                      * into the unpacked version first. 
                      * 
                      * @see convert()
                      */
                     inline void setCentreOfMass(const tarch::la::Vector<DIMENSIONS,double>& centreOfMass) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                        _centreOfMass = (centreOfMass);
                     }
                     
                     
                     
                     inline int getGlobalParticleNumber() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                        return _globalParticleNumber;
                     }
                     
                     
                     
                     inline void setGlobalParticleNumber(const int& globalParticleNumber) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                        _globalParticleNumber = globalParticleNumber;
                     }
                     
                     
                     
                     inline int getNumberOfTriangles() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                        return _numberOfTriangles;
                     }
                     
                     
                     
                     inline void setNumberOfTriangles(const int& numberOfTriangles) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                        _numberOfTriangles = numberOfTriangles;
                     }
                     
                     
                     
                     /**
                      * Generated and optimized
                      * 
                      * If you realise a for loop using exclusively arrays (vectors) and compile 
                      * with -DUseManualAlignment you may add 
                      * \code
                      #pragma vector aligned
                      #pragma simd
                      \endcode to this for loop to enforce your compiler to use SSE/AVX.
                      * 
                      * The alignment is tied to the unpacked records, i.e. for packed class
                      * variants the machine's natural alignment is switched off to recude the  
                      * memory footprint. Do not use any SSE/AVX operations or 
                      * vectorisation on the result for the packed variants, as the data is misaligned. 
                      * If you rely on vectorisation, convert the underlying record 
                      * into the unpacked version first. 
                      * 
                      * @see convert()
                      */
                     inline tarch::la::Vector<DIMENSIONS,int> getVertices() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                        return _vertices;
                     }
                     
                     
                     
                     /**
                      * Generated and optimized
                      * 
                      * If you realise a for loop using exclusively arrays (vectors) and compile 
                      * with -DUseManualAlignment you may add 
                      * \code
                      #pragma vector aligned
                      #pragma simd
                      \endcode to this for loop to enforce your compiler to use SSE/AVX.
                      * 
                      * The alignment is tied to the unpacked records, i.e. for packed class
                      * variants the machine's natural alignment is switched off to recude the  
                      * memory footprint. Do not use any SSE/AVX operations or 
                      * vectorisation on the result for the packed variants, as the data is misaligned. 
                      * If you rely on vectorisation, convert the underlying record 
                      * into the unpacked version first. 
                      * 
                      * @see convert()
                      */
                     inline void setVertices(const tarch::la::Vector<DIMENSIONS,int>& vertices) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                        _vertices = (vertices);
                     }
                     
                     
                     
                  };
                  
               private: 
                  PersistentRecords _persistentRecords;
                  
               public:
                  /**
                   * Generated
                   */
                  ParticlePacked();
                  
                  /**
                   * Generated
                   */
                  ParticlePacked(const PersistentRecords& persistentRecords);
                  
                  /**
                   * Generated
                   */
                  ParticlePacked(const tarch::la::Vector<DIMENSIONS,double>& centre, const tarch::la::Vector<DIMENSIONS,double>& velocity, const double& diameter, const double& radius, const double& epsilon, const double& mass, const double& hMin, const tarch::la::Vector<DIMENSIONS,double>& centreOfMass, const int& globalParticleNumber, const int& numberOfTriangles, const tarch::la::Vector<DIMENSIONS,int>& vertices);
                  
                  /**
                   * Generated
                   */
                  ~ParticlePacked();
                  
                  
                  /**
                   * Generated and optimized
                   * 
                   * If you realise a for loop using exclusively arrays (vectors) and compile 
                   * with -DUseManualAlignment you may add 
                   * \code
                   #pragma vector aligned
                   #pragma simd
                   \endcode to this for loop to enforce your compiler to use SSE/AVX.
                   * 
                   * The alignment is tied to the unpacked records, i.e. for packed class
                   * variants the machine's natural alignment is switched off to recude the  
                   * memory footprint. Do not use any SSE/AVX operations or 
                   * vectorisation on the result for the packed variants, as the data is misaligned. 
                   * If you rely on vectorisation, convert the underlying record 
                   * into the unpacked version first. 
                   * 
                   * @see convert()
                   */
                  inline tarch::la::Vector<DIMENSIONS,double> getCentre() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     return _persistentRecords._centre;
                  }
                  
                  
                  
                  /**
                   * Generated and optimized
                   * 
                   * If you realise a for loop using exclusively arrays (vectors) and compile 
                   * with -DUseManualAlignment you may add 
                   * \code
                   #pragma vector aligned
                   #pragma simd
                   \endcode to this for loop to enforce your compiler to use SSE/AVX.
                   * 
                   * The alignment is tied to the unpacked records, i.e. for packed class
                   * variants the machine's natural alignment is switched off to recude the  
                   * memory footprint. Do not use any SSE/AVX operations or 
                   * vectorisation on the result for the packed variants, as the data is misaligned. 
                   * If you rely on vectorisation, convert the underlying record 
                   * into the unpacked version first. 
                   * 
                   * @see convert()
                   */
                  inline void setCentre(const tarch::la::Vector<DIMENSIONS,double>& centre) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     _persistentRecords._centre = (centre);
                  }
                  
                  
                  
                  inline double getCentre(int elementIndex) const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     assertion(elementIndex>=0);
                     assertion(elementIndex<DIMENSIONS);
                     return _persistentRecords._centre[elementIndex];
                     
                  }
                  
                  
                  
                  inline void setCentre(int elementIndex, const double& centre) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     assertion(elementIndex>=0);
                     assertion(elementIndex<DIMENSIONS);
                     _persistentRecords._centre[elementIndex]= centre;
                     
                  }
                  
                  
                  
                  /**
                   * Generated and optimized
                   * 
                   * If you realise a for loop using exclusively arrays (vectors) and compile 
                   * with -DUseManualAlignment you may add 
                   * \code
                   #pragma vector aligned
                   #pragma simd
                   \endcode to this for loop to enforce your compiler to use SSE/AVX.
                   * 
                   * The alignment is tied to the unpacked records, i.e. for packed class
                   * variants the machine's natural alignment is switched off to recude the  
                   * memory footprint. Do not use any SSE/AVX operations or 
                   * vectorisation on the result for the packed variants, as the data is misaligned. 
                   * If you rely on vectorisation, convert the underlying record 
                   * into the unpacked version first. 
                   * 
                   * @see convert()
                   */
                  inline tarch::la::Vector<DIMENSIONS,double> getVelocity() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     return _persistentRecords._velocity;
                  }
                  
                  
                  
                  /**
                   * Generated and optimized
                   * 
                   * If you realise a for loop using exclusively arrays (vectors) and compile 
                   * with -DUseManualAlignment you may add 
                   * \code
                   #pragma vector aligned
                   #pragma simd
                   \endcode to this for loop to enforce your compiler to use SSE/AVX.
                   * 
                   * The alignment is tied to the unpacked records, i.e. for packed class
                   * variants the machine's natural alignment is switched off to recude the  
                   * memory footprint. Do not use any SSE/AVX operations or 
                   * vectorisation on the result for the packed variants, as the data is misaligned. 
                   * If you rely on vectorisation, convert the underlying record 
                   * into the unpacked version first. 
                   * 
                   * @see convert()
                   */
                  inline void setVelocity(const tarch::la::Vector<DIMENSIONS,double>& velocity) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     _persistentRecords._velocity = (velocity);
                  }
                  
                  
                  
                  inline double getVelocity(int elementIndex) const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     assertion(elementIndex>=0);
                     assertion(elementIndex<DIMENSIONS);
                     return _persistentRecords._velocity[elementIndex];
                     
                  }
                  
                  
                  
                  inline void setVelocity(int elementIndex, const double& velocity) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     assertion(elementIndex>=0);
                     assertion(elementIndex<DIMENSIONS);
                     _persistentRecords._velocity[elementIndex]= velocity;
                     
                  }
                  
                  
                  
                  inline double getDiameter() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     return _persistentRecords._diameter;
                  }
                  
                  
                  
                  inline void setDiameter(const double& diameter) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     _persistentRecords._diameter = diameter;
                  }
                  
                  
                  
                  inline double getRadius() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     return _persistentRecords._radius;
                  }
                  
                  
                  
                  inline void setRadius(const double& radius) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     _persistentRecords._radius = radius;
                  }
                  
                  
                  
                  inline double getEpsilon() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     return _persistentRecords._epsilon;
                  }
                  
                  
                  
                  inline void setEpsilon(const double& epsilon) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     _persistentRecords._epsilon = epsilon;
                  }
                  
                  
                  
                  inline double getMass() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     return _persistentRecords._mass;
                  }
                  
                  
                  
                  inline void setMass(const double& mass) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     _persistentRecords._mass = mass;
                  }
                  
                  
                  
                  inline double getHMin() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     return _persistentRecords._hMin;
                  }
                  
                  
                  
                  inline void setHMin(const double& hMin) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     _persistentRecords._hMin = hMin;
                  }
                  
                  
                  
                  /**
                   * Generated and optimized
                   * 
                   * If you realise a for loop using exclusively arrays (vectors) and compile 
                   * with -DUseManualAlignment you may add 
                   * \code
                   #pragma vector aligned
                   #pragma simd
                   \endcode to this for loop to enforce your compiler to use SSE/AVX.
                   * 
                   * The alignment is tied to the unpacked records, i.e. for packed class
                   * variants the machine's natural alignment is switched off to recude the  
                   * memory footprint. Do not use any SSE/AVX operations or 
                   * vectorisation on the result for the packed variants, as the data is misaligned. 
                   * If you rely on vectorisation, convert the underlying record 
                   * into the unpacked version first. 
                   * 
                   * @see convert()
                   */
                  inline tarch::la::Vector<DIMENSIONS,double> getCentreOfMass() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     return _persistentRecords._centreOfMass;
                  }
                  
                  
                  
                  /**
                   * Generated and optimized
                   * 
                   * If you realise a for loop using exclusively arrays (vectors) and compile 
                   * with -DUseManualAlignment you may add 
                   * \code
                   #pragma vector aligned
                   #pragma simd
                   \endcode to this for loop to enforce your compiler to use SSE/AVX.
                   * 
                   * The alignment is tied to the unpacked records, i.e. for packed class
                   * variants the machine's natural alignment is switched off to recude the  
                   * memory footprint. Do not use any SSE/AVX operations or 
                   * vectorisation on the result for the packed variants, as the data is misaligned. 
                   * If you rely on vectorisation, convert the underlying record 
                   * into the unpacked version first. 
                   * 
                   * @see convert()
                   */
                  inline void setCentreOfMass(const tarch::la::Vector<DIMENSIONS,double>& centreOfMass) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     _persistentRecords._centreOfMass = (centreOfMass);
                  }
                  
                  
                  
                  inline double getCentreOfMass(int elementIndex) const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     assertion(elementIndex>=0);
                     assertion(elementIndex<DIMENSIONS);
                     return _persistentRecords._centreOfMass[elementIndex];
                     
                  }
                  
                  
                  
                  inline void setCentreOfMass(int elementIndex, const double& centreOfMass) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     assertion(elementIndex>=0);
                     assertion(elementIndex<DIMENSIONS);
                     _persistentRecords._centreOfMass[elementIndex]= centreOfMass;
                     
                  }
                  
                  
                  
                  inline int getGlobalParticleNumber() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     return _persistentRecords._globalParticleNumber;
                  }
                  
                  
                  
                  inline void setGlobalParticleNumber(const int& globalParticleNumber) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     _persistentRecords._globalParticleNumber = globalParticleNumber;
                  }
                  
                  
                  
                  inline int getNumberOfTriangles() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     return _persistentRecords._numberOfTriangles;
                  }
                  
                  
                  
                  inline void setNumberOfTriangles(const int& numberOfTriangles) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     _persistentRecords._numberOfTriangles = numberOfTriangles;
                  }
                  
                  
                  
                  /**
                   * Generated and optimized
                   * 
                   * If you realise a for loop using exclusively arrays (vectors) and compile 
                   * with -DUseManualAlignment you may add 
                   * \code
                   #pragma vector aligned
                   #pragma simd
                   \endcode to this for loop to enforce your compiler to use SSE/AVX.
                   * 
                   * The alignment is tied to the unpacked records, i.e. for packed class
                   * variants the machine's natural alignment is switched off to recude the  
                   * memory footprint. Do not use any SSE/AVX operations or 
                   * vectorisation on the result for the packed variants, as the data is misaligned. 
                   * If you rely on vectorisation, convert the underlying record 
                   * into the unpacked version first. 
                   * 
                   * @see convert()
                   */
                  inline tarch::la::Vector<DIMENSIONS,int> getVertices() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     return _persistentRecords._vertices;
                  }
                  
                  
                  
                  /**
                   * Generated and optimized
                   * 
                   * If you realise a for loop using exclusively arrays (vectors) and compile 
                   * with -DUseManualAlignment you may add 
                   * \code
                   #pragma vector aligned
                   #pragma simd
                   \endcode to this for loop to enforce your compiler to use SSE/AVX.
                   * 
                   * The alignment is tied to the unpacked records, i.e. for packed class
                   * variants the machine's natural alignment is switched off to recude the  
                   * memory footprint. Do not use any SSE/AVX operations or 
                   * vectorisation on the result for the packed variants, as the data is misaligned. 
                   * If you rely on vectorisation, convert the underlying record 
                   * into the unpacked version first. 
                   * 
                   * @see convert()
                   */
                  inline void setVertices(const tarch::la::Vector<DIMENSIONS,int>& vertices) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     _persistentRecords._vertices = (vertices);
                  }
                  
                  
                  
                  inline int getVertices(int elementIndex) const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     assertion(elementIndex>=0);
                     assertion(elementIndex<DIMENSIONS);
                     return _persistentRecords._vertices[elementIndex];
                     
                  }
                  
                  
                  
                  inline void setVertices(int elementIndex, const int& vertices) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     assertion(elementIndex>=0);
                     assertion(elementIndex<DIMENSIONS);
                     _persistentRecords._vertices[elementIndex]= vertices;
                     
                  }
                  
                  
                  /**
                   * Generated
                   */
                  std::string toString() const;
                  
                  /**
                   * Generated
                   */
                  void toString(std::ostream& out) const;
                  
                  
                  PersistentRecords getPersistentRecords() const;
                  /**
                   * Generated
                   */
                  Particle convert() const;
                  
                  
               #ifdef Parallel
                  protected:
                     static tarch::logging::Log _log;
                     
                  public:
                     
                     /**
                      * Global that represents the mpi datatype.
                      * There are two variants: Datatype identifies only those attributes marked with
                      * parallelise. FullDatatype instead identifies the whole record with all fields.
                      */
                     static MPI_Datatype Datatype;
                     static MPI_Datatype FullDatatype;
                     
                     /**
                      * Initializes the data type for the mpi operations. Has to be called
                      * before the very first send or receive operation is called.
                      */
                     static void initDatatype();
                     
                     static void shutdownDatatype();
                     
                     /**
                      * @param communicateSleep -1 Data exchange through blocking mpi
                      * @param communicateSleep  0 Data exchange through non-blocking mpi, i.e. pending messages are received via polling until MPI_Test succeeds
                      * @param communicateSleep >0 Same as 0 but in addition, each unsuccessful MPI_Test is follows by an usleep
                      */
                     void send(int destination, int tag, bool exchangeOnlyAttributesMarkedWithParallelise, int communicateSleep);
                     
                     void receive(int source, int tag, bool exchangeOnlyAttributesMarkedWithParallelise, int communicateSleep);
                     
                     static bool isMessageInQueue(int tag, bool exchangeOnlyAttributesMarkedWithParallelise);
                     
                     #endif
                        
                     };
                     
                     #ifdef PackedRecords
                     #pragma pack (pop)
                     #endif
                     
                     
                     
                  #elif defined(Dim2) && defined(Dim3)
                     /**
                      * @author This class is generated by DaStGen
                      * 		   DataStructureGenerator (DaStGen)
                      * 		   2007-2009 Wolfgang Eckhardt
                      * 		   2012      Tobias Weinzierl
                      *
                      * 		   build date: 09-02-2014 14:40
                      *
                      * @date   26/08/2016 13:52
                      */
                     class dem::records::Particle { 
                        
                        public:
                           
                           typedef dem::records::ParticlePacked Packed;
                           
                           struct PersistentRecords {
                              #ifdef UseManualAlignment
                              tarch::la::Vector<DIMENSIONS,double> _centre __attribute__((aligned(VectorisationAlignment)));
                              #else
                              tarch::la::Vector<DIMENSIONS,double> _centre;
                              #endif
                              #ifdef UseManualAlignment
                              tarch::la::Vector<DIMENSIONS,double> _velocity __attribute__((aligned(VectorisationAlignment)));
                              #else
                              tarch::la::Vector<DIMENSIONS,double> _velocity;
                              #endif
                              double _diameter;
                              double _radius;
                              double _epsilon;
                              double _mass;
                              double _hMin;
                              #ifdef UseManualAlignment
                              tarch::la::Vector<DIMENSIONS,double> _centreOfMass __attribute__((aligned(VectorisationAlignment)));
                              #else
                              tarch::la::Vector<DIMENSIONS,double> _centreOfMass;
                              #endif
                              int _globalParticleNumber;
                              double _angularVelocity;
                              #ifdef UseManualAlignment
                              tarch::la::Vector<DIMENSIONS,double> _angularVelocity __attribute__((aligned(VectorisationAlignment)));
                              #else
                              tarch::la::Vector<DIMENSIONS,double> _angularVelocity;
                              #endif
                              int _numberOfTriangles;
                              #ifdef UseManualAlignment
                              tarch::la::Vector<DIMENSIONS,int> _vertices __attribute__((aligned(VectorisationAlignment)));
                              #else
                              tarch::la::Vector<DIMENSIONS,int> _vertices;
                              #endif
                              /**
                               * Generated
                               */
                              PersistentRecords();
                              
                              /**
                               * Generated
                               */
                              PersistentRecords(const tarch::la::Vector<DIMENSIONS,double>& centre, const tarch::la::Vector<DIMENSIONS,double>& velocity, const double& diameter, const double& radius, const double& epsilon, const double& mass, const double& hMin, const tarch::la::Vector<DIMENSIONS,double>& centreOfMass, const int& globalParticleNumber, const double& angularVelocity, const tarch::la::Vector<DIMENSIONS,double>& angularVelocity, const int& numberOfTriangles, const tarch::la::Vector<DIMENSIONS,int>& vertices);
                              
                              
                              /**
                               * Generated and optimized
                               * 
                               * If you realise a for loop using exclusively arrays (vectors) and compile 
                               * with -DUseManualAlignment you may add 
                               * \code
                               #pragma vector aligned
                               #pragma simd
                               \endcode to this for loop to enforce your compiler to use SSE/AVX.
                               * 
                               * The alignment is tied to the unpacked records, i.e. for packed class
                               * variants the machine's natural alignment is switched off to recude the  
                               * memory footprint. Do not use any SSE/AVX operations or 
                               * vectorisation on the result for the packed variants, as the data is misaligned. 
                               * If you rely on vectorisation, convert the underlying record 
                               * into the unpacked version first. 
                               * 
                               * @see convert()
                               */
                              inline tarch::la::Vector<DIMENSIONS,double> getCentre() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                 return _centre;
                              }
                              
                              
                              
                              /**
                               * Generated and optimized
                               * 
                               * If you realise a for loop using exclusively arrays (vectors) and compile 
                               * with -DUseManualAlignment you may add 
                               * \code
                               #pragma vector aligned
                               #pragma simd
                               \endcode to this for loop to enforce your compiler to use SSE/AVX.
                               * 
                               * The alignment is tied to the unpacked records, i.e. for packed class
                               * variants the machine's natural alignment is switched off to recude the  
                               * memory footprint. Do not use any SSE/AVX operations or 
                               * vectorisation on the result for the packed variants, as the data is misaligned. 
                               * If you rely on vectorisation, convert the underlying record 
                               * into the unpacked version first. 
                               * 
                               * @see convert()
                               */
                              inline void setCentre(const tarch::la::Vector<DIMENSIONS,double>& centre) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                 _centre = (centre);
                              }
                              
                              
                              
                              /**
                               * Generated and optimized
                               * 
                               * If you realise a for loop using exclusively arrays (vectors) and compile 
                               * with -DUseManualAlignment you may add 
                               * \code
                               #pragma vector aligned
                               #pragma simd
                               \endcode to this for loop to enforce your compiler to use SSE/AVX.
                               * 
                               * The alignment is tied to the unpacked records, i.e. for packed class
                               * variants the machine's natural alignment is switched off to recude the  
                               * memory footprint. Do not use any SSE/AVX operations or 
                               * vectorisation on the result for the packed variants, as the data is misaligned. 
                               * If you rely on vectorisation, convert the underlying record 
                               * into the unpacked version first. 
                               * 
                               * @see convert()
                               */
                              inline tarch::la::Vector<DIMENSIONS,double> getVelocity() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                 return _velocity;
                              }
                              
                              
                              
                              /**
                               * Generated and optimized
                               * 
                               * If you realise a for loop using exclusively arrays (vectors) and compile 
                               * with -DUseManualAlignment you may add 
                               * \code
                               #pragma vector aligned
                               #pragma simd
                               \endcode to this for loop to enforce your compiler to use SSE/AVX.
                               * 
                               * The alignment is tied to the unpacked records, i.e. for packed class
                               * variants the machine's natural alignment is switched off to recude the  
                               * memory footprint. Do not use any SSE/AVX operations or 
                               * vectorisation on the result for the packed variants, as the data is misaligned. 
                               * If you rely on vectorisation, convert the underlying record 
                               * into the unpacked version first. 
                               * 
                               * @see convert()
                               */
                              inline void setVelocity(const tarch::la::Vector<DIMENSIONS,double>& velocity) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                 _velocity = (velocity);
                              }
                              
                              
                              
                              inline double getDiameter() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                 return _diameter;
                              }
                              
                              
                              
                              inline void setDiameter(const double& diameter) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                 _diameter = diameter;
                              }
                              
                              
                              
                              inline double getRadius() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                 return _radius;
                              }
                              
                              
                              
                              inline void setRadius(const double& radius) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                 _radius = radius;
                              }
                              
                              
                              
                              inline double getEpsilon() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                 return _epsilon;
                              }
                              
                              
                              
                              inline void setEpsilon(const double& epsilon) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                 _epsilon = epsilon;
                              }
                              
                              
                              
                              inline double getMass() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                 return _mass;
                              }
                              
                              
                              
                              inline void setMass(const double& mass) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                 _mass = mass;
                              }
                              
                              
                              
                              inline double getHMin() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                 return _hMin;
                              }
                              
                              
                              
                              inline void setHMin(const double& hMin) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                 _hMin = hMin;
                              }
                              
                              
                              
                              /**
                               * Generated and optimized
                               * 
                               * If you realise a for loop using exclusively arrays (vectors) and compile 
                               * with -DUseManualAlignment you may add 
                               * \code
                               #pragma vector aligned
                               #pragma simd
                               \endcode to this for loop to enforce your compiler to use SSE/AVX.
                               * 
                               * The alignment is tied to the unpacked records, i.e. for packed class
                               * variants the machine's natural alignment is switched off to recude the  
                               * memory footprint. Do not use any SSE/AVX operations or 
                               * vectorisation on the result for the packed variants, as the data is misaligned. 
                               * If you rely on vectorisation, convert the underlying record 
                               * into the unpacked version first. 
                               * 
                               * @see convert()
                               */
                              inline tarch::la::Vector<DIMENSIONS,double> getCentreOfMass() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                 return _centreOfMass;
                              }
                              
                              
                              
                              /**
                               * Generated and optimized
                               * 
                               * If you realise a for loop using exclusively arrays (vectors) and compile 
                               * with -DUseManualAlignment you may add 
                               * \code
                               #pragma vector aligned
                               #pragma simd
                               \endcode to this for loop to enforce your compiler to use SSE/AVX.
                               * 
                               * The alignment is tied to the unpacked records, i.e. for packed class
                               * variants the machine's natural alignment is switched off to recude the  
                               * memory footprint. Do not use any SSE/AVX operations or 
                               * vectorisation on the result for the packed variants, as the data is misaligned. 
                               * If you rely on vectorisation, convert the underlying record 
                               * into the unpacked version first. 
                               * 
                               * @see convert()
                               */
                              inline void setCentreOfMass(const tarch::la::Vector<DIMENSIONS,double>& centreOfMass) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                 _centreOfMass = (centreOfMass);
                              }
                              
                              
                              
                              inline int getGlobalParticleNumber() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                 return _globalParticleNumber;
                              }
                              
                              
                              
                              inline void setGlobalParticleNumber(const int& globalParticleNumber) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                 _globalParticleNumber = globalParticleNumber;
                              }
                              
                              
                              
                              inline double getAngularVelocity() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                 return _angularVelocity;
                              }
                              
                              
                              
                              inline void setAngularVelocity(const double& angularVelocity) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                 _angularVelocity = angularVelocity;
                              }
                              
                              
                              
                              /**
                               * Generated and optimized
                               * 
                               * If you realise a for loop using exclusively arrays (vectors) and compile 
                               * with -DUseManualAlignment you may add 
                               * \code
                               #pragma vector aligned
                               #pragma simd
                               \endcode to this for loop to enforce your compiler to use SSE/AVX.
                               * 
                               * The alignment is tied to the unpacked records, i.e. for packed class
                               * variants the machine's natural alignment is switched off to recude the  
                               * memory footprint. Do not use any SSE/AVX operations or 
                               * vectorisation on the result for the packed variants, as the data is misaligned. 
                               * If you rely on vectorisation, convert the underlying record 
                               * into the unpacked version first. 
                               * 
                               * @see convert()
                               */
                              inline tarch::la::Vector<DIMENSIONS,double> getAngularVelocity() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                 return _angularVelocity;
                              }
                              
                              
                              
                              /**
                               * Generated and optimized
                               * 
                               * If you realise a for loop using exclusively arrays (vectors) and compile 
                               * with -DUseManualAlignment you may add 
                               * \code
                               #pragma vector aligned
                               #pragma simd
                               \endcode to this for loop to enforce your compiler to use SSE/AVX.
                               * 
                               * The alignment is tied to the unpacked records, i.e. for packed class
                               * variants the machine's natural alignment is switched off to recude the  
                               * memory footprint. Do not use any SSE/AVX operations or 
                               * vectorisation on the result for the packed variants, as the data is misaligned. 
                               * If you rely on vectorisation, convert the underlying record 
                               * into the unpacked version first. 
                               * 
                               * @see convert()
                               */
                              inline void setAngularVelocity(const tarch::la::Vector<DIMENSIONS,double>& angularVelocity) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                 _angularVelocity = (angularVelocity);
                              }
                              
                              
                              
                              inline int getNumberOfTriangles() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                 return _numberOfTriangles;
                              }
                              
                              
                              
                              inline void setNumberOfTriangles(const int& numberOfTriangles) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                 _numberOfTriangles = numberOfTriangles;
                              }
                              
                              
                              
                              /**
                               * Generated and optimized
                               * 
                               * If you realise a for loop using exclusively arrays (vectors) and compile 
                               * with -DUseManualAlignment you may add 
                               * \code
                               #pragma vector aligned
                               #pragma simd
                               \endcode to this for loop to enforce your compiler to use SSE/AVX.
                               * 
                               * The alignment is tied to the unpacked records, i.e. for packed class
                               * variants the machine's natural alignment is switched off to recude the  
                               * memory footprint. Do not use any SSE/AVX operations or 
                               * vectorisation on the result for the packed variants, as the data is misaligned. 
                               * If you rely on vectorisation, convert the underlying record 
                               * into the unpacked version first. 
                               * 
                               * @see convert()
                               */
                              inline tarch::la::Vector<DIMENSIONS,int> getVertices() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                 return _vertices;
                              }
                              
                              
                              
                              /**
                               * Generated and optimized
                               * 
                               * If you realise a for loop using exclusively arrays (vectors) and compile 
                               * with -DUseManualAlignment you may add 
                               * \code
                               #pragma vector aligned
                               #pragma simd
                               \endcode to this for loop to enforce your compiler to use SSE/AVX.
                               * 
                               * The alignment is tied to the unpacked records, i.e. for packed class
                               * variants the machine's natural alignment is switched off to recude the  
                               * memory footprint. Do not use any SSE/AVX operations or 
                               * vectorisation on the result for the packed variants, as the data is misaligned. 
                               * If you rely on vectorisation, convert the underlying record 
                               * into the unpacked version first. 
                               * 
                               * @see convert()
                               */
                              inline void setVertices(const tarch::la::Vector<DIMENSIONS,int>& vertices) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                 _vertices = (vertices);
                              }
                              
                              
                              
                           };
                           
                        private: 
                           public:

                           PersistentRecords _persistentRecords;
                           private:

                           
                        public:
                           /**
                            * Generated
                            */
                           Particle();
                           
                           /**
                            * Generated
                            */
                           Particle(const PersistentRecords& persistentRecords);
                           
                           /**
                            * Generated
                            */
                           Particle(const tarch::la::Vector<DIMENSIONS,double>& centre, const tarch::la::Vector<DIMENSIONS,double>& velocity, const double& diameter, const double& radius, const double& epsilon, const double& mass, const double& hMin, const tarch::la::Vector<DIMENSIONS,double>& centreOfMass, const int& globalParticleNumber, const tarch::la::Vector<DIMENSIONS,double>& angularVelocity, const double& angularVelocity, const int& numberOfTriangles, const tarch::la::Vector<DIMENSIONS,int>& vertices);
                           
                           /**
                            * Generated
                            */
                           ~Particle();
                           
                           
                           /**
                            * Generated and optimized
                            * 
                            * If you realise a for loop using exclusively arrays (vectors) and compile 
                            * with -DUseManualAlignment you may add 
                            * \code
                            #pragma vector aligned
                            #pragma simd
                            \endcode to this for loop to enforce your compiler to use SSE/AVX.
                            * 
                            * The alignment is tied to the unpacked records, i.e. for packed class
                            * variants the machine's natural alignment is switched off to recude the  
                            * memory footprint. Do not use any SSE/AVX operations or 
                            * vectorisation on the result for the packed variants, as the data is misaligned. 
                            * If you rely on vectorisation, convert the underlying record 
                            * into the unpacked version first. 
                            * 
                            * @see convert()
                            */
                           inline tarch::la::Vector<DIMENSIONS,double> getCentre() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                              return _persistentRecords._centre;
                           }
                           
                           
                           
                           /**
                            * Generated and optimized
                            * 
                            * If you realise a for loop using exclusively arrays (vectors) and compile 
                            * with -DUseManualAlignment you may add 
                            * \code
                            #pragma vector aligned
                            #pragma simd
                            \endcode to this for loop to enforce your compiler to use SSE/AVX.
                            * 
                            * The alignment is tied to the unpacked records, i.e. for packed class
                            * variants the machine's natural alignment is switched off to recude the  
                            * memory footprint. Do not use any SSE/AVX operations or 
                            * vectorisation on the result for the packed variants, as the data is misaligned. 
                            * If you rely on vectorisation, convert the underlying record 
                            * into the unpacked version first. 
                            * 
                            * @see convert()
                            */
                           inline void setCentre(const tarch::la::Vector<DIMENSIONS,double>& centre) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                              _persistentRecords._centre = (centre);
                           }
                           
                           
                           
                           inline double getCentre(int elementIndex) const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                              assertion(elementIndex>=0);
                              assertion(elementIndex<DIMENSIONS);
                              return _persistentRecords._centre[elementIndex];
                              
                           }
                           
                           
                           
                           inline void setCentre(int elementIndex, const double& centre) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                              assertion(elementIndex>=0);
                              assertion(elementIndex<DIMENSIONS);
                              _persistentRecords._centre[elementIndex]= centre;
                              
                           }
                           
                           
                           
                           /**
                            * Generated and optimized
                            * 
                            * If you realise a for loop using exclusively arrays (vectors) and compile 
                            * with -DUseManualAlignment you may add 
                            * \code
                            #pragma vector aligned
                            #pragma simd
                            \endcode to this for loop to enforce your compiler to use SSE/AVX.
                            * 
                            * The alignment is tied to the unpacked records, i.e. for packed class
                            * variants the machine's natural alignment is switched off to recude the  
                            * memory footprint. Do not use any SSE/AVX operations or 
                            * vectorisation on the result for the packed variants, as the data is misaligned. 
                            * If you rely on vectorisation, convert the underlying record 
                            * into the unpacked version first. 
                            * 
                            * @see convert()
                            */
                           inline tarch::la::Vector<DIMENSIONS,double> getVelocity() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                              return _persistentRecords._velocity;
                           }
                           
                           
                           
                           /**
                            * Generated and optimized
                            * 
                            * If you realise a for loop using exclusively arrays (vectors) and compile 
                            * with -DUseManualAlignment you may add 
                            * \code
                            #pragma vector aligned
                            #pragma simd
                            \endcode to this for loop to enforce your compiler to use SSE/AVX.
                            * 
                            * The alignment is tied to the unpacked records, i.e. for packed class
                            * variants the machine's natural alignment is switched off to recude the  
                            * memory footprint. Do not use any SSE/AVX operations or 
                            * vectorisation on the result for the packed variants, as the data is misaligned. 
                            * If you rely on vectorisation, convert the underlying record 
                            * into the unpacked version first. 
                            * 
                            * @see convert()
                            */
                           inline void setVelocity(const tarch::la::Vector<DIMENSIONS,double>& velocity) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                              _persistentRecords._velocity = (velocity);
                           }
                           
                           
                           
                           inline double getVelocity(int elementIndex) const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                              assertion(elementIndex>=0);
                              assertion(elementIndex<DIMENSIONS);
                              return _persistentRecords._velocity[elementIndex];
                              
                           }
                           
                           
                           
                           inline void setVelocity(int elementIndex, const double& velocity) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                              assertion(elementIndex>=0);
                              assertion(elementIndex<DIMENSIONS);
                              _persistentRecords._velocity[elementIndex]= velocity;
                              
                           }
                           
                           
                           
                           inline double getDiameter() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                              return _persistentRecords._diameter;
                           }
                           
                           
                           
                           inline void setDiameter(const double& diameter) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                              _persistentRecords._diameter = diameter;
                           }
                           
                           
                           
                           inline double getRadius() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                              return _persistentRecords._radius;
                           }
                           
                           
                           
                           inline void setRadius(const double& radius) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                              _persistentRecords._radius = radius;
                           }
                           
                           
                           
                           inline double getEpsilon() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                              return _persistentRecords._epsilon;
                           }
                           
                           
                           
                           inline void setEpsilon(const double& epsilon) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                              _persistentRecords._epsilon = epsilon;
                           }
                           
                           
                           
                           inline double getMass() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                              return _persistentRecords._mass;
                           }
                           
                           
                           
                           inline void setMass(const double& mass) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                              _persistentRecords._mass = mass;
                           }
                           
                           
                           
                           inline double getHMin() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                              return _persistentRecords._hMin;
                           }
                           
                           
                           
                           inline void setHMin(const double& hMin) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                              _persistentRecords._hMin = hMin;
                           }
                           
                           
                           
                           /**
                            * Generated and optimized
                            * 
                            * If you realise a for loop using exclusively arrays (vectors) and compile 
                            * with -DUseManualAlignment you may add 
                            * \code
                            #pragma vector aligned
                            #pragma simd
                            \endcode to this for loop to enforce your compiler to use SSE/AVX.
                            * 
                            * The alignment is tied to the unpacked records, i.e. for packed class
                            * variants the machine's natural alignment is switched off to recude the  
                            * memory footprint. Do not use any SSE/AVX operations or 
                            * vectorisation on the result for the packed variants, as the data is misaligned. 
                            * If you rely on vectorisation, convert the underlying record 
                            * into the unpacked version first. 
                            * 
                            * @see convert()
                            */
                           inline tarch::la::Vector<DIMENSIONS,double> getCentreOfMass() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                              return _persistentRecords._centreOfMass;
                           }
                           
                           
                           
                           /**
                            * Generated and optimized
                            * 
                            * If you realise a for loop using exclusively arrays (vectors) and compile 
                            * with -DUseManualAlignment you may add 
                            * \code
                            #pragma vector aligned
                            #pragma simd
                            \endcode to this for loop to enforce your compiler to use SSE/AVX.
                            * 
                            * The alignment is tied to the unpacked records, i.e. for packed class
                            * variants the machine's natural alignment is switched off to recude the  
                            * memory footprint. Do not use any SSE/AVX operations or 
                            * vectorisation on the result for the packed variants, as the data is misaligned. 
                            * If you rely on vectorisation, convert the underlying record 
                            * into the unpacked version first. 
                            * 
                            * @see convert()
                            */
                           inline void setCentreOfMass(const tarch::la::Vector<DIMENSIONS,double>& centreOfMass) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                              _persistentRecords._centreOfMass = (centreOfMass);
                           }
                           
                           
                           
                           inline double getCentreOfMass(int elementIndex) const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                              assertion(elementIndex>=0);
                              assertion(elementIndex<DIMENSIONS);
                              return _persistentRecords._centreOfMass[elementIndex];
                              
                           }
                           
                           
                           
                           inline void setCentreOfMass(int elementIndex, const double& centreOfMass) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                              assertion(elementIndex>=0);
                              assertion(elementIndex<DIMENSIONS);
                              _persistentRecords._centreOfMass[elementIndex]= centreOfMass;
                              
                           }
                           
                           
                           
                           inline int getGlobalParticleNumber() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                              return _persistentRecords._globalParticleNumber;
                           }
                           
                           
                           
                           inline void setGlobalParticleNumber(const int& globalParticleNumber) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                              _persistentRecords._globalParticleNumber = globalParticleNumber;
                           }
                           
                           
                           
                           /**
                            * Generated and optimized
                            * 
                            * If you realise a for loop using exclusively arrays (vectors) and compile 
                            * with -DUseManualAlignment you may add 
                            * \code
                            #pragma vector aligned
                            #pragma simd
                            \endcode to this for loop to enforce your compiler to use SSE/AVX.
                            * 
                            * The alignment is tied to the unpacked records, i.e. for packed class
                            * variants the machine's natural alignment is switched off to recude the  
                            * memory footprint. Do not use any SSE/AVX operations or 
                            * vectorisation on the result for the packed variants, as the data is misaligned. 
                            * If you rely on vectorisation, convert the underlying record 
                            * into the unpacked version first. 
                            * 
                            * @see convert()
                            */
                           inline tarch::la::Vector<DIMENSIONS,double> getAngularVelocity() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                              return _persistentRecords._angularVelocity;
                           }
                           
                           
                           
                           /**
                            * Generated and optimized
                            * 
                            * If you realise a for loop using exclusively arrays (vectors) and compile 
                            * with -DUseManualAlignment you may add 
                            * \code
                            #pragma vector aligned
                            #pragma simd
                            \endcode to this for loop to enforce your compiler to use SSE/AVX.
                            * 
                            * The alignment is tied to the unpacked records, i.e. for packed class
                            * variants the machine's natural alignment is switched off to recude the  
                            * memory footprint. Do not use any SSE/AVX operations or 
                            * vectorisation on the result for the packed variants, as the data is misaligned. 
                            * If you rely on vectorisation, convert the underlying record 
                            * into the unpacked version first. 
                            * 
                            * @see convert()
                            */
                           inline void setAngularVelocity(const tarch::la::Vector<DIMENSIONS,double>& angularVelocity) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                              _persistentRecords._angularVelocity = (angularVelocity);
                           }
                           
                           
                           
                           inline double getAngularVelocity(int elementIndex) const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                              assertion(elementIndex>=0);
                              assertion(elementIndex<DIMENSIONS);
                              return _persistentRecords._angularVelocity[elementIndex];
                              
                           }
                           
                           
                           
                           inline void setAngularVelocity(int elementIndex, const double& angularVelocity) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                              assertion(elementIndex>=0);
                              assertion(elementIndex<DIMENSIONS);
                              _persistentRecords._angularVelocity[elementIndex]= angularVelocity;
                              
                           }
                           
                           
                           
                           inline double getAngularVelocity() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                              return _persistentRecords._angularVelocity;
                           }
                           
                           
                           
                           inline void setAngularVelocity(const double& angularVelocity) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                              _persistentRecords._angularVelocity = angularVelocity;
                           }
                           
                           
                           
                           inline int getNumberOfTriangles() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                              return _persistentRecords._numberOfTriangles;
                           }
                           
                           
                           
                           inline void setNumberOfTriangles(const int& numberOfTriangles) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                              _persistentRecords._numberOfTriangles = numberOfTriangles;
                           }
                           
                           
                           
                           /**
                            * Generated and optimized
                            * 
                            * If you realise a for loop using exclusively arrays (vectors) and compile 
                            * with -DUseManualAlignment you may add 
                            * \code
                            #pragma vector aligned
                            #pragma simd
                            \endcode to this for loop to enforce your compiler to use SSE/AVX.
                            * 
                            * The alignment is tied to the unpacked records, i.e. for packed class
                            * variants the machine's natural alignment is switched off to recude the  
                            * memory footprint. Do not use any SSE/AVX operations or 
                            * vectorisation on the result for the packed variants, as the data is misaligned. 
                            * If you rely on vectorisation, convert the underlying record 
                            * into the unpacked version first. 
                            * 
                            * @see convert()
                            */
                           inline tarch::la::Vector<DIMENSIONS,int> getVertices() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                              return _persistentRecords._vertices;
                           }
                           
                           
                           
                           /**
                            * Generated and optimized
                            * 
                            * If you realise a for loop using exclusively arrays (vectors) and compile 
                            * with -DUseManualAlignment you may add 
                            * \code
                            #pragma vector aligned
                            #pragma simd
                            \endcode to this for loop to enforce your compiler to use SSE/AVX.
                            * 
                            * The alignment is tied to the unpacked records, i.e. for packed class
                            * variants the machine's natural alignment is switched off to recude the  
                            * memory footprint. Do not use any SSE/AVX operations or 
                            * vectorisation on the result for the packed variants, as the data is misaligned. 
                            * If you rely on vectorisation, convert the underlying record 
                            * into the unpacked version first. 
                            * 
                            * @see convert()
                            */
                           inline void setVertices(const tarch::la::Vector<DIMENSIONS,int>& vertices) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                              _persistentRecords._vertices = (vertices);
                           }
                           
                           
                           
                           inline int getVertices(int elementIndex) const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                              assertion(elementIndex>=0);
                              assertion(elementIndex<DIMENSIONS);
                              return _persistentRecords._vertices[elementIndex];
                              
                           }
                           
                           
                           
                           inline void setVertices(int elementIndex, const int& vertices) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                              assertion(elementIndex>=0);
                              assertion(elementIndex<DIMENSIONS);
                              _persistentRecords._vertices[elementIndex]= vertices;
                              
                           }
                           
                           
                           /**
                            * Generated
                            */
                           std::string toString() const;
                           
                           /**
                            * Generated
                            */
                           void toString(std::ostream& out) const;
                           
                           
                           PersistentRecords getPersistentRecords() const;
                           /**
                            * Generated
                            */
                           ParticlePacked convert() const;
                           
                           
                        #ifdef Parallel
                           protected:
                              static tarch::logging::Log _log;
                              
                           public:
                              
                              /**
                               * Global that represents the mpi datatype.
                               * There are two variants: Datatype identifies only those attributes marked with
                               * parallelise. FullDatatype instead identifies the whole record with all fields.
                               */
                              static MPI_Datatype Datatype;
                              static MPI_Datatype FullDatatype;
                              
                              /**
                               * Initializes the data type for the mpi operations. Has to be called
                               * before the very first send or receive operation is called.
                               */
                              static void initDatatype();
                              
                              static void shutdownDatatype();
                              
                              /**
                               * @param communicateSleep -1 Data exchange through blocking mpi
                               * @param communicateSleep  0 Data exchange through non-blocking mpi, i.e. pending messages are received via polling until MPI_Test succeeds
                               * @param communicateSleep >0 Same as 0 but in addition, each unsuccessful MPI_Test is follows by an usleep
                               */
                              void send(int destination, int tag, bool exchangeOnlyAttributesMarkedWithParallelise, int communicateSleep);
                              
                              void receive(int source, int tag, bool exchangeOnlyAttributesMarkedWithParallelise, int communicateSleep);
                              
                              static bool isMessageInQueue(int tag, bool exchangeOnlyAttributesMarkedWithParallelise);
                              
                              #endif
                                 
                              };
                              
                              #ifndef DaStGenPackedPadding
                                #define DaStGenPackedPadding 1      // 32 bit version
                                // #define DaStGenPackedPadding 2   // 64 bit version
                              #endif
                              
                              
                              #ifdef PackedRecords
                                 #pragma pack (push, DaStGenPackedPadding)
                              #endif
                              
                              /**
                               * @author This class is generated by DaStGen
                               * 		   DataStructureGenerator (DaStGen)
                               * 		   2007-2009 Wolfgang Eckhardt
                               * 		   2012      Tobias Weinzierl
                               *
                               * 		   build date: 09-02-2014 14:40
                               *
                               * @date   26/08/2016 13:52
                               */
                              class dem::records::ParticlePacked { 
                                 
                                 public:
                                    
                                    struct PersistentRecords {
                                       tarch::la::Vector<DIMENSIONS,double> _centre;
                                       tarch::la::Vector<DIMENSIONS,double> _velocity;
                                       double _diameter;
                                       double _radius;
                                       double _epsilon;
                                       double _mass;
                                       double _hMin;
                                       tarch::la::Vector<DIMENSIONS,double> _centreOfMass;
                                       int _globalParticleNumber;
                                       double _angularVelocity;
                                       tarch::la::Vector<DIMENSIONS,double> _angularVelocity;
                                       int _numberOfTriangles;
                                       tarch::la::Vector<DIMENSIONS,int> _vertices;
                                       /**
                                        * Generated
                                        */
                                       PersistentRecords();
                                       
                                       /**
                                        * Generated
                                        */
                                       PersistentRecords(const tarch::la::Vector<DIMENSIONS,double>& centre, const tarch::la::Vector<DIMENSIONS,double>& velocity, const double& diameter, const double& radius, const double& epsilon, const double& mass, const double& hMin, const tarch::la::Vector<DIMENSIONS,double>& centreOfMass, const int& globalParticleNumber, const double& angularVelocity, const tarch::la::Vector<DIMENSIONS,double>& angularVelocity, const int& numberOfTriangles, const tarch::la::Vector<DIMENSIONS,int>& vertices);
                                       
                                       
                                       /**
                                        * Generated and optimized
                                        * 
                                        * If you realise a for loop using exclusively arrays (vectors) and compile 
                                        * with -DUseManualAlignment you may add 
                                        * \code
                                        #pragma vector aligned
                                        #pragma simd
                                        \endcode to this for loop to enforce your compiler to use SSE/AVX.
                                        * 
                                        * The alignment is tied to the unpacked records, i.e. for packed class
                                        * variants the machine's natural alignment is switched off to recude the  
                                        * memory footprint. Do not use any SSE/AVX operations or 
                                        * vectorisation on the result for the packed variants, as the data is misaligned. 
                                        * If you rely on vectorisation, convert the underlying record 
                                        * into the unpacked version first. 
                                        * 
                                        * @see convert()
                                        */
                                       inline tarch::la::Vector<DIMENSIONS,double> getCentre() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                          return _centre;
                                       }
                                       
                                       
                                       
                                       /**
                                        * Generated and optimized
                                        * 
                                        * If you realise a for loop using exclusively arrays (vectors) and compile 
                                        * with -DUseManualAlignment you may add 
                                        * \code
                                        #pragma vector aligned
                                        #pragma simd
                                        \endcode to this for loop to enforce your compiler to use SSE/AVX.
                                        * 
                                        * The alignment is tied to the unpacked records, i.e. for packed class
                                        * variants the machine's natural alignment is switched off to recude the  
                                        * memory footprint. Do not use any SSE/AVX operations or 
                                        * vectorisation on the result for the packed variants, as the data is misaligned. 
                                        * If you rely on vectorisation, convert the underlying record 
                                        * into the unpacked version first. 
                                        * 
                                        * @see convert()
                                        */
                                       inline void setCentre(const tarch::la::Vector<DIMENSIONS,double>& centre) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                          _centre = (centre);
                                       }
                                       
                                       
                                       
                                       /**
                                        * Generated and optimized
                                        * 
                                        * If you realise a for loop using exclusively arrays (vectors) and compile 
                                        * with -DUseManualAlignment you may add 
                                        * \code
                                        #pragma vector aligned
                                        #pragma simd
                                        \endcode to this for loop to enforce your compiler to use SSE/AVX.
                                        * 
                                        * The alignment is tied to the unpacked records, i.e. for packed class
                                        * variants the machine's natural alignment is switched off to recude the  
                                        * memory footprint. Do not use any SSE/AVX operations or 
                                        * vectorisation on the result for the packed variants, as the data is misaligned. 
                                        * If you rely on vectorisation, convert the underlying record 
                                        * into the unpacked version first. 
                                        * 
                                        * @see convert()
                                        */
                                       inline tarch::la::Vector<DIMENSIONS,double> getVelocity() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                          return _velocity;
                                       }
                                       
                                       
                                       
                                       /**
                                        * Generated and optimized
                                        * 
                                        * If you realise a for loop using exclusively arrays (vectors) and compile 
                                        * with -DUseManualAlignment you may add 
                                        * \code
                                        #pragma vector aligned
                                        #pragma simd
                                        \endcode to this for loop to enforce your compiler to use SSE/AVX.
                                        * 
                                        * The alignment is tied to the unpacked records, i.e. for packed class
                                        * variants the machine's natural alignment is switched off to recude the  
                                        * memory footprint. Do not use any SSE/AVX operations or 
                                        * vectorisation on the result for the packed variants, as the data is misaligned. 
                                        * If you rely on vectorisation, convert the underlying record 
                                        * into the unpacked version first. 
                                        * 
                                        * @see convert()
                                        */
                                       inline void setVelocity(const tarch::la::Vector<DIMENSIONS,double>& velocity) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                          _velocity = (velocity);
                                       }
                                       
                                       
                                       
                                       inline double getDiameter() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                          return _diameter;
                                       }
                                       
                                       
                                       
                                       inline void setDiameter(const double& diameter) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                          _diameter = diameter;
                                       }
                                       
                                       
                                       
                                       inline double getRadius() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                          return _radius;
                                       }
                                       
                                       
                                       
                                       inline void setRadius(const double& radius) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                          _radius = radius;
                                       }
                                       
                                       
                                       
                                       inline double getEpsilon() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                          return _epsilon;
                                       }
                                       
                                       
                                       
                                       inline void setEpsilon(const double& epsilon) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                          _epsilon = epsilon;
                                       }
                                       
                                       
                                       
                                       inline double getMass() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                          return _mass;
                                       }
                                       
                                       
                                       
                                       inline void setMass(const double& mass) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                          _mass = mass;
                                       }
                                       
                                       
                                       
                                       inline double getHMin() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                          return _hMin;
                                       }
                                       
                                       
                                       
                                       inline void setHMin(const double& hMin) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                          _hMin = hMin;
                                       }
                                       
                                       
                                       
                                       /**
                                        * Generated and optimized
                                        * 
                                        * If you realise a for loop using exclusively arrays (vectors) and compile 
                                        * with -DUseManualAlignment you may add 
                                        * \code
                                        #pragma vector aligned
                                        #pragma simd
                                        \endcode to this for loop to enforce your compiler to use SSE/AVX.
                                        * 
                                        * The alignment is tied to the unpacked records, i.e. for packed class
                                        * variants the machine's natural alignment is switched off to recude the  
                                        * memory footprint. Do not use any SSE/AVX operations or 
                                        * vectorisation on the result for the packed variants, as the data is misaligned. 
                                        * If you rely on vectorisation, convert the underlying record 
                                        * into the unpacked version first. 
                                        * 
                                        * @see convert()
                                        */
                                       inline tarch::la::Vector<DIMENSIONS,double> getCentreOfMass() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                          return _centreOfMass;
                                       }
                                       
                                       
                                       
                                       /**
                                        * Generated and optimized
                                        * 
                                        * If you realise a for loop using exclusively arrays (vectors) and compile 
                                        * with -DUseManualAlignment you may add 
                                        * \code
                                        #pragma vector aligned
                                        #pragma simd
                                        \endcode to this for loop to enforce your compiler to use SSE/AVX.
                                        * 
                                        * The alignment is tied to the unpacked records, i.e. for packed class
                                        * variants the machine's natural alignment is switched off to recude the  
                                        * memory footprint. Do not use any SSE/AVX operations or 
                                        * vectorisation on the result for the packed variants, as the data is misaligned. 
                                        * If you rely on vectorisation, convert the underlying record 
                                        * into the unpacked version first. 
                                        * 
                                        * @see convert()
                                        */
                                       inline void setCentreOfMass(const tarch::la::Vector<DIMENSIONS,double>& centreOfMass) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                          _centreOfMass = (centreOfMass);
                                       }
                                       
                                       
                                       
                                       inline int getGlobalParticleNumber() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                          return _globalParticleNumber;
                                       }
                                       
                                       
                                       
                                       inline void setGlobalParticleNumber(const int& globalParticleNumber) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                          _globalParticleNumber = globalParticleNumber;
                                       }
                                       
                                       
                                       
                                       inline double getAngularVelocity() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                          return _angularVelocity;
                                       }
                                       
                                       
                                       
                                       inline void setAngularVelocity(const double& angularVelocity) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                          _angularVelocity = angularVelocity;
                                       }
                                       
                                       
                                       
                                       /**
                                        * Generated and optimized
                                        * 
                                        * If you realise a for loop using exclusively arrays (vectors) and compile 
                                        * with -DUseManualAlignment you may add 
                                        * \code
                                        #pragma vector aligned
                                        #pragma simd
                                        \endcode to this for loop to enforce your compiler to use SSE/AVX.
                                        * 
                                        * The alignment is tied to the unpacked records, i.e. for packed class
                                        * variants the machine's natural alignment is switched off to recude the  
                                        * memory footprint. Do not use any SSE/AVX operations or 
                                        * vectorisation on the result for the packed variants, as the data is misaligned. 
                                        * If you rely on vectorisation, convert the underlying record 
                                        * into the unpacked version first. 
                                        * 
                                        * @see convert()
                                        */
                                       inline tarch::la::Vector<DIMENSIONS,double> getAngularVelocity() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                          return _angularVelocity;
                                       }
                                       
                                       
                                       
                                       /**
                                        * Generated and optimized
                                        * 
                                        * If you realise a for loop using exclusively arrays (vectors) and compile 
                                        * with -DUseManualAlignment you may add 
                                        * \code
                                        #pragma vector aligned
                                        #pragma simd
                                        \endcode to this for loop to enforce your compiler to use SSE/AVX.
                                        * 
                                        * The alignment is tied to the unpacked records, i.e. for packed class
                                        * variants the machine's natural alignment is switched off to recude the  
                                        * memory footprint. Do not use any SSE/AVX operations or 
                                        * vectorisation on the result for the packed variants, as the data is misaligned. 
                                        * If you rely on vectorisation, convert the underlying record 
                                        * into the unpacked version first. 
                                        * 
                                        * @see convert()
                                        */
                                       inline void setAngularVelocity(const tarch::la::Vector<DIMENSIONS,double>& angularVelocity) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                          _angularVelocity = (angularVelocity);
                                       }
                                       
                                       
                                       
                                       inline int getNumberOfTriangles() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                          return _numberOfTriangles;
                                       }
                                       
                                       
                                       
                                       inline void setNumberOfTriangles(const int& numberOfTriangles) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                          _numberOfTriangles = numberOfTriangles;
                                       }
                                       
                                       
                                       
                                       /**
                                        * Generated and optimized
                                        * 
                                        * If you realise a for loop using exclusively arrays (vectors) and compile 
                                        * with -DUseManualAlignment you may add 
                                        * \code
                                        #pragma vector aligned
                                        #pragma simd
                                        \endcode to this for loop to enforce your compiler to use SSE/AVX.
                                        * 
                                        * The alignment is tied to the unpacked records, i.e. for packed class
                                        * variants the machine's natural alignment is switched off to recude the  
                                        * memory footprint. Do not use any SSE/AVX operations or 
                                        * vectorisation on the result for the packed variants, as the data is misaligned. 
                                        * If you rely on vectorisation, convert the underlying record 
                                        * into the unpacked version first. 
                                        * 
                                        * @see convert()
                                        */
                                       inline tarch::la::Vector<DIMENSIONS,int> getVertices() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                          return _vertices;
                                       }
                                       
                                       
                                       
                                       /**
                                        * Generated and optimized
                                        * 
                                        * If you realise a for loop using exclusively arrays (vectors) and compile 
                                        * with -DUseManualAlignment you may add 
                                        * \code
                                        #pragma vector aligned
                                        #pragma simd
                                        \endcode to this for loop to enforce your compiler to use SSE/AVX.
                                        * 
                                        * The alignment is tied to the unpacked records, i.e. for packed class
                                        * variants the machine's natural alignment is switched off to recude the  
                                        * memory footprint. Do not use any SSE/AVX operations or 
                                        * vectorisation on the result for the packed variants, as the data is misaligned. 
                                        * If you rely on vectorisation, convert the underlying record 
                                        * into the unpacked version first. 
                                        * 
                                        * @see convert()
                                        */
                                       inline void setVertices(const tarch::la::Vector<DIMENSIONS,int>& vertices) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                          _vertices = (vertices);
                                       }
                                       
                                       
                                       
                                    };
                                    
                                 private: 
                                    PersistentRecords _persistentRecords;
                                    
                                 public:
                                    /**
                                     * Generated
                                     */
                                    ParticlePacked();
                                    
                                    /**
                                     * Generated
                                     */
                                    ParticlePacked(const PersistentRecords& persistentRecords);
                                    
                                    /**
                                     * Generated
                                     */
                                    ParticlePacked(const tarch::la::Vector<DIMENSIONS,double>& centre, const tarch::la::Vector<DIMENSIONS,double>& velocity, const double& diameter, const double& radius, const double& epsilon, const double& mass, const double& hMin, const tarch::la::Vector<DIMENSIONS,double>& centreOfMass, const int& globalParticleNumber, const tarch::la::Vector<DIMENSIONS,double>& angularVelocity, const double& angularVelocity, const int& numberOfTriangles, const tarch::la::Vector<DIMENSIONS,int>& vertices);
                                    
                                    /**
                                     * Generated
                                     */
                                    ~ParticlePacked();
                                    
                                    
                                    /**
                                     * Generated and optimized
                                     * 
                                     * If you realise a for loop using exclusively arrays (vectors) and compile 
                                     * with -DUseManualAlignment you may add 
                                     * \code
                                     #pragma vector aligned
                                     #pragma simd
                                     \endcode to this for loop to enforce your compiler to use SSE/AVX.
                                     * 
                                     * The alignment is tied to the unpacked records, i.e. for packed class
                                     * variants the machine's natural alignment is switched off to recude the  
                                     * memory footprint. Do not use any SSE/AVX operations or 
                                     * vectorisation on the result for the packed variants, as the data is misaligned. 
                                     * If you rely on vectorisation, convert the underlying record 
                                     * into the unpacked version first. 
                                     * 
                                     * @see convert()
                                     */
                                    inline tarch::la::Vector<DIMENSIONS,double> getCentre() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                       return _persistentRecords._centre;
                                    }
                                    
                                    
                                    
                                    /**
                                     * Generated and optimized
                                     * 
                                     * If you realise a for loop using exclusively arrays (vectors) and compile 
                                     * with -DUseManualAlignment you may add 
                                     * \code
                                     #pragma vector aligned
                                     #pragma simd
                                     \endcode to this for loop to enforce your compiler to use SSE/AVX.
                                     * 
                                     * The alignment is tied to the unpacked records, i.e. for packed class
                                     * variants the machine's natural alignment is switched off to recude the  
                                     * memory footprint. Do not use any SSE/AVX operations or 
                                     * vectorisation on the result for the packed variants, as the data is misaligned. 
                                     * If you rely on vectorisation, convert the underlying record 
                                     * into the unpacked version first. 
                                     * 
                                     * @see convert()
                                     */
                                    inline void setCentre(const tarch::la::Vector<DIMENSIONS,double>& centre) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                       _persistentRecords._centre = (centre);
                                    }
                                    
                                    
                                    
                                    inline double getCentre(int elementIndex) const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                       assertion(elementIndex>=0);
                                       assertion(elementIndex<DIMENSIONS);
                                       return _persistentRecords._centre[elementIndex];
                                       
                                    }
                                    
                                    
                                    
                                    inline void setCentre(int elementIndex, const double& centre) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                       assertion(elementIndex>=0);
                                       assertion(elementIndex<DIMENSIONS);
                                       _persistentRecords._centre[elementIndex]= centre;
                                       
                                    }
                                    
                                    
                                    
                                    /**
                                     * Generated and optimized
                                     * 
                                     * If you realise a for loop using exclusively arrays (vectors) and compile 
                                     * with -DUseManualAlignment you may add 
                                     * \code
                                     #pragma vector aligned
                                     #pragma simd
                                     \endcode to this for loop to enforce your compiler to use SSE/AVX.
                                     * 
                                     * The alignment is tied to the unpacked records, i.e. for packed class
                                     * variants the machine's natural alignment is switched off to recude the  
                                     * memory footprint. Do not use any SSE/AVX operations or 
                                     * vectorisation on the result for the packed variants, as the data is misaligned. 
                                     * If you rely on vectorisation, convert the underlying record 
                                     * into the unpacked version first. 
                                     * 
                                     * @see convert()
                                     */
                                    inline tarch::la::Vector<DIMENSIONS,double> getVelocity() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                       return _persistentRecords._velocity;
                                    }
                                    
                                    
                                    
                                    /**
                                     * Generated and optimized
                                     * 
                                     * If you realise a for loop using exclusively arrays (vectors) and compile 
                                     * with -DUseManualAlignment you may add 
                                     * \code
                                     #pragma vector aligned
                                     #pragma simd
                                     \endcode to this for loop to enforce your compiler to use SSE/AVX.
                                     * 
                                     * The alignment is tied to the unpacked records, i.e. for packed class
                                     * variants the machine's natural alignment is switched off to recude the  
                                     * memory footprint. Do not use any SSE/AVX operations or 
                                     * vectorisation on the result for the packed variants, as the data is misaligned. 
                                     * If you rely on vectorisation, convert the underlying record 
                                     * into the unpacked version first. 
                                     * 
                                     * @see convert()
                                     */
                                    inline void setVelocity(const tarch::la::Vector<DIMENSIONS,double>& velocity) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                       _persistentRecords._velocity = (velocity);
                                    }
                                    
                                    
                                    
                                    inline double getVelocity(int elementIndex) const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                       assertion(elementIndex>=0);
                                       assertion(elementIndex<DIMENSIONS);
                                       return _persistentRecords._velocity[elementIndex];
                                       
                                    }
                                    
                                    
                                    
                                    inline void setVelocity(int elementIndex, const double& velocity) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                       assertion(elementIndex>=0);
                                       assertion(elementIndex<DIMENSIONS);
                                       _persistentRecords._velocity[elementIndex]= velocity;
                                       
                                    }
                                    
                                    
                                    
                                    inline double getDiameter() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                       return _persistentRecords._diameter;
                                    }
                                    
                                    
                                    
                                    inline void setDiameter(const double& diameter) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                       _persistentRecords._diameter = diameter;
                                    }
                                    
                                    
                                    
                                    inline double getRadius() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                       return _persistentRecords._radius;
                                    }
                                    
                                    
                                    
                                    inline void setRadius(const double& radius) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                       _persistentRecords._radius = radius;
                                    }
                                    
                                    
                                    
                                    inline double getEpsilon() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                       return _persistentRecords._epsilon;
                                    }
                                    
                                    
                                    
                                    inline void setEpsilon(const double& epsilon) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                       _persistentRecords._epsilon = epsilon;
                                    }
                                    
                                    
                                    
                                    inline double getMass() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                       return _persistentRecords._mass;
                                    }
                                    
                                    
                                    
                                    inline void setMass(const double& mass) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                       _persistentRecords._mass = mass;
                                    }
                                    
                                    
                                    
                                    inline double getHMin() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                       return _persistentRecords._hMin;
                                    }
                                    
                                    
                                    
                                    inline void setHMin(const double& hMin) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                       _persistentRecords._hMin = hMin;
                                    }
                                    
                                    
                                    
                                    /**
                                     * Generated and optimized
                                     * 
                                     * If you realise a for loop using exclusively arrays (vectors) and compile 
                                     * with -DUseManualAlignment you may add 
                                     * \code
                                     #pragma vector aligned
                                     #pragma simd
                                     \endcode to this for loop to enforce your compiler to use SSE/AVX.
                                     * 
                                     * The alignment is tied to the unpacked records, i.e. for packed class
                                     * variants the machine's natural alignment is switched off to recude the  
                                     * memory footprint. Do not use any SSE/AVX operations or 
                                     * vectorisation on the result for the packed variants, as the data is misaligned. 
                                     * If you rely on vectorisation, convert the underlying record 
                                     * into the unpacked version first. 
                                     * 
                                     * @see convert()
                                     */
                                    inline tarch::la::Vector<DIMENSIONS,double> getCentreOfMass() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                       return _persistentRecords._centreOfMass;
                                    }
                                    
                                    
                                    
                                    /**
                                     * Generated and optimized
                                     * 
                                     * If you realise a for loop using exclusively arrays (vectors) and compile 
                                     * with -DUseManualAlignment you may add 
                                     * \code
                                     #pragma vector aligned
                                     #pragma simd
                                     \endcode to this for loop to enforce your compiler to use SSE/AVX.
                                     * 
                                     * The alignment is tied to the unpacked records, i.e. for packed class
                                     * variants the machine's natural alignment is switched off to recude the  
                                     * memory footprint. Do not use any SSE/AVX operations or 
                                     * vectorisation on the result for the packed variants, as the data is misaligned. 
                                     * If you rely on vectorisation, convert the underlying record 
                                     * into the unpacked version first. 
                                     * 
                                     * @see convert()
                                     */
                                    inline void setCentreOfMass(const tarch::la::Vector<DIMENSIONS,double>& centreOfMass) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                       _persistentRecords._centreOfMass = (centreOfMass);
                                    }
                                    
                                    
                                    
                                    inline double getCentreOfMass(int elementIndex) const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                       assertion(elementIndex>=0);
                                       assertion(elementIndex<DIMENSIONS);
                                       return _persistentRecords._centreOfMass[elementIndex];
                                       
                                    }
                                    
                                    
                                    
                                    inline void setCentreOfMass(int elementIndex, const double& centreOfMass) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                       assertion(elementIndex>=0);
                                       assertion(elementIndex<DIMENSIONS);
                                       _persistentRecords._centreOfMass[elementIndex]= centreOfMass;
                                       
                                    }
                                    
                                    
                                    
                                    inline int getGlobalParticleNumber() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                       return _persistentRecords._globalParticleNumber;
                                    }
                                    
                                    
                                    
                                    inline void setGlobalParticleNumber(const int& globalParticleNumber) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                       _persistentRecords._globalParticleNumber = globalParticleNumber;
                                    }
                                    
                                    
                                    
                                    /**
                                     * Generated and optimized
                                     * 
                                     * If you realise a for loop using exclusively arrays (vectors) and compile 
                                     * with -DUseManualAlignment you may add 
                                     * \code
                                     #pragma vector aligned
                                     #pragma simd
                                     \endcode to this for loop to enforce your compiler to use SSE/AVX.
                                     * 
                                     * The alignment is tied to the unpacked records, i.e. for packed class
                                     * variants the machine's natural alignment is switched off to recude the  
                                     * memory footprint. Do not use any SSE/AVX operations or 
                                     * vectorisation on the result for the packed variants, as the data is misaligned. 
                                     * If you rely on vectorisation, convert the underlying record 
                                     * into the unpacked version first. 
                                     * 
                                     * @see convert()
                                     */
                                    inline tarch::la::Vector<DIMENSIONS,double> getAngularVelocity() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                       return _persistentRecords._angularVelocity;
                                    }
                                    
                                    
                                    
                                    /**
                                     * Generated and optimized
                                     * 
                                     * If you realise a for loop using exclusively arrays (vectors) and compile 
                                     * with -DUseManualAlignment you may add 
                                     * \code
                                     #pragma vector aligned
                                     #pragma simd
                                     \endcode to this for loop to enforce your compiler to use SSE/AVX.
                                     * 
                                     * The alignment is tied to the unpacked records, i.e. for packed class
                                     * variants the machine's natural alignment is switched off to recude the  
                                     * memory footprint. Do not use any SSE/AVX operations or 
                                     * vectorisation on the result for the packed variants, as the data is misaligned. 
                                     * If you rely on vectorisation, convert the underlying record 
                                     * into the unpacked version first. 
                                     * 
                                     * @see convert()
                                     */
                                    inline void setAngularVelocity(const tarch::la::Vector<DIMENSIONS,double>& angularVelocity) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                       _persistentRecords._angularVelocity = (angularVelocity);
                                    }
                                    
                                    
                                    
                                    inline double getAngularVelocity(int elementIndex) const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                       assertion(elementIndex>=0);
                                       assertion(elementIndex<DIMENSIONS);
                                       return _persistentRecords._angularVelocity[elementIndex];
                                       
                                    }
                                    
                                    
                                    
                                    inline void setAngularVelocity(int elementIndex, const double& angularVelocity) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                       assertion(elementIndex>=0);
                                       assertion(elementIndex<DIMENSIONS);
                                       _persistentRecords._angularVelocity[elementIndex]= angularVelocity;
                                       
                                    }
                                    
                                    
                                    
                                    inline double getAngularVelocity() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                       return _persistentRecords._angularVelocity;
                                    }
                                    
                                    
                                    
                                    inline void setAngularVelocity(const double& angularVelocity) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                       _persistentRecords._angularVelocity = angularVelocity;
                                    }
                                    
                                    
                                    
                                    inline int getNumberOfTriangles() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                       return _persistentRecords._numberOfTriangles;
                                    }
                                    
                                    
                                    
                                    inline void setNumberOfTriangles(const int& numberOfTriangles) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                       _persistentRecords._numberOfTriangles = numberOfTriangles;
                                    }
                                    
                                    
                                    
                                    /**
                                     * Generated and optimized
                                     * 
                                     * If you realise a for loop using exclusively arrays (vectors) and compile 
                                     * with -DUseManualAlignment you may add 
                                     * \code
                                     #pragma vector aligned
                                     #pragma simd
                                     \endcode to this for loop to enforce your compiler to use SSE/AVX.
                                     * 
                                     * The alignment is tied to the unpacked records, i.e. for packed class
                                     * variants the machine's natural alignment is switched off to recude the  
                                     * memory footprint. Do not use any SSE/AVX operations or 
                                     * vectorisation on the result for the packed variants, as the data is misaligned. 
                                     * If you rely on vectorisation, convert the underlying record 
                                     * into the unpacked version first. 
                                     * 
                                     * @see convert()
                                     */
                                    inline tarch::la::Vector<DIMENSIONS,int> getVertices() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                       return _persistentRecords._vertices;
                                    }
                                    
                                    
                                    
                                    /**
                                     * Generated and optimized
                                     * 
                                     * If you realise a for loop using exclusively arrays (vectors) and compile 
                                     * with -DUseManualAlignment you may add 
                                     * \code
                                     #pragma vector aligned
                                     #pragma simd
                                     \endcode to this for loop to enforce your compiler to use SSE/AVX.
                                     * 
                                     * The alignment is tied to the unpacked records, i.e. for packed class
                                     * variants the machine's natural alignment is switched off to recude the  
                                     * memory footprint. Do not use any SSE/AVX operations or 
                                     * vectorisation on the result for the packed variants, as the data is misaligned. 
                                     * If you rely on vectorisation, convert the underlying record 
                                     * into the unpacked version first. 
                                     * 
                                     * @see convert()
                                     */
                                    inline void setVertices(const tarch::la::Vector<DIMENSIONS,int>& vertices) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                       _persistentRecords._vertices = (vertices);
                                    }
                                    
                                    
                                    
                                    inline int getVertices(int elementIndex) const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                       assertion(elementIndex>=0);
                                       assertion(elementIndex<DIMENSIONS);
                                       return _persistentRecords._vertices[elementIndex];
                                       
                                    }
                                    
                                    
                                    
                                    inline void setVertices(int elementIndex, const int& vertices) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                       assertion(elementIndex>=0);
                                       assertion(elementIndex<DIMENSIONS);
                                       _persistentRecords._vertices[elementIndex]= vertices;
                                       
                                    }
                                    
                                    
                                    /**
                                     * Generated
                                     */
                                    std::string toString() const;
                                    
                                    /**
                                     * Generated
                                     */
                                    void toString(std::ostream& out) const;
                                    
                                    
                                    PersistentRecords getPersistentRecords() const;
                                    /**
                                     * Generated
                                     */
                                    Particle convert() const;
                                    
                                    
                                 #ifdef Parallel
                                    protected:
                                       static tarch::logging::Log _log;
                                       
                                    public:
                                       
                                       /**
                                        * Global that represents the mpi datatype.
                                        * There are two variants: Datatype identifies only those attributes marked with
                                        * parallelise. FullDatatype instead identifies the whole record with all fields.
                                        */
                                       static MPI_Datatype Datatype;
                                       static MPI_Datatype FullDatatype;
                                       
                                       /**
                                        * Initializes the data type for the mpi operations. Has to be called
                                        * before the very first send or receive operation is called.
                                        */
                                       static void initDatatype();
                                       
                                       static void shutdownDatatype();
                                       
                                       /**
                                        * @param communicateSleep -1 Data exchange through blocking mpi
                                        * @param communicateSleep  0 Data exchange through non-blocking mpi, i.e. pending messages are received via polling until MPI_Test succeeds
                                        * @param communicateSleep >0 Same as 0 but in addition, each unsuccessful MPI_Test is follows by an usleep
                                        */
                                       void send(int destination, int tag, bool exchangeOnlyAttributesMarkedWithParallelise, int communicateSleep);
                                       
                                       void receive(int source, int tag, bool exchangeOnlyAttributesMarkedWithParallelise, int communicateSleep);
                                       
                                       static bool isMessageInQueue(int tag, bool exchangeOnlyAttributesMarkedWithParallelise);
                                       
                                       #endif
                                          
                                       };
                                       
                                       #ifdef PackedRecords
                                       #pragma pack (pop)
                                       #endif
                                       
                                       
                                       
                                    
                                 #elif defined(Dim2) && !defined(Dim3)
                                    /**
                                     * @author This class is generated by DaStGen
                                     * 		   DataStructureGenerator (DaStGen)
                                     * 		   2007-2009 Wolfgang Eckhardt
                                     * 		   2012      Tobias Weinzierl
                                     *
                                     * 		   build date: 09-02-2014 14:40
                                     *
                                     * @date   26/08/2016 13:52
                                     */
                                    class dem::records::Particle { 
                                       
                                       public:
                                          
                                          typedef dem::records::ParticlePacked Packed;
                                          
                                          struct PersistentRecords {
                                             #ifdef UseManualAlignment
                                             tarch::la::Vector<DIMENSIONS,double> _centre __attribute__((aligned(VectorisationAlignment)));
                                             #else
                                             tarch::la::Vector<DIMENSIONS,double> _centre;
                                             #endif
                                             #ifdef UseManualAlignment
                                             tarch::la::Vector<DIMENSIONS,double> _velocity __attribute__((aligned(VectorisationAlignment)));
                                             #else
                                             tarch::la::Vector<DIMENSIONS,double> _velocity;
                                             #endif
                                             double _diameter;
                                             double _radius;
                                             double _epsilon;
                                             double _mass;
                                             double _hMin;
                                             #ifdef UseManualAlignment
                                             tarch::la::Vector<DIMENSIONS,double> _centreOfMass __attribute__((aligned(VectorisationAlignment)));
                                             #else
                                             tarch::la::Vector<DIMENSIONS,double> _centreOfMass;
                                             #endif
                                             int _globalParticleNumber;
                                             double _angularVelocity;
                                             int _numberOfTriangles;
                                             #ifdef UseManualAlignment
                                             tarch::la::Vector<DIMENSIONS,int> _vertices __attribute__((aligned(VectorisationAlignment)));
                                             #else
                                             tarch::la::Vector<DIMENSIONS,int> _vertices;
                                             #endif
                                             /**
                                              * Generated
                                              */
                                             PersistentRecords();
                                             
                                             /**
                                              * Generated
                                              */
                                             PersistentRecords(const tarch::la::Vector<DIMENSIONS,double>& centre, const tarch::la::Vector<DIMENSIONS,double>& velocity, const double& diameter, const double& radius, const double& epsilon, const double& mass, const double& hMin, const tarch::la::Vector<DIMENSIONS,double>& centreOfMass, const int& globalParticleNumber, const double& angularVelocity, const int& numberOfTriangles, const tarch::la::Vector<DIMENSIONS,int>& vertices);
                                             
                                             
                                             /**
                                              * Generated and optimized
                                              * 
                                              * If you realise a for loop using exclusively arrays (vectors) and compile 
                                              * with -DUseManualAlignment you may add 
                                              * \code
                                              #pragma vector aligned
                                              #pragma simd
                                              \endcode to this for loop to enforce your compiler to use SSE/AVX.
                                              * 
                                              * The alignment is tied to the unpacked records, i.e. for packed class
                                              * variants the machine's natural alignment is switched off to recude the  
                                              * memory footprint. Do not use any SSE/AVX operations or 
                                              * vectorisation on the result for the packed variants, as the data is misaligned. 
                                              * If you rely on vectorisation, convert the underlying record 
                                              * into the unpacked version first. 
                                              * 
                                              * @see convert()
                                              */
                                             inline tarch::la::Vector<DIMENSIONS,double> getCentre() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                return _centre;
                                             }
                                             
                                             
                                             
                                             /**
                                              * Generated and optimized
                                              * 
                                              * If you realise a for loop using exclusively arrays (vectors) and compile 
                                              * with -DUseManualAlignment you may add 
                                              * \code
                                              #pragma vector aligned
                                              #pragma simd
                                              \endcode to this for loop to enforce your compiler to use SSE/AVX.
                                              * 
                                              * The alignment is tied to the unpacked records, i.e. for packed class
                                              * variants the machine's natural alignment is switched off to recude the  
                                              * memory footprint. Do not use any SSE/AVX operations or 
                                              * vectorisation on the result for the packed variants, as the data is misaligned. 
                                              * If you rely on vectorisation, convert the underlying record 
                                              * into the unpacked version first. 
                                              * 
                                              * @see convert()
                                              */
                                             inline void setCentre(const tarch::la::Vector<DIMENSIONS,double>& centre) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                _centre = (centre);
                                             }
                                             
                                             
                                             
                                             /**
                                              * Generated and optimized
                                              * 
                                              * If you realise a for loop using exclusively arrays (vectors) and compile 
                                              * with -DUseManualAlignment you may add 
                                              * \code
                                              #pragma vector aligned
                                              #pragma simd
                                              \endcode to this for loop to enforce your compiler to use SSE/AVX.
                                              * 
                                              * The alignment is tied to the unpacked records, i.e. for packed class
                                              * variants the machine's natural alignment is switched off to recude the  
                                              * memory footprint. Do not use any SSE/AVX operations or 
                                              * vectorisation on the result for the packed variants, as the data is misaligned. 
                                              * If you rely on vectorisation, convert the underlying record 
                                              * into the unpacked version first. 
                                              * 
                                              * @see convert()
                                              */
                                             inline tarch::la::Vector<DIMENSIONS,double> getVelocity() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                return _velocity;
                                             }
                                             
                                             
                                             
                                             /**
                                              * Generated and optimized
                                              * 
                                              * If you realise a for loop using exclusively arrays (vectors) and compile 
                                              * with -DUseManualAlignment you may add 
                                              * \code
                                              #pragma vector aligned
                                              #pragma simd
                                              \endcode to this for loop to enforce your compiler to use SSE/AVX.
                                              * 
                                              * The alignment is tied to the unpacked records, i.e. for packed class
                                              * variants the machine's natural alignment is switched off to recude the  
                                              * memory footprint. Do not use any SSE/AVX operations or 
                                              * vectorisation on the result for the packed variants, as the data is misaligned. 
                                              * If you rely on vectorisation, convert the underlying record 
                                              * into the unpacked version first. 
                                              * 
                                              * @see convert()
                                              */
                                             inline void setVelocity(const tarch::la::Vector<DIMENSIONS,double>& velocity) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                _velocity = (velocity);
                                             }
                                             
                                             
                                             
                                             inline double getDiameter() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                return _diameter;
                                             }
                                             
                                             
                                             
                                             inline void setDiameter(const double& diameter) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                _diameter = diameter;
                                             }
                                             
                                             
                                             
                                             inline double getRadius() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                return _radius;
                                             }
                                             
                                             
                                             
                                             inline void setRadius(const double& radius) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                _radius = radius;
                                             }
                                             
                                             
                                             
                                             inline double getEpsilon() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                return _epsilon;
                                             }
                                             
                                             
                                             
                                             inline void setEpsilon(const double& epsilon) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                _epsilon = epsilon;
                                             }
                                             
                                             
                                             
                                             inline double getMass() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                return _mass;
                                             }
                                             
                                             
                                             
                                             inline void setMass(const double& mass) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                _mass = mass;
                                             }
                                             
                                             
                                             
                                             inline double getHMin() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                return _hMin;
                                             }
                                             
                                             
                                             
                                             inline void setHMin(const double& hMin) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                _hMin = hMin;
                                             }
                                             
                                             
                                             
                                             /**
                                              * Generated and optimized
                                              * 
                                              * If you realise a for loop using exclusively arrays (vectors) and compile 
                                              * with -DUseManualAlignment you may add 
                                              * \code
                                              #pragma vector aligned
                                              #pragma simd
                                              \endcode to this for loop to enforce your compiler to use SSE/AVX.
                                              * 
                                              * The alignment is tied to the unpacked records, i.e. for packed class
                                              * variants the machine's natural alignment is switched off to recude the  
                                              * memory footprint. Do not use any SSE/AVX operations or 
                                              * vectorisation on the result for the packed variants, as the data is misaligned. 
                                              * If you rely on vectorisation, convert the underlying record 
                                              * into the unpacked version first. 
                                              * 
                                              * @see convert()
                                              */
                                             inline tarch::la::Vector<DIMENSIONS,double> getCentreOfMass() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                return _centreOfMass;
                                             }
                                             
                                             
                                             
                                             /**
                                              * Generated and optimized
                                              * 
                                              * If you realise a for loop using exclusively arrays (vectors) and compile 
                                              * with -DUseManualAlignment you may add 
                                              * \code
                                              #pragma vector aligned
                                              #pragma simd
                                              \endcode to this for loop to enforce your compiler to use SSE/AVX.
                                              * 
                                              * The alignment is tied to the unpacked records, i.e. for packed class
                                              * variants the machine's natural alignment is switched off to recude the  
                                              * memory footprint. Do not use any SSE/AVX operations or 
                                              * vectorisation on the result for the packed variants, as the data is misaligned. 
                                              * If you rely on vectorisation, convert the underlying record 
                                              * into the unpacked version first. 
                                              * 
                                              * @see convert()
                                              */
                                             inline void setCentreOfMass(const tarch::la::Vector<DIMENSIONS,double>& centreOfMass) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                _centreOfMass = (centreOfMass);
                                             }
                                             
                                             
                                             
                                             inline int getGlobalParticleNumber() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                return _globalParticleNumber;
                                             }
                                             
                                             
                                             
                                             inline void setGlobalParticleNumber(const int& globalParticleNumber) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                _globalParticleNumber = globalParticleNumber;
                                             }
                                             
                                             
                                             
                                             inline double getAngularVelocity() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                return _angularVelocity;
                                             }
                                             
                                             
                                             
                                             inline void setAngularVelocity(const double& angularVelocity) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                _angularVelocity = angularVelocity;
                                             }
                                             
                                             
                                             
                                             inline int getNumberOfTriangles() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                return _numberOfTriangles;
                                             }
                                             
                                             
                                             
                                             inline void setNumberOfTriangles(const int& numberOfTriangles) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                _numberOfTriangles = numberOfTriangles;
                                             }
                                             
                                             
                                             
                                             /**
                                              * Generated and optimized
                                              * 
                                              * If you realise a for loop using exclusively arrays (vectors) and compile 
                                              * with -DUseManualAlignment you may add 
                                              * \code
                                              #pragma vector aligned
                                              #pragma simd
                                              \endcode to this for loop to enforce your compiler to use SSE/AVX.
                                              * 
                                              * The alignment is tied to the unpacked records, i.e. for packed class
                                              * variants the machine's natural alignment is switched off to recude the  
                                              * memory footprint. Do not use any SSE/AVX operations or 
                                              * vectorisation on the result for the packed variants, as the data is misaligned. 
                                              * If you rely on vectorisation, convert the underlying record 
                                              * into the unpacked version first. 
                                              * 
                                              * @see convert()
                                              */
                                             inline tarch::la::Vector<DIMENSIONS,int> getVertices() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                return _vertices;
                                             }
                                             
                                             
                                             
                                             /**
                                              * Generated and optimized
                                              * 
                                              * If you realise a for loop using exclusively arrays (vectors) and compile 
                                              * with -DUseManualAlignment you may add 
                                              * \code
                                              #pragma vector aligned
                                              #pragma simd
                                              \endcode to this for loop to enforce your compiler to use SSE/AVX.
                                              * 
                                              * The alignment is tied to the unpacked records, i.e. for packed class
                                              * variants the machine's natural alignment is switched off to recude the  
                                              * memory footprint. Do not use any SSE/AVX operations or 
                                              * vectorisation on the result for the packed variants, as the data is misaligned. 
                                              * If you rely on vectorisation, convert the underlying record 
                                              * into the unpacked version first. 
                                              * 
                                              * @see convert()
                                              */
                                             inline void setVertices(const tarch::la::Vector<DIMENSIONS,int>& vertices) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                _vertices = (vertices);
                                             }
                                             
                                             
                                             
                                          };
                                          
                                       private: 
                                          public:

                                          PersistentRecords _persistentRecords;
                                          private:

                                          
                                       public:
                                          /**
                                           * Generated
                                           */
                                          Particle();
                                          
                                          /**
                                           * Generated
                                           */
                                          Particle(const PersistentRecords& persistentRecords);
                                          
                                          /**
                                           * Generated
                                           */
                                          Particle(const tarch::la::Vector<DIMENSIONS,double>& centre, const tarch::la::Vector<DIMENSIONS,double>& velocity, const double& diameter, const double& radius, const double& epsilon, const double& mass, const double& hMin, const tarch::la::Vector<DIMENSIONS,double>& centreOfMass, const int& globalParticleNumber, const double& angularVelocity, const int& numberOfTriangles, const tarch::la::Vector<DIMENSIONS,int>& vertices);
                                          
                                          /**
                                           * Generated
                                           */
                                          ~Particle();
                                          
                                          
                                          /**
                                           * Generated and optimized
                                           * 
                                           * If you realise a for loop using exclusively arrays (vectors) and compile 
                                           * with -DUseManualAlignment you may add 
                                           * \code
                                           #pragma vector aligned
                                           #pragma simd
                                           \endcode to this for loop to enforce your compiler to use SSE/AVX.
                                           * 
                                           * The alignment is tied to the unpacked records, i.e. for packed class
                                           * variants the machine's natural alignment is switched off to recude the  
                                           * memory footprint. Do not use any SSE/AVX operations or 
                                           * vectorisation on the result for the packed variants, as the data is misaligned. 
                                           * If you rely on vectorisation, convert the underlying record 
                                           * into the unpacked version first. 
                                           * 
                                           * @see convert()
                                           */
                                          inline tarch::la::Vector<DIMENSIONS,double> getCentre() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                             return _persistentRecords._centre;
                                          }
                                          
                                          
                                          
                                          /**
                                           * Generated and optimized
                                           * 
                                           * If you realise a for loop using exclusively arrays (vectors) and compile 
                                           * with -DUseManualAlignment you may add 
                                           * \code
                                           #pragma vector aligned
                                           #pragma simd
                                           \endcode to this for loop to enforce your compiler to use SSE/AVX.
                                           * 
                                           * The alignment is tied to the unpacked records, i.e. for packed class
                                           * variants the machine's natural alignment is switched off to recude the  
                                           * memory footprint. Do not use any SSE/AVX operations or 
                                           * vectorisation on the result for the packed variants, as the data is misaligned. 
                                           * If you rely on vectorisation, convert the underlying record 
                                           * into the unpacked version first. 
                                           * 
                                           * @see convert()
                                           */
                                          inline void setCentre(const tarch::la::Vector<DIMENSIONS,double>& centre) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                             _persistentRecords._centre = (centre);
                                          }
                                          
                                          
                                          
                                          inline double getCentre(int elementIndex) const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                             assertion(elementIndex>=0);
                                             assertion(elementIndex<DIMENSIONS);
                                             return _persistentRecords._centre[elementIndex];
                                             
                                          }
                                          
                                          
                                          
                                          inline void setCentre(int elementIndex, const double& centre) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                             assertion(elementIndex>=0);
                                             assertion(elementIndex<DIMENSIONS);
                                             _persistentRecords._centre[elementIndex]= centre;
                                             
                                          }
                                          
                                          
                                          
                                          /**
                                           * Generated and optimized
                                           * 
                                           * If you realise a for loop using exclusively arrays (vectors) and compile 
                                           * with -DUseManualAlignment you may add 
                                           * \code
                                           #pragma vector aligned
                                           #pragma simd
                                           \endcode to this for loop to enforce your compiler to use SSE/AVX.
                                           * 
                                           * The alignment is tied to the unpacked records, i.e. for packed class
                                           * variants the machine's natural alignment is switched off to recude the  
                                           * memory footprint. Do not use any SSE/AVX operations or 
                                           * vectorisation on the result for the packed variants, as the data is misaligned. 
                                           * If you rely on vectorisation, convert the underlying record 
                                           * into the unpacked version first. 
                                           * 
                                           * @see convert()
                                           */
                                          inline tarch::la::Vector<DIMENSIONS,double> getVelocity() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                             return _persistentRecords._velocity;
                                          }
                                          
                                          
                                          
                                          /**
                                           * Generated and optimized
                                           * 
                                           * If you realise a for loop using exclusively arrays (vectors) and compile 
                                           * with -DUseManualAlignment you may add 
                                           * \code
                                           #pragma vector aligned
                                           #pragma simd
                                           \endcode to this for loop to enforce your compiler to use SSE/AVX.
                                           * 
                                           * The alignment is tied to the unpacked records, i.e. for packed class
                                           * variants the machine's natural alignment is switched off to recude the  
                                           * memory footprint. Do not use any SSE/AVX operations or 
                                           * vectorisation on the result for the packed variants, as the data is misaligned. 
                                           * If you rely on vectorisation, convert the underlying record 
                                           * into the unpacked version first. 
                                           * 
                                           * @see convert()
                                           */
                                          inline void setVelocity(const tarch::la::Vector<DIMENSIONS,double>& velocity) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                             _persistentRecords._velocity = (velocity);
                                          }
                                          
                                          
                                          
                                          inline double getVelocity(int elementIndex) const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                             assertion(elementIndex>=0);
                                             assertion(elementIndex<DIMENSIONS);
                                             return _persistentRecords._velocity[elementIndex];
                                             
                                          }
                                          
                                          
                                          
                                          inline void setVelocity(int elementIndex, const double& velocity) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                             assertion(elementIndex>=0);
                                             assertion(elementIndex<DIMENSIONS);
                                             _persistentRecords._velocity[elementIndex]= velocity;
                                             
                                          }
                                          
                                          
                                          
                                          inline double getDiameter() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                             return _persistentRecords._diameter;
                                          }
                                          
                                          
                                          
                                          inline void setDiameter(const double& diameter) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                             _persistentRecords._diameter = diameter;
                                          }
                                          
                                          
                                          
                                          inline double getRadius() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                             return _persistentRecords._radius;
                                          }
                                          
                                          
                                          
                                          inline void setRadius(const double& radius) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                             _persistentRecords._radius = radius;
                                          }
                                          
                                          
                                          
                                          inline double getEpsilon() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                             return _persistentRecords._epsilon;
                                          }
                                          
                                          
                                          
                                          inline void setEpsilon(const double& epsilon) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                             _persistentRecords._epsilon = epsilon;
                                          }
                                          
                                          
                                          
                                          inline double getMass() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                             return _persistentRecords._mass;
                                          }
                                          
                                          
                                          
                                          inline void setMass(const double& mass) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                             _persistentRecords._mass = mass;
                                          }
                                          
                                          
                                          
                                          inline double getHMin() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                             return _persistentRecords._hMin;
                                          }
                                          
                                          
                                          
                                          inline void setHMin(const double& hMin) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                             _persistentRecords._hMin = hMin;
                                          }
                                          
                                          
                                          
                                          /**
                                           * Generated and optimized
                                           * 
                                           * If you realise a for loop using exclusively arrays (vectors) and compile 
                                           * with -DUseManualAlignment you may add 
                                           * \code
                                           #pragma vector aligned
                                           #pragma simd
                                           \endcode to this for loop to enforce your compiler to use SSE/AVX.
                                           * 
                                           * The alignment is tied to the unpacked records, i.e. for packed class
                                           * variants the machine's natural alignment is switched off to recude the  
                                           * memory footprint. Do not use any SSE/AVX operations or 
                                           * vectorisation on the result for the packed variants, as the data is misaligned. 
                                           * If you rely on vectorisation, convert the underlying record 
                                           * into the unpacked version first. 
                                           * 
                                           * @see convert()
                                           */
                                          inline tarch::la::Vector<DIMENSIONS,double> getCentreOfMass() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                             return _persistentRecords._centreOfMass;
                                          }
                                          
                                          
                                          
                                          /**
                                           * Generated and optimized
                                           * 
                                           * If you realise a for loop using exclusively arrays (vectors) and compile 
                                           * with -DUseManualAlignment you may add 
                                           * \code
                                           #pragma vector aligned
                                           #pragma simd
                                           \endcode to this for loop to enforce your compiler to use SSE/AVX.
                                           * 
                                           * The alignment is tied to the unpacked records, i.e. for packed class
                                           * variants the machine's natural alignment is switched off to recude the  
                                           * memory footprint. Do not use any SSE/AVX operations or 
                                           * vectorisation on the result for the packed variants, as the data is misaligned. 
                                           * If you rely on vectorisation, convert the underlying record 
                                           * into the unpacked version first. 
                                           * 
                                           * @see convert()
                                           */
                                          inline void setCentreOfMass(const tarch::la::Vector<DIMENSIONS,double>& centreOfMass) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                             _persistentRecords._centreOfMass = (centreOfMass);
                                          }
                                          
                                          
                                          
                                          inline double getCentreOfMass(int elementIndex) const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                             assertion(elementIndex>=0);
                                             assertion(elementIndex<DIMENSIONS);
                                             return _persistentRecords._centreOfMass[elementIndex];
                                             
                                          }
                                          
                                          
                                          
                                          inline void setCentreOfMass(int elementIndex, const double& centreOfMass) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                             assertion(elementIndex>=0);
                                             assertion(elementIndex<DIMENSIONS);
                                             _persistentRecords._centreOfMass[elementIndex]= centreOfMass;
                                             
                                          }
                                          
                                          
                                          
                                          inline int getGlobalParticleNumber() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                             return _persistentRecords._globalParticleNumber;
                                          }
                                          
                                          
                                          
                                          inline void setGlobalParticleNumber(const int& globalParticleNumber) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                             _persistentRecords._globalParticleNumber = globalParticleNumber;
                                          }
                                          
                                          
                                          
                                          inline double getAngularVelocity() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                             return _persistentRecords._angularVelocity;
                                          }
                                          
                                          
                                          
                                          inline void setAngularVelocity(const double& angularVelocity) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                             _persistentRecords._angularVelocity = angularVelocity;
                                          }
                                          
                                          
                                          
                                          inline int getNumberOfTriangles() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                             return _persistentRecords._numberOfTriangles;
                                          }
                                          
                                          
                                          
                                          inline void setNumberOfTriangles(const int& numberOfTriangles) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                             _persistentRecords._numberOfTriangles = numberOfTriangles;
                                          }
                                          
                                          
                                          
                                          /**
                                           * Generated and optimized
                                           * 
                                           * If you realise a for loop using exclusively arrays (vectors) and compile 
                                           * with -DUseManualAlignment you may add 
                                           * \code
                                           #pragma vector aligned
                                           #pragma simd
                                           \endcode to this for loop to enforce your compiler to use SSE/AVX.
                                           * 
                                           * The alignment is tied to the unpacked records, i.e. for packed class
                                           * variants the machine's natural alignment is switched off to recude the  
                                           * memory footprint. Do not use any SSE/AVX operations or 
                                           * vectorisation on the result for the packed variants, as the data is misaligned. 
                                           * If you rely on vectorisation, convert the underlying record 
                                           * into the unpacked version first. 
                                           * 
                                           * @see convert()
                                           */
                                          inline tarch::la::Vector<DIMENSIONS,int> getVertices() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                             return _persistentRecords._vertices;
                                          }
                                          
                                          
                                          
                                          /**
                                           * Generated and optimized
                                           * 
                                           * If you realise a for loop using exclusively arrays (vectors) and compile 
                                           * with -DUseManualAlignment you may add 
                                           * \code
                                           #pragma vector aligned
                                           #pragma simd
                                           \endcode to this for loop to enforce your compiler to use SSE/AVX.
                                           * 
                                           * The alignment is tied to the unpacked records, i.e. for packed class
                                           * variants the machine's natural alignment is switched off to recude the  
                                           * memory footprint. Do not use any SSE/AVX operations or 
                                           * vectorisation on the result for the packed variants, as the data is misaligned. 
                                           * If you rely on vectorisation, convert the underlying record 
                                           * into the unpacked version first. 
                                           * 
                                           * @see convert()
                                           */
                                          inline void setVertices(const tarch::la::Vector<DIMENSIONS,int>& vertices) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                             _persistentRecords._vertices = (vertices);
                                          }
                                          
                                          
                                          
                                          inline int getVertices(int elementIndex) const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                             assertion(elementIndex>=0);
                                             assertion(elementIndex<DIMENSIONS);
                                             return _persistentRecords._vertices[elementIndex];
                                             
                                          }
                                          
                                          
                                          
                                          inline void setVertices(int elementIndex, const int& vertices) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                             assertion(elementIndex>=0);
                                             assertion(elementIndex<DIMENSIONS);
                                             _persistentRecords._vertices[elementIndex]= vertices;
                                             
                                          }
                                          
                                          
                                          /**
                                           * Generated
                                           */
                                          std::string toString() const;
                                          
                                          /**
                                           * Generated
                                           */
                                          void toString(std::ostream& out) const;
                                          
                                          
                                          PersistentRecords getPersistentRecords() const;
                                          /**
                                           * Generated
                                           */
                                          ParticlePacked convert() const;
                                          
                                          
                                       #ifdef Parallel
                                          protected:
                                             static tarch::logging::Log _log;
                                             
                                          public:
                                             
                                             /**
                                              * Global that represents the mpi datatype.
                                              * There are two variants: Datatype identifies only those attributes marked with
                                              * parallelise. FullDatatype instead identifies the whole record with all fields.
                                              */
                                             static MPI_Datatype Datatype;
                                             static MPI_Datatype FullDatatype;
                                             
                                             /**
                                              * Initializes the data type for the mpi operations. Has to be called
                                              * before the very first send or receive operation is called.
                                              */
                                             static void initDatatype();
                                             
                                             static void shutdownDatatype();
                                             
                                             /**
                                              * @param communicateSleep -1 Data exchange through blocking mpi
                                              * @param communicateSleep  0 Data exchange through non-blocking mpi, i.e. pending messages are received via polling until MPI_Test succeeds
                                              * @param communicateSleep >0 Same as 0 but in addition, each unsuccessful MPI_Test is follows by an usleep
                                              */
                                             void send(int destination, int tag, bool exchangeOnlyAttributesMarkedWithParallelise, int communicateSleep);
                                             
                                             void receive(int source, int tag, bool exchangeOnlyAttributesMarkedWithParallelise, int communicateSleep);
                                             
                                             static bool isMessageInQueue(int tag, bool exchangeOnlyAttributesMarkedWithParallelise);
                                             
                                             #endif
                                                
                                             };
                                             
                                             #ifndef DaStGenPackedPadding
                                               #define DaStGenPackedPadding 1      // 32 bit version
                                               // #define DaStGenPackedPadding 2   // 64 bit version
                                             #endif
                                             
                                             
                                             #ifdef PackedRecords
                                                #pragma pack (push, DaStGenPackedPadding)
                                             #endif
                                             
                                             /**
                                              * @author This class is generated by DaStGen
                                              * 		   DataStructureGenerator (DaStGen)
                                              * 		   2007-2009 Wolfgang Eckhardt
                                              * 		   2012      Tobias Weinzierl
                                              *
                                              * 		   build date: 09-02-2014 14:40
                                              *
                                              * @date   26/08/2016 13:52
                                              */
                                             class dem::records::ParticlePacked { 
                                                
                                                public:
                                                   
                                                   struct PersistentRecords {
                                                      tarch::la::Vector<DIMENSIONS,double> _centre;
                                                      tarch::la::Vector<DIMENSIONS,double> _velocity;
                                                      double _diameter;
                                                      double _radius;
                                                      double _epsilon;
                                                      double _mass;
                                                      double _hMin;
                                                      tarch::la::Vector<DIMENSIONS,double> _centreOfMass;
                                                      int _globalParticleNumber;
                                                      double _angularVelocity;
                                                      int _numberOfTriangles;
                                                      tarch::la::Vector<DIMENSIONS,int> _vertices;
                                                      /**
                                                       * Generated
                                                       */
                                                      PersistentRecords();
                                                      
                                                      /**
                                                       * Generated
                                                       */
                                                      PersistentRecords(const tarch::la::Vector<DIMENSIONS,double>& centre, const tarch::la::Vector<DIMENSIONS,double>& velocity, const double& diameter, const double& radius, const double& epsilon, const double& mass, const double& hMin, const tarch::la::Vector<DIMENSIONS,double>& centreOfMass, const int& globalParticleNumber, const double& angularVelocity, const int& numberOfTriangles, const tarch::la::Vector<DIMENSIONS,int>& vertices);
                                                      
                                                      
                                                      /**
                                                       * Generated and optimized
                                                       * 
                                                       * If you realise a for loop using exclusively arrays (vectors) and compile 
                                                       * with -DUseManualAlignment you may add 
                                                       * \code
                                                       #pragma vector aligned
                                                       #pragma simd
                                                       \endcode to this for loop to enforce your compiler to use SSE/AVX.
                                                       * 
                                                       * The alignment is tied to the unpacked records, i.e. for packed class
                                                       * variants the machine's natural alignment is switched off to recude the  
                                                       * memory footprint. Do not use any SSE/AVX operations or 
                                                       * vectorisation on the result for the packed variants, as the data is misaligned. 
                                                       * If you rely on vectorisation, convert the underlying record 
                                                       * into the unpacked version first. 
                                                       * 
                                                       * @see convert()
                                                       */
                                                      inline tarch::la::Vector<DIMENSIONS,double> getCentre() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                         return _centre;
                                                      }
                                                      
                                                      
                                                      
                                                      /**
                                                       * Generated and optimized
                                                       * 
                                                       * If you realise a for loop using exclusively arrays (vectors) and compile 
                                                       * with -DUseManualAlignment you may add 
                                                       * \code
                                                       #pragma vector aligned
                                                       #pragma simd
                                                       \endcode to this for loop to enforce your compiler to use SSE/AVX.
                                                       * 
                                                       * The alignment is tied to the unpacked records, i.e. for packed class
                                                       * variants the machine's natural alignment is switched off to recude the  
                                                       * memory footprint. Do not use any SSE/AVX operations or 
                                                       * vectorisation on the result for the packed variants, as the data is misaligned. 
                                                       * If you rely on vectorisation, convert the underlying record 
                                                       * into the unpacked version first. 
                                                       * 
                                                       * @see convert()
                                                       */
                                                      inline void setCentre(const tarch::la::Vector<DIMENSIONS,double>& centre) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                         _centre = (centre);
                                                      }
                                                      
                                                      
                                                      
                                                      /**
                                                       * Generated and optimized
                                                       * 
                                                       * If you realise a for loop using exclusively arrays (vectors) and compile 
                                                       * with -DUseManualAlignment you may add 
                                                       * \code
                                                       #pragma vector aligned
                                                       #pragma simd
                                                       \endcode to this for loop to enforce your compiler to use SSE/AVX.
                                                       * 
                                                       * The alignment is tied to the unpacked records, i.e. for packed class
                                                       * variants the machine's natural alignment is switched off to recude the  
                                                       * memory footprint. Do not use any SSE/AVX operations or 
                                                       * vectorisation on the result for the packed variants, as the data is misaligned. 
                                                       * If you rely on vectorisation, convert the underlying record 
                                                       * into the unpacked version first. 
                                                       * 
                                                       * @see convert()
                                                       */
                                                      inline tarch::la::Vector<DIMENSIONS,double> getVelocity() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                         return _velocity;
                                                      }
                                                      
                                                      
                                                      
                                                      /**
                                                       * Generated and optimized
                                                       * 
                                                       * If you realise a for loop using exclusively arrays (vectors) and compile 
                                                       * with -DUseManualAlignment you may add 
                                                       * \code
                                                       #pragma vector aligned
                                                       #pragma simd
                                                       \endcode to this for loop to enforce your compiler to use SSE/AVX.
                                                       * 
                                                       * The alignment is tied to the unpacked records, i.e. for packed class
                                                       * variants the machine's natural alignment is switched off to recude the  
                                                       * memory footprint. Do not use any SSE/AVX operations or 
                                                       * vectorisation on the result for the packed variants, as the data is misaligned. 
                                                       * If you rely on vectorisation, convert the underlying record 
                                                       * into the unpacked version first. 
                                                       * 
                                                       * @see convert()
                                                       */
                                                      inline void setVelocity(const tarch::la::Vector<DIMENSIONS,double>& velocity) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                         _velocity = (velocity);
                                                      }
                                                      
                                                      
                                                      
                                                      inline double getDiameter() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                         return _diameter;
                                                      }
                                                      
                                                      
                                                      
                                                      inline void setDiameter(const double& diameter) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                         _diameter = diameter;
                                                      }
                                                      
                                                      
                                                      
                                                      inline double getRadius() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                         return _radius;
                                                      }
                                                      
                                                      
                                                      
                                                      inline void setRadius(const double& radius) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                         _radius = radius;
                                                      }
                                                      
                                                      
                                                      
                                                      inline double getEpsilon() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                         return _epsilon;
                                                      }
                                                      
                                                      
                                                      
                                                      inline void setEpsilon(const double& epsilon) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                         _epsilon = epsilon;
                                                      }
                                                      
                                                      
                                                      
                                                      inline double getMass() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                         return _mass;
                                                      }
                                                      
                                                      
                                                      
                                                      inline void setMass(const double& mass) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                         _mass = mass;
                                                      }
                                                      
                                                      
                                                      
                                                      inline double getHMin() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                         return _hMin;
                                                      }
                                                      
                                                      
                                                      
                                                      inline void setHMin(const double& hMin) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                         _hMin = hMin;
                                                      }
                                                      
                                                      
                                                      
                                                      /**
                                                       * Generated and optimized
                                                       * 
                                                       * If you realise a for loop using exclusively arrays (vectors) and compile 
                                                       * with -DUseManualAlignment you may add 
                                                       * \code
                                                       #pragma vector aligned
                                                       #pragma simd
                                                       \endcode to this for loop to enforce your compiler to use SSE/AVX.
                                                       * 
                                                       * The alignment is tied to the unpacked records, i.e. for packed class
                                                       * variants the machine's natural alignment is switched off to recude the  
                                                       * memory footprint. Do not use any SSE/AVX operations or 
                                                       * vectorisation on the result for the packed variants, as the data is misaligned. 
                                                       * If you rely on vectorisation, convert the underlying record 
                                                       * into the unpacked version first. 
                                                       * 
                                                       * @see convert()
                                                       */
                                                      inline tarch::la::Vector<DIMENSIONS,double> getCentreOfMass() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                         return _centreOfMass;
                                                      }
                                                      
                                                      
                                                      
                                                      /**
                                                       * Generated and optimized
                                                       * 
                                                       * If you realise a for loop using exclusively arrays (vectors) and compile 
                                                       * with -DUseManualAlignment you may add 
                                                       * \code
                                                       #pragma vector aligned
                                                       #pragma simd
                                                       \endcode to this for loop to enforce your compiler to use SSE/AVX.
                                                       * 
                                                       * The alignment is tied to the unpacked records, i.e. for packed class
                                                       * variants the machine's natural alignment is switched off to recude the  
                                                       * memory footprint. Do not use any SSE/AVX operations or 
                                                       * vectorisation on the result for the packed variants, as the data is misaligned. 
                                                       * If you rely on vectorisation, convert the underlying record 
                                                       * into the unpacked version first. 
                                                       * 
                                                       * @see convert()
                                                       */
                                                      inline void setCentreOfMass(const tarch::la::Vector<DIMENSIONS,double>& centreOfMass) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                         _centreOfMass = (centreOfMass);
                                                      }
                                                      
                                                      
                                                      
                                                      inline int getGlobalParticleNumber() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                         return _globalParticleNumber;
                                                      }
                                                      
                                                      
                                                      
                                                      inline void setGlobalParticleNumber(const int& globalParticleNumber) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                         _globalParticleNumber = globalParticleNumber;
                                                      }
                                                      
                                                      
                                                      
                                                      inline double getAngularVelocity() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                         return _angularVelocity;
                                                      }
                                                      
                                                      
                                                      
                                                      inline void setAngularVelocity(const double& angularVelocity) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                         _angularVelocity = angularVelocity;
                                                      }
                                                      
                                                      
                                                      
                                                      inline int getNumberOfTriangles() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                         return _numberOfTriangles;
                                                      }
                                                      
                                                      
                                                      
                                                      inline void setNumberOfTriangles(const int& numberOfTriangles) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                         _numberOfTriangles = numberOfTriangles;
                                                      }
                                                      
                                                      
                                                      
                                                      /**
                                                       * Generated and optimized
                                                       * 
                                                       * If you realise a for loop using exclusively arrays (vectors) and compile 
                                                       * with -DUseManualAlignment you may add 
                                                       * \code
                                                       #pragma vector aligned
                                                       #pragma simd
                                                       \endcode to this for loop to enforce your compiler to use SSE/AVX.
                                                       * 
                                                       * The alignment is tied to the unpacked records, i.e. for packed class
                                                       * variants the machine's natural alignment is switched off to recude the  
                                                       * memory footprint. Do not use any SSE/AVX operations or 
                                                       * vectorisation on the result for the packed variants, as the data is misaligned. 
                                                       * If you rely on vectorisation, convert the underlying record 
                                                       * into the unpacked version first. 
                                                       * 
                                                       * @see convert()
                                                       */
                                                      inline tarch::la::Vector<DIMENSIONS,int> getVertices() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                         return _vertices;
                                                      }
                                                      
                                                      
                                                      
                                                      /**
                                                       * Generated and optimized
                                                       * 
                                                       * If you realise a for loop using exclusively arrays (vectors) and compile 
                                                       * with -DUseManualAlignment you may add 
                                                       * \code
                                                       #pragma vector aligned
                                                       #pragma simd
                                                       \endcode to this for loop to enforce your compiler to use SSE/AVX.
                                                       * 
                                                       * The alignment is tied to the unpacked records, i.e. for packed class
                                                       * variants the machine's natural alignment is switched off to recude the  
                                                       * memory footprint. Do not use any SSE/AVX operations or 
                                                       * vectorisation on the result for the packed variants, as the data is misaligned. 
                                                       * If you rely on vectorisation, convert the underlying record 
                                                       * into the unpacked version first. 
                                                       * 
                                                       * @see convert()
                                                       */
                                                      inline void setVertices(const tarch::la::Vector<DIMENSIONS,int>& vertices) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                         _vertices = (vertices);
                                                      }
                                                      
                                                      
                                                      
                                                   };
                                                   
                                                private: 
                                                   PersistentRecords _persistentRecords;
                                                   
                                                public:
                                                   /**
                                                    * Generated
                                                    */
                                                   ParticlePacked();
                                                   
                                                   /**
                                                    * Generated
                                                    */
                                                   ParticlePacked(const PersistentRecords& persistentRecords);
                                                   
                                                   /**
                                                    * Generated
                                                    */
                                                   ParticlePacked(const tarch::la::Vector<DIMENSIONS,double>& centre, const tarch::la::Vector<DIMENSIONS,double>& velocity, const double& diameter, const double& radius, const double& epsilon, const double& mass, const double& hMin, const tarch::la::Vector<DIMENSIONS,double>& centreOfMass, const int& globalParticleNumber, const double& angularVelocity, const int& numberOfTriangles, const tarch::la::Vector<DIMENSIONS,int>& vertices);
                                                   
                                                   /**
                                                    * Generated
                                                    */
                                                   ~ParticlePacked();
                                                   
                                                   
                                                   /**
                                                    * Generated and optimized
                                                    * 
                                                    * If you realise a for loop using exclusively arrays (vectors) and compile 
                                                    * with -DUseManualAlignment you may add 
                                                    * \code
                                                    #pragma vector aligned
                                                    #pragma simd
                                                    \endcode to this for loop to enforce your compiler to use SSE/AVX.
                                                    * 
                                                    * The alignment is tied to the unpacked records, i.e. for packed class
                                                    * variants the machine's natural alignment is switched off to recude the  
                                                    * memory footprint. Do not use any SSE/AVX operations or 
                                                    * vectorisation on the result for the packed variants, as the data is misaligned. 
                                                    * If you rely on vectorisation, convert the underlying record 
                                                    * into the unpacked version first. 
                                                    * 
                                                    * @see convert()
                                                    */
                                                   inline tarch::la::Vector<DIMENSIONS,double> getCentre() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                      return _persistentRecords._centre;
                                                   }
                                                   
                                                   
                                                   
                                                   /**
                                                    * Generated and optimized
                                                    * 
                                                    * If you realise a for loop using exclusively arrays (vectors) and compile 
                                                    * with -DUseManualAlignment you may add 
                                                    * \code
                                                    #pragma vector aligned
                                                    #pragma simd
                                                    \endcode to this for loop to enforce your compiler to use SSE/AVX.
                                                    * 
                                                    * The alignment is tied to the unpacked records, i.e. for packed class
                                                    * variants the machine's natural alignment is switched off to recude the  
                                                    * memory footprint. Do not use any SSE/AVX operations or 
                                                    * vectorisation on the result for the packed variants, as the data is misaligned. 
                                                    * If you rely on vectorisation, convert the underlying record 
                                                    * into the unpacked version first. 
                                                    * 
                                                    * @see convert()
                                                    */
                                                   inline void setCentre(const tarch::la::Vector<DIMENSIONS,double>& centre) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                      _persistentRecords._centre = (centre);
                                                   }
                                                   
                                                   
                                                   
                                                   inline double getCentre(int elementIndex) const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                      assertion(elementIndex>=0);
                                                      assertion(elementIndex<DIMENSIONS);
                                                      return _persistentRecords._centre[elementIndex];
                                                      
                                                   }
                                                   
                                                   
                                                   
                                                   inline void setCentre(int elementIndex, const double& centre) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                      assertion(elementIndex>=0);
                                                      assertion(elementIndex<DIMENSIONS);
                                                      _persistentRecords._centre[elementIndex]= centre;
                                                      
                                                   }
                                                   
                                                   
                                                   
                                                   /**
                                                    * Generated and optimized
                                                    * 
                                                    * If you realise a for loop using exclusively arrays (vectors) and compile 
                                                    * with -DUseManualAlignment you may add 
                                                    * \code
                                                    #pragma vector aligned
                                                    #pragma simd
                                                    \endcode to this for loop to enforce your compiler to use SSE/AVX.
                                                    * 
                                                    * The alignment is tied to the unpacked records, i.e. for packed class
                                                    * variants the machine's natural alignment is switched off to recude the  
                                                    * memory footprint. Do not use any SSE/AVX operations or 
                                                    * vectorisation on the result for the packed variants, as the data is misaligned. 
                                                    * If you rely on vectorisation, convert the underlying record 
                                                    * into the unpacked version first. 
                                                    * 
                                                    * @see convert()
                                                    */
                                                   inline tarch::la::Vector<DIMENSIONS,double> getVelocity() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                      return _persistentRecords._velocity;
                                                   }
                                                   
                                                   
                                                   
                                                   /**
                                                    * Generated and optimized
                                                    * 
                                                    * If you realise a for loop using exclusively arrays (vectors) and compile 
                                                    * with -DUseManualAlignment you may add 
                                                    * \code
                                                    #pragma vector aligned
                                                    #pragma simd
                                                    \endcode to this for loop to enforce your compiler to use SSE/AVX.
                                                    * 
                                                    * The alignment is tied to the unpacked records, i.e. for packed class
                                                    * variants the machine's natural alignment is switched off to recude the  
                                                    * memory footprint. Do not use any SSE/AVX operations or 
                                                    * vectorisation on the result for the packed variants, as the data is misaligned. 
                                                    * If you rely on vectorisation, convert the underlying record 
                                                    * into the unpacked version first. 
                                                    * 
                                                    * @see convert()
                                                    */
                                                   inline void setVelocity(const tarch::la::Vector<DIMENSIONS,double>& velocity) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                      _persistentRecords._velocity = (velocity);
                                                   }
                                                   
                                                   
                                                   
                                                   inline double getVelocity(int elementIndex) const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                      assertion(elementIndex>=0);
                                                      assertion(elementIndex<DIMENSIONS);
                                                      return _persistentRecords._velocity[elementIndex];
                                                      
                                                   }
                                                   
                                                   
                                                   
                                                   inline void setVelocity(int elementIndex, const double& velocity) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                      assertion(elementIndex>=0);
                                                      assertion(elementIndex<DIMENSIONS);
                                                      _persistentRecords._velocity[elementIndex]= velocity;
                                                      
                                                   }
                                                   
                                                   
                                                   
                                                   inline double getDiameter() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                      return _persistentRecords._diameter;
                                                   }
                                                   
                                                   
                                                   
                                                   inline void setDiameter(const double& diameter) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                      _persistentRecords._diameter = diameter;
                                                   }
                                                   
                                                   
                                                   
                                                   inline double getRadius() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                      return _persistentRecords._radius;
                                                   }
                                                   
                                                   
                                                   
                                                   inline void setRadius(const double& radius) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                      _persistentRecords._radius = radius;
                                                   }
                                                   
                                                   
                                                   
                                                   inline double getEpsilon() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                      return _persistentRecords._epsilon;
                                                   }
                                                   
                                                   
                                                   
                                                   inline void setEpsilon(const double& epsilon) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                      _persistentRecords._epsilon = epsilon;
                                                   }
                                                   
                                                   
                                                   
                                                   inline double getMass() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                      return _persistentRecords._mass;
                                                   }
                                                   
                                                   
                                                   
                                                   inline void setMass(const double& mass) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                      _persistentRecords._mass = mass;
                                                   }
                                                   
                                                   
                                                   
                                                   inline double getHMin() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                      return _persistentRecords._hMin;
                                                   }
                                                   
                                                   
                                                   
                                                   inline void setHMin(const double& hMin) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                      _persistentRecords._hMin = hMin;
                                                   }
                                                   
                                                   
                                                   
                                                   /**
                                                    * Generated and optimized
                                                    * 
                                                    * If you realise a for loop using exclusively arrays (vectors) and compile 
                                                    * with -DUseManualAlignment you may add 
                                                    * \code
                                                    #pragma vector aligned
                                                    #pragma simd
                                                    \endcode to this for loop to enforce your compiler to use SSE/AVX.
                                                    * 
                                                    * The alignment is tied to the unpacked records, i.e. for packed class
                                                    * variants the machine's natural alignment is switched off to recude the  
                                                    * memory footprint. Do not use any SSE/AVX operations or 
                                                    * vectorisation on the result for the packed variants, as the data is misaligned. 
                                                    * If you rely on vectorisation, convert the underlying record 
                                                    * into the unpacked version first. 
                                                    * 
                                                    * @see convert()
                                                    */
                                                   inline tarch::la::Vector<DIMENSIONS,double> getCentreOfMass() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                      return _persistentRecords._centreOfMass;
                                                   }
                                                   
                                                   
                                                   
                                                   /**
                                                    * Generated and optimized
                                                    * 
                                                    * If you realise a for loop using exclusively arrays (vectors) and compile 
                                                    * with -DUseManualAlignment you may add 
                                                    * \code
                                                    #pragma vector aligned
                                                    #pragma simd
                                                    \endcode to this for loop to enforce your compiler to use SSE/AVX.
                                                    * 
                                                    * The alignment is tied to the unpacked records, i.e. for packed class
                                                    * variants the machine's natural alignment is switched off to recude the  
                                                    * memory footprint. Do not use any SSE/AVX operations or 
                                                    * vectorisation on the result for the packed variants, as the data is misaligned. 
                                                    * If you rely on vectorisation, convert the underlying record 
                                                    * into the unpacked version first. 
                                                    * 
                                                    * @see convert()
                                                    */
                                                   inline void setCentreOfMass(const tarch::la::Vector<DIMENSIONS,double>& centreOfMass) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                      _persistentRecords._centreOfMass = (centreOfMass);
                                                   }
                                                   
                                                   
                                                   
                                                   inline double getCentreOfMass(int elementIndex) const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                      assertion(elementIndex>=0);
                                                      assertion(elementIndex<DIMENSIONS);
                                                      return _persistentRecords._centreOfMass[elementIndex];
                                                      
                                                   }
                                                   
                                                   
                                                   
                                                   inline void setCentreOfMass(int elementIndex, const double& centreOfMass) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                      assertion(elementIndex>=0);
                                                      assertion(elementIndex<DIMENSIONS);
                                                      _persistentRecords._centreOfMass[elementIndex]= centreOfMass;
                                                      
                                                   }
                                                   
                                                   
                                                   
                                                   inline int getGlobalParticleNumber() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                      return _persistentRecords._globalParticleNumber;
                                                   }
                                                   
                                                   
                                                   
                                                   inline void setGlobalParticleNumber(const int& globalParticleNumber) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                      _persistentRecords._globalParticleNumber = globalParticleNumber;
                                                   }
                                                   
                                                   
                                                   
                                                   inline double getAngularVelocity() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                      return _persistentRecords._angularVelocity;
                                                   }
                                                   
                                                   
                                                   
                                                   inline void setAngularVelocity(const double& angularVelocity) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                      _persistentRecords._angularVelocity = angularVelocity;
                                                   }
                                                   
                                                   
                                                   
                                                   inline int getNumberOfTriangles() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                      return _persistentRecords._numberOfTriangles;
                                                   }
                                                   
                                                   
                                                   
                                                   inline void setNumberOfTriangles(const int& numberOfTriangles) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                      _persistentRecords._numberOfTriangles = numberOfTriangles;
                                                   }
                                                   
                                                   
                                                   
                                                   /**
                                                    * Generated and optimized
                                                    * 
                                                    * If you realise a for loop using exclusively arrays (vectors) and compile 
                                                    * with -DUseManualAlignment you may add 
                                                    * \code
                                                    #pragma vector aligned
                                                    #pragma simd
                                                    \endcode to this for loop to enforce your compiler to use SSE/AVX.
                                                    * 
                                                    * The alignment is tied to the unpacked records, i.e. for packed class
                                                    * variants the machine's natural alignment is switched off to recude the  
                                                    * memory footprint. Do not use any SSE/AVX operations or 
                                                    * vectorisation on the result for the packed variants, as the data is misaligned. 
                                                    * If you rely on vectorisation, convert the underlying record 
                                                    * into the unpacked version first. 
                                                    * 
                                                    * @see convert()
                                                    */
                                                   inline tarch::la::Vector<DIMENSIONS,int> getVertices() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                      return _persistentRecords._vertices;
                                                   }
                                                   
                                                   
                                                   
                                                   /**
                                                    * Generated and optimized
                                                    * 
                                                    * If you realise a for loop using exclusively arrays (vectors) and compile 
                                                    * with -DUseManualAlignment you may add 
                                                    * \code
                                                    #pragma vector aligned
                                                    #pragma simd
                                                    \endcode to this for loop to enforce your compiler to use SSE/AVX.
                                                    * 
                                                    * The alignment is tied to the unpacked records, i.e. for packed class
                                                    * variants the machine's natural alignment is switched off to recude the  
                                                    * memory footprint. Do not use any SSE/AVX operations or 
                                                    * vectorisation on the result for the packed variants, as the data is misaligned. 
                                                    * If you rely on vectorisation, convert the underlying record 
                                                    * into the unpacked version first. 
                                                    * 
                                                    * @see convert()
                                                    */
                                                   inline void setVertices(const tarch::la::Vector<DIMENSIONS,int>& vertices) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                      _persistentRecords._vertices = (vertices);
                                                   }
                                                   
                                                   
                                                   
                                                   inline int getVertices(int elementIndex) const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                      assertion(elementIndex>=0);
                                                      assertion(elementIndex<DIMENSIONS);
                                                      return _persistentRecords._vertices[elementIndex];
                                                      
                                                   }
                                                   
                                                   
                                                   
                                                   inline void setVertices(int elementIndex, const int& vertices) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                      assertion(elementIndex>=0);
                                                      assertion(elementIndex<DIMENSIONS);
                                                      _persistentRecords._vertices[elementIndex]= vertices;
                                                      
                                                   }
                                                   
                                                   
                                                   /**
                                                    * Generated
                                                    */
                                                   std::string toString() const;
                                                   
                                                   /**
                                                    * Generated
                                                    */
                                                   void toString(std::ostream& out) const;
                                                   
                                                   
                                                   PersistentRecords getPersistentRecords() const;
                                                   /**
                                                    * Generated
                                                    */
                                                   Particle convert() const;
                                                   
                                                   
                                                #ifdef Parallel
                                                   protected:
                                                      static tarch::logging::Log _log;
                                                      
                                                   public:
                                                      
                                                      /**
                                                       * Global that represents the mpi datatype.
                                                       * There are two variants: Datatype identifies only those attributes marked with
                                                       * parallelise. FullDatatype instead identifies the whole record with all fields.
                                                       */
                                                      static MPI_Datatype Datatype;
                                                      static MPI_Datatype FullDatatype;
                                                      
                                                      /**
                                                       * Initializes the data type for the mpi operations. Has to be called
                                                       * before the very first send or receive operation is called.
                                                       */
                                                      static void initDatatype();
                                                      
                                                      static void shutdownDatatype();
                                                      
                                                      /**
                                                       * @param communicateSleep -1 Data exchange through blocking mpi
                                                       * @param communicateSleep  0 Data exchange through non-blocking mpi, i.e. pending messages are received via polling until MPI_Test succeeds
                                                       * @param communicateSleep >0 Same as 0 but in addition, each unsuccessful MPI_Test is follows by an usleep
                                                       */
                                                      void send(int destination, int tag, bool exchangeOnlyAttributesMarkedWithParallelise, int communicateSleep);
                                                      
                                                      void receive(int source, int tag, bool exchangeOnlyAttributesMarkedWithParallelise, int communicateSleep);
                                                      
                                                      static bool isMessageInQueue(int tag, bool exchangeOnlyAttributesMarkedWithParallelise);
                                                      
                                                      #endif
                                                         
                                                      };
                                                      
                                                      #ifdef PackedRecords
                                                      #pragma pack (pop)
                                                      #endif
                                                      
                                                      
                                                      
                                                   
                                                #elif !defined(Dim2) && defined(Dim3)
                                                   /**
                                                    * @author This class is generated by DaStGen
                                                    * 		   DataStructureGenerator (DaStGen)
                                                    * 		   2007-2009 Wolfgang Eckhardt
                                                    * 		   2012      Tobias Weinzierl
                                                    *
                                                    * 		   build date: 09-02-2014 14:40
                                                    *
                                                    * @date   26/08/2016 13:52
                                                    */
                                                   class dem::records::Particle { 
                                                      
                                                      public:
                                                         
                                                         typedef dem::records::ParticlePacked Packed;
                                                         
                                                         struct PersistentRecords {
                                                            #ifdef UseManualAlignment
                                                            tarch::la::Vector<DIMENSIONS,double> _centre __attribute__((aligned(VectorisationAlignment)));
                                                            #else
                                                            tarch::la::Vector<DIMENSIONS,double> _centre;
                                                            #endif
                                                            #ifdef UseManualAlignment
                                                            tarch::la::Vector<DIMENSIONS,double> _velocity __attribute__((aligned(VectorisationAlignment)));
                                                            #else
                                                            tarch::la::Vector<DIMENSIONS,double> _velocity;
                                                            #endif
                                                            double _diameter;
                                                            double _radius;
                                                            double _epsilon;
                                                            double _mass;
                                                            double _hMin;
                                                            #ifdef UseManualAlignment
                                                            tarch::la::Vector<DIMENSIONS,double> _centreOfMass __attribute__((aligned(VectorisationAlignment)));
                                                            #else
                                                            tarch::la::Vector<DIMENSIONS,double> _centreOfMass;
                                                            #endif
                                                            int _globalParticleNumber;
                                                            #ifdef UseManualAlignment
                                                            tarch::la::Vector<DIMENSIONS,double> _angularVelocity __attribute__((aligned(VectorisationAlignment)));
                                                            #else
                                                            tarch::la::Vector<DIMENSIONS,double> _angularVelocity;
                                                            #endif
                                                            int _numberOfTriangles;
                                                            #ifdef UseManualAlignment
                                                            tarch::la::Vector<DIMENSIONS,int> _vertices __attribute__((aligned(VectorisationAlignment)));
                                                            #else
                                                            tarch::la::Vector<DIMENSIONS,int> _vertices;
                                                            #endif
                                                            /**
                                                             * Generated
                                                             */
                                                            PersistentRecords();
                                                            
                                                            /**
                                                             * Generated
                                                             */
                                                            PersistentRecords(const tarch::la::Vector<DIMENSIONS,double>& centre, const tarch::la::Vector<DIMENSIONS,double>& velocity, const double& diameter, const double& radius, const double& epsilon, const double& mass, const double& hMin, const tarch::la::Vector<DIMENSIONS,double>& centreOfMass, const int& globalParticleNumber, const tarch::la::Vector<DIMENSIONS,double>& angularVelocity, const int& numberOfTriangles, const tarch::la::Vector<DIMENSIONS,int>& vertices);
                                                            
                                                            
                                                            /**
                                                             * Generated and optimized
                                                             * 
                                                             * If you realise a for loop using exclusively arrays (vectors) and compile 
                                                             * with -DUseManualAlignment you may add 
                                                             * \code
                                                             #pragma vector aligned
                                                             #pragma simd
                                                             \endcode to this for loop to enforce your compiler to use SSE/AVX.
                                                             * 
                                                             * The alignment is tied to the unpacked records, i.e. for packed class
                                                             * variants the machine's natural alignment is switched off to recude the  
                                                             * memory footprint. Do not use any SSE/AVX operations or 
                                                             * vectorisation on the result for the packed variants, as the data is misaligned. 
                                                             * If you rely on vectorisation, convert the underlying record 
                                                             * into the unpacked version first. 
                                                             * 
                                                             * @see convert()
                                                             */
                                                            inline tarch::la::Vector<DIMENSIONS,double> getCentre() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                               return _centre;
                                                            }
                                                            
                                                            
                                                            
                                                            /**
                                                             * Generated and optimized
                                                             * 
                                                             * If you realise a for loop using exclusively arrays (vectors) and compile 
                                                             * with -DUseManualAlignment you may add 
                                                             * \code
                                                             #pragma vector aligned
                                                             #pragma simd
                                                             \endcode to this for loop to enforce your compiler to use SSE/AVX.
                                                             * 
                                                             * The alignment is tied to the unpacked records, i.e. for packed class
                                                             * variants the machine's natural alignment is switched off to recude the  
                                                             * memory footprint. Do not use any SSE/AVX operations or 
                                                             * vectorisation on the result for the packed variants, as the data is misaligned. 
                                                             * If you rely on vectorisation, convert the underlying record 
                                                             * into the unpacked version first. 
                                                             * 
                                                             * @see convert()
                                                             */
                                                            inline void setCentre(const tarch::la::Vector<DIMENSIONS,double>& centre) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                               _centre = (centre);
                                                            }
                                                            
                                                            
                                                            
                                                            /**
                                                             * Generated and optimized
                                                             * 
                                                             * If you realise a for loop using exclusively arrays (vectors) and compile 
                                                             * with -DUseManualAlignment you may add 
                                                             * \code
                                                             #pragma vector aligned
                                                             #pragma simd
                                                             \endcode to this for loop to enforce your compiler to use SSE/AVX.
                                                             * 
                                                             * The alignment is tied to the unpacked records, i.e. for packed class
                                                             * variants the machine's natural alignment is switched off to recude the  
                                                             * memory footprint. Do not use any SSE/AVX operations or 
                                                             * vectorisation on the result for the packed variants, as the data is misaligned. 
                                                             * If you rely on vectorisation, convert the underlying record 
                                                             * into the unpacked version first. 
                                                             * 
                                                             * @see convert()
                                                             */
                                                            inline tarch::la::Vector<DIMENSIONS,double> getVelocity() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                               return _velocity;
                                                            }
                                                            
                                                            
                                                            
                                                            /**
                                                             * Generated and optimized
                                                             * 
                                                             * If you realise a for loop using exclusively arrays (vectors) and compile 
                                                             * with -DUseManualAlignment you may add 
                                                             * \code
                                                             #pragma vector aligned
                                                             #pragma simd
                                                             \endcode to this for loop to enforce your compiler to use SSE/AVX.
                                                             * 
                                                             * The alignment is tied to the unpacked records, i.e. for packed class
                                                             * variants the machine's natural alignment is switched off to recude the  
                                                             * memory footprint. Do not use any SSE/AVX operations or 
                                                             * vectorisation on the result for the packed variants, as the data is misaligned. 
                                                             * If you rely on vectorisation, convert the underlying record 
                                                             * into the unpacked version first. 
                                                             * 
                                                             * @see convert()
                                                             */
                                                            inline void setVelocity(const tarch::la::Vector<DIMENSIONS,double>& velocity) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                               _velocity = (velocity);
                                                            }
                                                            
                                                            
                                                            
                                                            inline double getDiameter() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                               return _diameter;
                                                            }
                                                            
                                                            
                                                            
                                                            inline void setDiameter(const double& diameter) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                               _diameter = diameter;
                                                            }
                                                            
                                                            
                                                            
                                                            inline double getRadius() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                               return _radius;
                                                            }
                                                            
                                                            
                                                            
                                                            inline void setRadius(const double& radius) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                               _radius = radius;
                                                            }
                                                            
                                                            
                                                            
                                                            inline double getEpsilon() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                               return _epsilon;
                                                            }
                                                            
                                                            
                                                            
                                                            inline void setEpsilon(const double& epsilon) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                               _epsilon = epsilon;
                                                            }
                                                            
                                                            
                                                            
                                                            inline double getMass() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                               return _mass;
                                                            }
                                                            
                                                            
                                                            
                                                            inline void setMass(const double& mass) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                               _mass = mass;
                                                            }
                                                            
                                                            
                                                            
                                                            inline double getHMin() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                               return _hMin;
                                                            }
                                                            
                                                            
                                                            
                                                            inline void setHMin(const double& hMin) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                               _hMin = hMin;
                                                            }
                                                            
                                                            
                                                            
                                                            /**
                                                             * Generated and optimized
                                                             * 
                                                             * If you realise a for loop using exclusively arrays (vectors) and compile 
                                                             * with -DUseManualAlignment you may add 
                                                             * \code
                                                             #pragma vector aligned
                                                             #pragma simd
                                                             \endcode to this for loop to enforce your compiler to use SSE/AVX.
                                                             * 
                                                             * The alignment is tied to the unpacked records, i.e. for packed class
                                                             * variants the machine's natural alignment is switched off to recude the  
                                                             * memory footprint. Do not use any SSE/AVX operations or 
                                                             * vectorisation on the result for the packed variants, as the data is misaligned. 
                                                             * If you rely on vectorisation, convert the underlying record 
                                                             * into the unpacked version first. 
                                                             * 
                                                             * @see convert()
                                                             */
                                                            inline tarch::la::Vector<DIMENSIONS,double> getCentreOfMass() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                               return _centreOfMass;
                                                            }
                                                            
                                                            
                                                            
                                                            /**
                                                             * Generated and optimized
                                                             * 
                                                             * If you realise a for loop using exclusively arrays (vectors) and compile 
                                                             * with -DUseManualAlignment you may add 
                                                             * \code
                                                             #pragma vector aligned
                                                             #pragma simd
                                                             \endcode to this for loop to enforce your compiler to use SSE/AVX.
                                                             * 
                                                             * The alignment is tied to the unpacked records, i.e. for packed class
                                                             * variants the machine's natural alignment is switched off to recude the  
                                                             * memory footprint. Do not use any SSE/AVX operations or 
                                                             * vectorisation on the result for the packed variants, as the data is misaligned. 
                                                             * If you rely on vectorisation, convert the underlying record 
                                                             * into the unpacked version first. 
                                                             * 
                                                             * @see convert()
                                                             */
                                                            inline void setCentreOfMass(const tarch::la::Vector<DIMENSIONS,double>& centreOfMass) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                               _centreOfMass = (centreOfMass);
                                                            }
                                                            
                                                            
                                                            
                                                            inline int getGlobalParticleNumber() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                               return _globalParticleNumber;
                                                            }
                                                            
                                                            
                                                            
                                                            inline void setGlobalParticleNumber(const int& globalParticleNumber) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                               _globalParticleNumber = globalParticleNumber;
                                                            }
                                                            
                                                            
                                                            
                                                            /**
                                                             * Generated and optimized
                                                             * 
                                                             * If you realise a for loop using exclusively arrays (vectors) and compile 
                                                             * with -DUseManualAlignment you may add 
                                                             * \code
                                                             #pragma vector aligned
                                                             #pragma simd
                                                             \endcode to this for loop to enforce your compiler to use SSE/AVX.
                                                             * 
                                                             * The alignment is tied to the unpacked records, i.e. for packed class
                                                             * variants the machine's natural alignment is switched off to recude the  
                                                             * memory footprint. Do not use any SSE/AVX operations or 
                                                             * vectorisation on the result for the packed variants, as the data is misaligned. 
                                                             * If you rely on vectorisation, convert the underlying record 
                                                             * into the unpacked version first. 
                                                             * 
                                                             * @see convert()
                                                             */
                                                            inline tarch::la::Vector<DIMENSIONS,double> getAngularVelocity() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                               return _angularVelocity;
                                                            }
                                                            
                                                            
                                                            
                                                            /**
                                                             * Generated and optimized
                                                             * 
                                                             * If you realise a for loop using exclusively arrays (vectors) and compile 
                                                             * with -DUseManualAlignment you may add 
                                                             * \code
                                                             #pragma vector aligned
                                                             #pragma simd
                                                             \endcode to this for loop to enforce your compiler to use SSE/AVX.
                                                             * 
                                                             * The alignment is tied to the unpacked records, i.e. for packed class
                                                             * variants the machine's natural alignment is switched off to recude the  
                                                             * memory footprint. Do not use any SSE/AVX operations or 
                                                             * vectorisation on the result for the packed variants, as the data is misaligned. 
                                                             * If you rely on vectorisation, convert the underlying record 
                                                             * into the unpacked version first. 
                                                             * 
                                                             * @see convert()
                                                             */
                                                            inline void setAngularVelocity(const tarch::la::Vector<DIMENSIONS,double>& angularVelocity) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                               _angularVelocity = (angularVelocity);
                                                            }
                                                            
                                                            
                                                            
                                                            inline int getNumberOfTriangles() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                               return _numberOfTriangles;
                                                            }
                                                            
                                                            
                                                            
                                                            inline void setNumberOfTriangles(const int& numberOfTriangles) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                               _numberOfTriangles = numberOfTriangles;
                                                            }
                                                            
                                                            
                                                            
                                                            /**
                                                             * Generated and optimized
                                                             * 
                                                             * If you realise a for loop using exclusively arrays (vectors) and compile 
                                                             * with -DUseManualAlignment you may add 
                                                             * \code
                                                             #pragma vector aligned
                                                             #pragma simd
                                                             \endcode to this for loop to enforce your compiler to use SSE/AVX.
                                                             * 
                                                             * The alignment is tied to the unpacked records, i.e. for packed class
                                                             * variants the machine's natural alignment is switched off to recude the  
                                                             * memory footprint. Do not use any SSE/AVX operations or 
                                                             * vectorisation on the result for the packed variants, as the data is misaligned. 
                                                             * If you rely on vectorisation, convert the underlying record 
                                                             * into the unpacked version first. 
                                                             * 
                                                             * @see convert()
                                                             */
                                                            inline tarch::la::Vector<DIMENSIONS,int> getVertices() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                               return _vertices;
                                                            }
                                                            
                                                            
                                                            
                                                            /**
                                                             * Generated and optimized
                                                             * 
                                                             * If you realise a for loop using exclusively arrays (vectors) and compile 
                                                             * with -DUseManualAlignment you may add 
                                                             * \code
                                                             #pragma vector aligned
                                                             #pragma simd
                                                             \endcode to this for loop to enforce your compiler to use SSE/AVX.
                                                             * 
                                                             * The alignment is tied to the unpacked records, i.e. for packed class
                                                             * variants the machine's natural alignment is switched off to recude the  
                                                             * memory footprint. Do not use any SSE/AVX operations or 
                                                             * vectorisation on the result for the packed variants, as the data is misaligned. 
                                                             * If you rely on vectorisation, convert the underlying record 
                                                             * into the unpacked version first. 
                                                             * 
                                                             * @see convert()
                                                             */
                                                            inline void setVertices(const tarch::la::Vector<DIMENSIONS,int>& vertices) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                               _vertices = (vertices);
                                                            }
                                                            
                                                            
                                                            
                                                         };
                                                         
                                                      private: 
                                                         public:

                                                         PersistentRecords _persistentRecords;
                                                         private:

                                                         
                                                      public:
                                                         /**
                                                          * Generated
                                                          */
                                                         Particle();
                                                         
                                                         /**
                                                          * Generated
                                                          */
                                                         Particle(const PersistentRecords& persistentRecords);
                                                         
                                                         /**
                                                          * Generated
                                                          */
                                                         Particle(const tarch::la::Vector<DIMENSIONS,double>& centre, const tarch::la::Vector<DIMENSIONS,double>& velocity, const double& diameter, const double& radius, const double& epsilon, const double& mass, const double& hMin, const tarch::la::Vector<DIMENSIONS,double>& centreOfMass, const int& globalParticleNumber, const tarch::la::Vector<DIMENSIONS,double>& angularVelocity, const int& numberOfTriangles, const tarch::la::Vector<DIMENSIONS,int>& vertices);
                                                         
                                                         /**
                                                          * Generated
                                                          */
                                                         ~Particle();
                                                         
                                                         
                                                         /**
                                                          * Generated and optimized
                                                          * 
                                                          * If you realise a for loop using exclusively arrays (vectors) and compile 
                                                          * with -DUseManualAlignment you may add 
                                                          * \code
                                                          #pragma vector aligned
                                                          #pragma simd
                                                          \endcode to this for loop to enforce your compiler to use SSE/AVX.
                                                          * 
                                                          * The alignment is tied to the unpacked records, i.e. for packed class
                                                          * variants the machine's natural alignment is switched off to recude the  
                                                          * memory footprint. Do not use any SSE/AVX operations or 
                                                          * vectorisation on the result for the packed variants, as the data is misaligned. 
                                                          * If you rely on vectorisation, convert the underlying record 
                                                          * into the unpacked version first. 
                                                          * 
                                                          * @see convert()
                                                          */
                                                         inline tarch::la::Vector<DIMENSIONS,double> getCentre() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                            return _persistentRecords._centre;
                                                         }
                                                         
                                                         
                                                         
                                                         /**
                                                          * Generated and optimized
                                                          * 
                                                          * If you realise a for loop using exclusively arrays (vectors) and compile 
                                                          * with -DUseManualAlignment you may add 
                                                          * \code
                                                          #pragma vector aligned
                                                          #pragma simd
                                                          \endcode to this for loop to enforce your compiler to use SSE/AVX.
                                                          * 
                                                          * The alignment is tied to the unpacked records, i.e. for packed class
                                                          * variants the machine's natural alignment is switched off to recude the  
                                                          * memory footprint. Do not use any SSE/AVX operations or 
                                                          * vectorisation on the result for the packed variants, as the data is misaligned. 
                                                          * If you rely on vectorisation, convert the underlying record 
                                                          * into the unpacked version first. 
                                                          * 
                                                          * @see convert()
                                                          */
                                                         inline void setCentre(const tarch::la::Vector<DIMENSIONS,double>& centre) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                            _persistentRecords._centre = (centre);
                                                         }
                                                         
                                                         
                                                         
                                                         inline double getCentre(int elementIndex) const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                            assertion(elementIndex>=0);
                                                            assertion(elementIndex<DIMENSIONS);
                                                            return _persistentRecords._centre[elementIndex];
                                                            
                                                         }
                                                         
                                                         
                                                         
                                                         inline void setCentre(int elementIndex, const double& centre) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                            assertion(elementIndex>=0);
                                                            assertion(elementIndex<DIMENSIONS);
                                                            _persistentRecords._centre[elementIndex]= centre;
                                                            
                                                         }
                                                         
                                                         
                                                         
                                                         /**
                                                          * Generated and optimized
                                                          * 
                                                          * If you realise a for loop using exclusively arrays (vectors) and compile 
                                                          * with -DUseManualAlignment you may add 
                                                          * \code
                                                          #pragma vector aligned
                                                          #pragma simd
                                                          \endcode to this for loop to enforce your compiler to use SSE/AVX.
                                                          * 
                                                          * The alignment is tied to the unpacked records, i.e. for packed class
                                                          * variants the machine's natural alignment is switched off to recude the  
                                                          * memory footprint. Do not use any SSE/AVX operations or 
                                                          * vectorisation on the result for the packed variants, as the data is misaligned. 
                                                          * If you rely on vectorisation, convert the underlying record 
                                                          * into the unpacked version first. 
                                                          * 
                                                          * @see convert()
                                                          */
                                                         inline tarch::la::Vector<DIMENSIONS,double> getVelocity() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                            return _persistentRecords._velocity;
                                                         }
                                                         
                                                         
                                                         
                                                         /**
                                                          * Generated and optimized
                                                          * 
                                                          * If you realise a for loop using exclusively arrays (vectors) and compile 
                                                          * with -DUseManualAlignment you may add 
                                                          * \code
                                                          #pragma vector aligned
                                                          #pragma simd
                                                          \endcode to this for loop to enforce your compiler to use SSE/AVX.
                                                          * 
                                                          * The alignment is tied to the unpacked records, i.e. for packed class
                                                          * variants the machine's natural alignment is switched off to recude the  
                                                          * memory footprint. Do not use any SSE/AVX operations or 
                                                          * vectorisation on the result for the packed variants, as the data is misaligned. 
                                                          * If you rely on vectorisation, convert the underlying record 
                                                          * into the unpacked version first. 
                                                          * 
                                                          * @see convert()
                                                          */
                                                         inline void setVelocity(const tarch::la::Vector<DIMENSIONS,double>& velocity) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                            _persistentRecords._velocity = (velocity);
                                                         }
                                                         
                                                         
                                                         
                                                         inline double getVelocity(int elementIndex) const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                            assertion(elementIndex>=0);
                                                            assertion(elementIndex<DIMENSIONS);
                                                            return _persistentRecords._velocity[elementIndex];
                                                            
                                                         }
                                                         
                                                         
                                                         
                                                         inline void setVelocity(int elementIndex, const double& velocity) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                            assertion(elementIndex>=0);
                                                            assertion(elementIndex<DIMENSIONS);
                                                            _persistentRecords._velocity[elementIndex]= velocity;
                                                            
                                                         }
                                                         
                                                         
                                                         
                                                         inline double getDiameter() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                            return _persistentRecords._diameter;
                                                         }
                                                         
                                                         
                                                         
                                                         inline void setDiameter(const double& diameter) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                            _persistentRecords._diameter = diameter;
                                                         }
                                                         
                                                         
                                                         
                                                         inline double getRadius() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                            return _persistentRecords._radius;
                                                         }
                                                         
                                                         
                                                         
                                                         inline void setRadius(const double& radius) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                            _persistentRecords._radius = radius;
                                                         }
                                                         
                                                         
                                                         
                                                         inline double getEpsilon() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                            return _persistentRecords._epsilon;
                                                         }
                                                         
                                                         
                                                         
                                                         inline void setEpsilon(const double& epsilon) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                            _persistentRecords._epsilon = epsilon;
                                                         }
                                                         
                                                         
                                                         
                                                         inline double getMass() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                            return _persistentRecords._mass;
                                                         }
                                                         
                                                         
                                                         
                                                         inline void setMass(const double& mass) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                            _persistentRecords._mass = mass;
                                                         }
                                                         
                                                         
                                                         
                                                         inline double getHMin() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                            return _persistentRecords._hMin;
                                                         }
                                                         
                                                         
                                                         
                                                         inline void setHMin(const double& hMin) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                            _persistentRecords._hMin = hMin;
                                                         }
                                                         
                                                         
                                                         
                                                         /**
                                                          * Generated and optimized
                                                          * 
                                                          * If you realise a for loop using exclusively arrays (vectors) and compile 
                                                          * with -DUseManualAlignment you may add 
                                                          * \code
                                                          #pragma vector aligned
                                                          #pragma simd
                                                          \endcode to this for loop to enforce your compiler to use SSE/AVX.
                                                          * 
                                                          * The alignment is tied to the unpacked records, i.e. for packed class
                                                          * variants the machine's natural alignment is switched off to recude the  
                                                          * memory footprint. Do not use any SSE/AVX operations or 
                                                          * vectorisation on the result for the packed variants, as the data is misaligned. 
                                                          * If you rely on vectorisation, convert the underlying record 
                                                          * into the unpacked version first. 
                                                          * 
                                                          * @see convert()
                                                          */
                                                         inline tarch::la::Vector<DIMENSIONS,double> getCentreOfMass() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                            return _persistentRecords._centreOfMass;
                                                         }
                                                         
                                                         
                                                         
                                                         /**
                                                          * Generated and optimized
                                                          * 
                                                          * If you realise a for loop using exclusively arrays (vectors) and compile 
                                                          * with -DUseManualAlignment you may add 
                                                          * \code
                                                          #pragma vector aligned
                                                          #pragma simd
                                                          \endcode to this for loop to enforce your compiler to use SSE/AVX.
                                                          * 
                                                          * The alignment is tied to the unpacked records, i.e. for packed class
                                                          * variants the machine's natural alignment is switched off to recude the  
                                                          * memory footprint. Do not use any SSE/AVX operations or 
                                                          * vectorisation on the result for the packed variants, as the data is misaligned. 
                                                          * If you rely on vectorisation, convert the underlying record 
                                                          * into the unpacked version first. 
                                                          * 
                                                          * @see convert()
                                                          */
                                                         inline void setCentreOfMass(const tarch::la::Vector<DIMENSIONS,double>& centreOfMass) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                            _persistentRecords._centreOfMass = (centreOfMass);
                                                         }
                                                         
                                                         
                                                         
                                                         inline double getCentreOfMass(int elementIndex) const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                            assertion(elementIndex>=0);
                                                            assertion(elementIndex<DIMENSIONS);
                                                            return _persistentRecords._centreOfMass[elementIndex];
                                                            
                                                         }
                                                         
                                                         
                                                         
                                                         inline void setCentreOfMass(int elementIndex, const double& centreOfMass) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                            assertion(elementIndex>=0);
                                                            assertion(elementIndex<DIMENSIONS);
                                                            _persistentRecords._centreOfMass[elementIndex]= centreOfMass;
                                                            
                                                         }
                                                         
                                                         
                                                         
                                                         inline int getGlobalParticleNumber() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                            return _persistentRecords._globalParticleNumber;
                                                         }
                                                         
                                                         
                                                         
                                                         inline void setGlobalParticleNumber(const int& globalParticleNumber) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                            _persistentRecords._globalParticleNumber = globalParticleNumber;
                                                         }
                                                         
                                                         
                                                         
                                                         /**
                                                          * Generated and optimized
                                                          * 
                                                          * If you realise a for loop using exclusively arrays (vectors) and compile 
                                                          * with -DUseManualAlignment you may add 
                                                          * \code
                                                          #pragma vector aligned
                                                          #pragma simd
                                                          \endcode to this for loop to enforce your compiler to use SSE/AVX.
                                                          * 
                                                          * The alignment is tied to the unpacked records, i.e. for packed class
                                                          * variants the machine's natural alignment is switched off to recude the  
                                                          * memory footprint. Do not use any SSE/AVX operations or 
                                                          * vectorisation on the result for the packed variants, as the data is misaligned. 
                                                          * If you rely on vectorisation, convert the underlying record 
                                                          * into the unpacked version first. 
                                                          * 
                                                          * @see convert()
                                                          */
                                                         inline tarch::la::Vector<DIMENSIONS,double> getAngularVelocity() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                            return _persistentRecords._angularVelocity;
                                                         }
                                                         
                                                         
                                                         
                                                         /**
                                                          * Generated and optimized
                                                          * 
                                                          * If you realise a for loop using exclusively arrays (vectors) and compile 
                                                          * with -DUseManualAlignment you may add 
                                                          * \code
                                                          #pragma vector aligned
                                                          #pragma simd
                                                          \endcode to this for loop to enforce your compiler to use SSE/AVX.
                                                          * 
                                                          * The alignment is tied to the unpacked records, i.e. for packed class
                                                          * variants the machine's natural alignment is switched off to recude the  
                                                          * memory footprint. Do not use any SSE/AVX operations or 
                                                          * vectorisation on the result for the packed variants, as the data is misaligned. 
                                                          * If you rely on vectorisation, convert the underlying record 
                                                          * into the unpacked version first. 
                                                          * 
                                                          * @see convert()
                                                          */
                                                         inline void setAngularVelocity(const tarch::la::Vector<DIMENSIONS,double>& angularVelocity) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                            _persistentRecords._angularVelocity = (angularVelocity);
                                                         }
                                                         
                                                         
                                                         
                                                         inline double getAngularVelocity(int elementIndex) const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                            assertion(elementIndex>=0);
                                                            assertion(elementIndex<DIMENSIONS);
                                                            return _persistentRecords._angularVelocity[elementIndex];
                                                            
                                                         }
                                                         
                                                         
                                                         
                                                         inline void setAngularVelocity(int elementIndex, const double& angularVelocity) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                            assertion(elementIndex>=0);
                                                            assertion(elementIndex<DIMENSIONS);
                                                            _persistentRecords._angularVelocity[elementIndex]= angularVelocity;
                                                            
                                                         }
                                                         
                                                         
                                                         
                                                         inline int getNumberOfTriangles() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                            return _persistentRecords._numberOfTriangles;
                                                         }
                                                         
                                                         
                                                         
                                                         inline void setNumberOfTriangles(const int& numberOfTriangles) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                            _persistentRecords._numberOfTriangles = numberOfTriangles;
                                                         }
                                                         
                                                         
                                                         
                                                         /**
                                                          * Generated and optimized
                                                          * 
                                                          * If you realise a for loop using exclusively arrays (vectors) and compile 
                                                          * with -DUseManualAlignment you may add 
                                                          * \code
                                                          #pragma vector aligned
                                                          #pragma simd
                                                          \endcode to this for loop to enforce your compiler to use SSE/AVX.
                                                          * 
                                                          * The alignment is tied to the unpacked records, i.e. for packed class
                                                          * variants the machine's natural alignment is switched off to recude the  
                                                          * memory footprint. Do not use any SSE/AVX operations or 
                                                          * vectorisation on the result for the packed variants, as the data is misaligned. 
                                                          * If you rely on vectorisation, convert the underlying record 
                                                          * into the unpacked version first. 
                                                          * 
                                                          * @see convert()
                                                          */
                                                         inline tarch::la::Vector<DIMENSIONS,int> getVertices() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                            return _persistentRecords._vertices;
                                                         }
                                                         
                                                         
                                                         
                                                         /**
                                                          * Generated and optimized
                                                          * 
                                                          * If you realise a for loop using exclusively arrays (vectors) and compile 
                                                          * with -DUseManualAlignment you may add 
                                                          * \code
                                                          #pragma vector aligned
                                                          #pragma simd
                                                          \endcode to this for loop to enforce your compiler to use SSE/AVX.
                                                          * 
                                                          * The alignment is tied to the unpacked records, i.e. for packed class
                                                          * variants the machine's natural alignment is switched off to recude the  
                                                          * memory footprint. Do not use any SSE/AVX operations or 
                                                          * vectorisation on the result for the packed variants, as the data is misaligned. 
                                                          * If you rely on vectorisation, convert the underlying record 
                                                          * into the unpacked version first. 
                                                          * 
                                                          * @see convert()
                                                          */
                                                         inline void setVertices(const tarch::la::Vector<DIMENSIONS,int>& vertices) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                            _persistentRecords._vertices = (vertices);
                                                         }
                                                         
                                                         
                                                         
                                                         inline int getVertices(int elementIndex) const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                            assertion(elementIndex>=0);
                                                            assertion(elementIndex<DIMENSIONS);
                                                            return _persistentRecords._vertices[elementIndex];
                                                            
                                                         }
                                                         
                                                         
                                                         
                                                         inline void setVertices(int elementIndex, const int& vertices) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                            assertion(elementIndex>=0);
                                                            assertion(elementIndex<DIMENSIONS);
                                                            _persistentRecords._vertices[elementIndex]= vertices;
                                                            
                                                         }
                                                         
                                                         
                                                         /**
                                                          * Generated
                                                          */
                                                         std::string toString() const;
                                                         
                                                         /**
                                                          * Generated
                                                          */
                                                         void toString(std::ostream& out) const;
                                                         
                                                         
                                                         PersistentRecords getPersistentRecords() const;
                                                         /**
                                                          * Generated
                                                          */
                                                         ParticlePacked convert() const;
                                                         
                                                         
                                                      #ifdef Parallel
                                                         protected:
                                                            static tarch::logging::Log _log;
                                                            
                                                         public:
                                                            
                                                            /**
                                                             * Global that represents the mpi datatype.
                                                             * There are two variants: Datatype identifies only those attributes marked with
                                                             * parallelise. FullDatatype instead identifies the whole record with all fields.
                                                             */
                                                            static MPI_Datatype Datatype;
                                                            static MPI_Datatype FullDatatype;
                                                            
                                                            /**
                                                             * Initializes the data type for the mpi operations. Has to be called
                                                             * before the very first send or receive operation is called.
                                                             */
                                                            static void initDatatype();
                                                            
                                                            static void shutdownDatatype();
                                                            
                                                            /**
                                                             * @param communicateSleep -1 Data exchange through blocking mpi
                                                             * @param communicateSleep  0 Data exchange through non-blocking mpi, i.e. pending messages are received via polling until MPI_Test succeeds
                                                             * @param communicateSleep >0 Same as 0 but in addition, each unsuccessful MPI_Test is follows by an usleep
                                                             */
                                                            void send(int destination, int tag, bool exchangeOnlyAttributesMarkedWithParallelise, int communicateSleep);
                                                            
                                                            void receive(int source, int tag, bool exchangeOnlyAttributesMarkedWithParallelise, int communicateSleep);
                                                            
                                                            static bool isMessageInQueue(int tag, bool exchangeOnlyAttributesMarkedWithParallelise);
                                                            
                                                            #endif
                                                               
                                                            };
                                                            
                                                            #ifndef DaStGenPackedPadding
                                                              #define DaStGenPackedPadding 1      // 32 bit version
                                                              // #define DaStGenPackedPadding 2   // 64 bit version
                                                            #endif
                                                            
                                                            
                                                            #ifdef PackedRecords
                                                               #pragma pack (push, DaStGenPackedPadding)
                                                            #endif
                                                            
                                                            /**
                                                             * @author This class is generated by DaStGen
                                                             * 		   DataStructureGenerator (DaStGen)
                                                             * 		   2007-2009 Wolfgang Eckhardt
                                                             * 		   2012      Tobias Weinzierl
                                                             *
                                                             * 		   build date: 09-02-2014 14:40
                                                             *
                                                             * @date   26/08/2016 13:52
                                                             */
                                                            class dem::records::ParticlePacked { 
                                                               
                                                               public:
                                                                  
                                                                  struct PersistentRecords {
                                                                     tarch::la::Vector<DIMENSIONS,double> _centre;
                                                                     tarch::la::Vector<DIMENSIONS,double> _velocity;
                                                                     double _diameter;
                                                                     double _radius;
                                                                     double _epsilon;
                                                                     double _mass;
                                                                     double _hMin;
                                                                     tarch::la::Vector<DIMENSIONS,double> _centreOfMass;
                                                                     int _globalParticleNumber;
                                                                     tarch::la::Vector<DIMENSIONS,double> _angularVelocity;
                                                                     int _numberOfTriangles;
                                                                     tarch::la::Vector<DIMENSIONS,int> _vertices;
                                                                     /**
                                                                      * Generated
                                                                      */
                                                                     PersistentRecords();
                                                                     
                                                                     /**
                                                                      * Generated
                                                                      */
                                                                     PersistentRecords(const tarch::la::Vector<DIMENSIONS,double>& centre, const tarch::la::Vector<DIMENSIONS,double>& velocity, const double& diameter, const double& radius, const double& epsilon, const double& mass, const double& hMin, const tarch::la::Vector<DIMENSIONS,double>& centreOfMass, const int& globalParticleNumber, const tarch::la::Vector<DIMENSIONS,double>& angularVelocity, const int& numberOfTriangles, const tarch::la::Vector<DIMENSIONS,int>& vertices);
                                                                     
                                                                     
                                                                     /**
                                                                      * Generated and optimized
                                                                      * 
                                                                      * If you realise a for loop using exclusively arrays (vectors) and compile 
                                                                      * with -DUseManualAlignment you may add 
                                                                      * \code
                                                                      #pragma vector aligned
                                                                      #pragma simd
                                                                      \endcode to this for loop to enforce your compiler to use SSE/AVX.
                                                                      * 
                                                                      * The alignment is tied to the unpacked records, i.e. for packed class
                                                                      * variants the machine's natural alignment is switched off to recude the  
                                                                      * memory footprint. Do not use any SSE/AVX operations or 
                                                                      * vectorisation on the result for the packed variants, as the data is misaligned. 
                                                                      * If you rely on vectorisation, convert the underlying record 
                                                                      * into the unpacked version first. 
                                                                      * 
                                                                      * @see convert()
                                                                      */
                                                                     inline tarch::la::Vector<DIMENSIONS,double> getCentre() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                                        return _centre;
                                                                     }
                                                                     
                                                                     
                                                                     
                                                                     /**
                                                                      * Generated and optimized
                                                                      * 
                                                                      * If you realise a for loop using exclusively arrays (vectors) and compile 
                                                                      * with -DUseManualAlignment you may add 
                                                                      * \code
                                                                      #pragma vector aligned
                                                                      #pragma simd
                                                                      \endcode to this for loop to enforce your compiler to use SSE/AVX.
                                                                      * 
                                                                      * The alignment is tied to the unpacked records, i.e. for packed class
                                                                      * variants the machine's natural alignment is switched off to recude the  
                                                                      * memory footprint. Do not use any SSE/AVX operations or 
                                                                      * vectorisation on the result for the packed variants, as the data is misaligned. 
                                                                      * If you rely on vectorisation, convert the underlying record 
                                                                      * into the unpacked version first. 
                                                                      * 
                                                                      * @see convert()
                                                                      */
                                                                     inline void setCentre(const tarch::la::Vector<DIMENSIONS,double>& centre) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                                        _centre = (centre);
                                                                     }
                                                                     
                                                                     
                                                                     
                                                                     /**
                                                                      * Generated and optimized
                                                                      * 
                                                                      * If you realise a for loop using exclusively arrays (vectors) and compile 
                                                                      * with -DUseManualAlignment you may add 
                                                                      * \code
                                                                      #pragma vector aligned
                                                                      #pragma simd
                                                                      \endcode to this for loop to enforce your compiler to use SSE/AVX.
                                                                      * 
                                                                      * The alignment is tied to the unpacked records, i.e. for packed class
                                                                      * variants the machine's natural alignment is switched off to recude the  
                                                                      * memory footprint. Do not use any SSE/AVX operations or 
                                                                      * vectorisation on the result for the packed variants, as the data is misaligned. 
                                                                      * If you rely on vectorisation, convert the underlying record 
                                                                      * into the unpacked version first. 
                                                                      * 
                                                                      * @see convert()
                                                                      */
                                                                     inline tarch::la::Vector<DIMENSIONS,double> getVelocity() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                                        return _velocity;
                                                                     }
                                                                     
                                                                     
                                                                     
                                                                     /**
                                                                      * Generated and optimized
                                                                      * 
                                                                      * If you realise a for loop using exclusively arrays (vectors) and compile 
                                                                      * with -DUseManualAlignment you may add 
                                                                      * \code
                                                                      #pragma vector aligned
                                                                      #pragma simd
                                                                      \endcode to this for loop to enforce your compiler to use SSE/AVX.
                                                                      * 
                                                                      * The alignment is tied to the unpacked records, i.e. for packed class
                                                                      * variants the machine's natural alignment is switched off to recude the  
                                                                      * memory footprint. Do not use any SSE/AVX operations or 
                                                                      * vectorisation on the result for the packed variants, as the data is misaligned. 
                                                                      * If you rely on vectorisation, convert the underlying record 
                                                                      * into the unpacked version first. 
                                                                      * 
                                                                      * @see convert()
                                                                      */
                                                                     inline void setVelocity(const tarch::la::Vector<DIMENSIONS,double>& velocity) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                                        _velocity = (velocity);
                                                                     }
                                                                     
                                                                     
                                                                     
                                                                     inline double getDiameter() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                                        return _diameter;
                                                                     }
                                                                     
                                                                     
                                                                     
                                                                     inline void setDiameter(const double& diameter) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                                        _diameter = diameter;
                                                                     }
                                                                     
                                                                     
                                                                     
                                                                     inline double getRadius() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                                        return _radius;
                                                                     }
                                                                     
                                                                     
                                                                     
                                                                     inline void setRadius(const double& radius) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                                        _radius = radius;
                                                                     }
                                                                     
                                                                     
                                                                     
                                                                     inline double getEpsilon() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                                        return _epsilon;
                                                                     }
                                                                     
                                                                     
                                                                     
                                                                     inline void setEpsilon(const double& epsilon) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                                        _epsilon = epsilon;
                                                                     }
                                                                     
                                                                     
                                                                     
                                                                     inline double getMass() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                                        return _mass;
                                                                     }
                                                                     
                                                                     
                                                                     
                                                                     inline void setMass(const double& mass) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                                        _mass = mass;
                                                                     }
                                                                     
                                                                     
                                                                     
                                                                     inline double getHMin() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                                        return _hMin;
                                                                     }
                                                                     
                                                                     
                                                                     
                                                                     inline void setHMin(const double& hMin) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                                        _hMin = hMin;
                                                                     }
                                                                     
                                                                     
                                                                     
                                                                     /**
                                                                      * Generated and optimized
                                                                      * 
                                                                      * If you realise a for loop using exclusively arrays (vectors) and compile 
                                                                      * with -DUseManualAlignment you may add 
                                                                      * \code
                                                                      #pragma vector aligned
                                                                      #pragma simd
                                                                      \endcode to this for loop to enforce your compiler to use SSE/AVX.
                                                                      * 
                                                                      * The alignment is tied to the unpacked records, i.e. for packed class
                                                                      * variants the machine's natural alignment is switched off to recude the  
                                                                      * memory footprint. Do not use any SSE/AVX operations or 
                                                                      * vectorisation on the result for the packed variants, as the data is misaligned. 
                                                                      * If you rely on vectorisation, convert the underlying record 
                                                                      * into the unpacked version first. 
                                                                      * 
                                                                      * @see convert()
                                                                      */
                                                                     inline tarch::la::Vector<DIMENSIONS,double> getCentreOfMass() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                                        return _centreOfMass;
                                                                     }
                                                                     
                                                                     
                                                                     
                                                                     /**
                                                                      * Generated and optimized
                                                                      * 
                                                                      * If you realise a for loop using exclusively arrays (vectors) and compile 
                                                                      * with -DUseManualAlignment you may add 
                                                                      * \code
                                                                      #pragma vector aligned
                                                                      #pragma simd
                                                                      \endcode to this for loop to enforce your compiler to use SSE/AVX.
                                                                      * 
                                                                      * The alignment is tied to the unpacked records, i.e. for packed class
                                                                      * variants the machine's natural alignment is switched off to recude the  
                                                                      * memory footprint. Do not use any SSE/AVX operations or 
                                                                      * vectorisation on the result for the packed variants, as the data is misaligned. 
                                                                      * If you rely on vectorisation, convert the underlying record 
                                                                      * into the unpacked version first. 
                                                                      * 
                                                                      * @see convert()
                                                                      */
                                                                     inline void setCentreOfMass(const tarch::la::Vector<DIMENSIONS,double>& centreOfMass) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                                        _centreOfMass = (centreOfMass);
                                                                     }
                                                                     
                                                                     
                                                                     
                                                                     inline int getGlobalParticleNumber() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                                        return _globalParticleNumber;
                                                                     }
                                                                     
                                                                     
                                                                     
                                                                     inline void setGlobalParticleNumber(const int& globalParticleNumber) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                                        _globalParticleNumber = globalParticleNumber;
                                                                     }
                                                                     
                                                                     
                                                                     
                                                                     /**
                                                                      * Generated and optimized
                                                                      * 
                                                                      * If you realise a for loop using exclusively arrays (vectors) and compile 
                                                                      * with -DUseManualAlignment you may add 
                                                                      * \code
                                                                      #pragma vector aligned
                                                                      #pragma simd
                                                                      \endcode to this for loop to enforce your compiler to use SSE/AVX.
                                                                      * 
                                                                      * The alignment is tied to the unpacked records, i.e. for packed class
                                                                      * variants the machine's natural alignment is switched off to recude the  
                                                                      * memory footprint. Do not use any SSE/AVX operations or 
                                                                      * vectorisation on the result for the packed variants, as the data is misaligned. 
                                                                      * If you rely on vectorisation, convert the underlying record 
                                                                      * into the unpacked version first. 
                                                                      * 
                                                                      * @see convert()
                                                                      */
                                                                     inline tarch::la::Vector<DIMENSIONS,double> getAngularVelocity() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                                        return _angularVelocity;
                                                                     }
                                                                     
                                                                     
                                                                     
                                                                     /**
                                                                      * Generated and optimized
                                                                      * 
                                                                      * If you realise a for loop using exclusively arrays (vectors) and compile 
                                                                      * with -DUseManualAlignment you may add 
                                                                      * \code
                                                                      #pragma vector aligned
                                                                      #pragma simd
                                                                      \endcode to this for loop to enforce your compiler to use SSE/AVX.
                                                                      * 
                                                                      * The alignment is tied to the unpacked records, i.e. for packed class
                                                                      * variants the machine's natural alignment is switched off to recude the  
                                                                      * memory footprint. Do not use any SSE/AVX operations or 
                                                                      * vectorisation on the result for the packed variants, as the data is misaligned. 
                                                                      * If you rely on vectorisation, convert the underlying record 
                                                                      * into the unpacked version first. 
                                                                      * 
                                                                      * @see convert()
                                                                      */
                                                                     inline void setAngularVelocity(const tarch::la::Vector<DIMENSIONS,double>& angularVelocity) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                                        _angularVelocity = (angularVelocity);
                                                                     }
                                                                     
                                                                     
                                                                     
                                                                     inline int getNumberOfTriangles() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                                        return _numberOfTriangles;
                                                                     }
                                                                     
                                                                     
                                                                     
                                                                     inline void setNumberOfTriangles(const int& numberOfTriangles) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                                        _numberOfTriangles = numberOfTriangles;
                                                                     }
                                                                     
                                                                     
                                                                     
                                                                     /**
                                                                      * Generated and optimized
                                                                      * 
                                                                      * If you realise a for loop using exclusively arrays (vectors) and compile 
                                                                      * with -DUseManualAlignment you may add 
                                                                      * \code
                                                                      #pragma vector aligned
                                                                      #pragma simd
                                                                      \endcode to this for loop to enforce your compiler to use SSE/AVX.
                                                                      * 
                                                                      * The alignment is tied to the unpacked records, i.e. for packed class
                                                                      * variants the machine's natural alignment is switched off to recude the  
                                                                      * memory footprint. Do not use any SSE/AVX operations or 
                                                                      * vectorisation on the result for the packed variants, as the data is misaligned. 
                                                                      * If you rely on vectorisation, convert the underlying record 
                                                                      * into the unpacked version first. 
                                                                      * 
                                                                      * @see convert()
                                                                      */
                                                                     inline tarch::la::Vector<DIMENSIONS,int> getVertices() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                                        return _vertices;
                                                                     }
                                                                     
                                                                     
                                                                     
                                                                     /**
                                                                      * Generated and optimized
                                                                      * 
                                                                      * If you realise a for loop using exclusively arrays (vectors) and compile 
                                                                      * with -DUseManualAlignment you may add 
                                                                      * \code
                                                                      #pragma vector aligned
                                                                      #pragma simd
                                                                      \endcode to this for loop to enforce your compiler to use SSE/AVX.
                                                                      * 
                                                                      * The alignment is tied to the unpacked records, i.e. for packed class
                                                                      * variants the machine's natural alignment is switched off to recude the  
                                                                      * memory footprint. Do not use any SSE/AVX operations or 
                                                                      * vectorisation on the result for the packed variants, as the data is misaligned. 
                                                                      * If you rely on vectorisation, convert the underlying record 
                                                                      * into the unpacked version first. 
                                                                      * 
                                                                      * @see convert()
                                                                      */
                                                                     inline void setVertices(const tarch::la::Vector<DIMENSIONS,int>& vertices) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                                        _vertices = (vertices);
                                                                     }
                                                                     
                                                                     
                                                                     
                                                                  };
                                                                  
                                                               private: 
                                                                  PersistentRecords _persistentRecords;
                                                                  
                                                               public:
                                                                  /**
                                                                   * Generated
                                                                   */
                                                                  ParticlePacked();
                                                                  
                                                                  /**
                                                                   * Generated
                                                                   */
                                                                  ParticlePacked(const PersistentRecords& persistentRecords);
                                                                  
                                                                  /**
                                                                   * Generated
                                                                   */
                                                                  ParticlePacked(const tarch::la::Vector<DIMENSIONS,double>& centre, const tarch::la::Vector<DIMENSIONS,double>& velocity, const double& diameter, const double& radius, const double& epsilon, const double& mass, const double& hMin, const tarch::la::Vector<DIMENSIONS,double>& centreOfMass, const int& globalParticleNumber, const tarch::la::Vector<DIMENSIONS,double>& angularVelocity, const int& numberOfTriangles, const tarch::la::Vector<DIMENSIONS,int>& vertices);
                                                                  
                                                                  /**
                                                                   * Generated
                                                                   */
                                                                  ~ParticlePacked();
                                                                  
                                                                  
                                                                  /**
                                                                   * Generated and optimized
                                                                   * 
                                                                   * If you realise a for loop using exclusively arrays (vectors) and compile 
                                                                   * with -DUseManualAlignment you may add 
                                                                   * \code
                                                                   #pragma vector aligned
                                                                   #pragma simd
                                                                   \endcode to this for loop to enforce your compiler to use SSE/AVX.
                                                                   * 
                                                                   * The alignment is tied to the unpacked records, i.e. for packed class
                                                                   * variants the machine's natural alignment is switched off to recude the  
                                                                   * memory footprint. Do not use any SSE/AVX operations or 
                                                                   * vectorisation on the result for the packed variants, as the data is misaligned. 
                                                                   * If you rely on vectorisation, convert the underlying record 
                                                                   * into the unpacked version first. 
                                                                   * 
                                                                   * @see convert()
                                                                   */
                                                                  inline tarch::la::Vector<DIMENSIONS,double> getCentre() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                                     return _persistentRecords._centre;
                                                                  }
                                                                  
                                                                  
                                                                  
                                                                  /**
                                                                   * Generated and optimized
                                                                   * 
                                                                   * If you realise a for loop using exclusively arrays (vectors) and compile 
                                                                   * with -DUseManualAlignment you may add 
                                                                   * \code
                                                                   #pragma vector aligned
                                                                   #pragma simd
                                                                   \endcode to this for loop to enforce your compiler to use SSE/AVX.
                                                                   * 
                                                                   * The alignment is tied to the unpacked records, i.e. for packed class
                                                                   * variants the machine's natural alignment is switched off to recude the  
                                                                   * memory footprint. Do not use any SSE/AVX operations or 
                                                                   * vectorisation on the result for the packed variants, as the data is misaligned. 
                                                                   * If you rely on vectorisation, convert the underlying record 
                                                                   * into the unpacked version first. 
                                                                   * 
                                                                   * @see convert()
                                                                   */
                                                                  inline void setCentre(const tarch::la::Vector<DIMENSIONS,double>& centre) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                                     _persistentRecords._centre = (centre);
                                                                  }
                                                                  
                                                                  
                                                                  
                                                                  inline double getCentre(int elementIndex) const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                                     assertion(elementIndex>=0);
                                                                     assertion(elementIndex<DIMENSIONS);
                                                                     return _persistentRecords._centre[elementIndex];
                                                                     
                                                                  }
                                                                  
                                                                  
                                                                  
                                                                  inline void setCentre(int elementIndex, const double& centre) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                                     assertion(elementIndex>=0);
                                                                     assertion(elementIndex<DIMENSIONS);
                                                                     _persistentRecords._centre[elementIndex]= centre;
                                                                     
                                                                  }
                                                                  
                                                                  
                                                                  
                                                                  /**
                                                                   * Generated and optimized
                                                                   * 
                                                                   * If you realise a for loop using exclusively arrays (vectors) and compile 
                                                                   * with -DUseManualAlignment you may add 
                                                                   * \code
                                                                   #pragma vector aligned
                                                                   #pragma simd
                                                                   \endcode to this for loop to enforce your compiler to use SSE/AVX.
                                                                   * 
                                                                   * The alignment is tied to the unpacked records, i.e. for packed class
                                                                   * variants the machine's natural alignment is switched off to recude the  
                                                                   * memory footprint. Do not use any SSE/AVX operations or 
                                                                   * vectorisation on the result for the packed variants, as the data is misaligned. 
                                                                   * If you rely on vectorisation, convert the underlying record 
                                                                   * into the unpacked version first. 
                                                                   * 
                                                                   * @see convert()
                                                                   */
                                                                  inline tarch::la::Vector<DIMENSIONS,double> getVelocity() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                                     return _persistentRecords._velocity;
                                                                  }
                                                                  
                                                                  
                                                                  
                                                                  /**
                                                                   * Generated and optimized
                                                                   * 
                                                                   * If you realise a for loop using exclusively arrays (vectors) and compile 
                                                                   * with -DUseManualAlignment you may add 
                                                                   * \code
                                                                   #pragma vector aligned
                                                                   #pragma simd
                                                                   \endcode to this for loop to enforce your compiler to use SSE/AVX.
                                                                   * 
                                                                   * The alignment is tied to the unpacked records, i.e. for packed class
                                                                   * variants the machine's natural alignment is switched off to recude the  
                                                                   * memory footprint. Do not use any SSE/AVX operations or 
                                                                   * vectorisation on the result for the packed variants, as the data is misaligned. 
                                                                   * If you rely on vectorisation, convert the underlying record 
                                                                   * into the unpacked version first. 
                                                                   * 
                                                                   * @see convert()
                                                                   */
                                                                  inline void setVelocity(const tarch::la::Vector<DIMENSIONS,double>& velocity) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                                     _persistentRecords._velocity = (velocity);
                                                                  }
                                                                  
                                                                  
                                                                  
                                                                  inline double getVelocity(int elementIndex) const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                                     assertion(elementIndex>=0);
                                                                     assertion(elementIndex<DIMENSIONS);
                                                                     return _persistentRecords._velocity[elementIndex];
                                                                     
                                                                  }
                                                                  
                                                                  
                                                                  
                                                                  inline void setVelocity(int elementIndex, const double& velocity) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                                     assertion(elementIndex>=0);
                                                                     assertion(elementIndex<DIMENSIONS);
                                                                     _persistentRecords._velocity[elementIndex]= velocity;
                                                                     
                                                                  }
                                                                  
                                                                  
                                                                  
                                                                  inline double getDiameter() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                                     return _persistentRecords._diameter;
                                                                  }
                                                                  
                                                                  
                                                                  
                                                                  inline void setDiameter(const double& diameter) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                                     _persistentRecords._diameter = diameter;
                                                                  }
                                                                  
                                                                  
                                                                  
                                                                  inline double getRadius() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                                     return _persistentRecords._radius;
                                                                  }
                                                                  
                                                                  
                                                                  
                                                                  inline void setRadius(const double& radius) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                                     _persistentRecords._radius = radius;
                                                                  }
                                                                  
                                                                  
                                                                  
                                                                  inline double getEpsilon() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                                     return _persistentRecords._epsilon;
                                                                  }
                                                                  
                                                                  
                                                                  
                                                                  inline void setEpsilon(const double& epsilon) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                                     _persistentRecords._epsilon = epsilon;
                                                                  }
                                                                  
                                                                  
                                                                  
                                                                  inline double getMass() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                                     return _persistentRecords._mass;
                                                                  }
                                                                  
                                                                  
                                                                  
                                                                  inline void setMass(const double& mass) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                                     _persistentRecords._mass = mass;
                                                                  }
                                                                  
                                                                  
                                                                  
                                                                  inline double getHMin() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                                     return _persistentRecords._hMin;
                                                                  }
                                                                  
                                                                  
                                                                  
                                                                  inline void setHMin(const double& hMin) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                                     _persistentRecords._hMin = hMin;
                                                                  }
                                                                  
                                                                  
                                                                  
                                                                  /**
                                                                   * Generated and optimized
                                                                   * 
                                                                   * If you realise a for loop using exclusively arrays (vectors) and compile 
                                                                   * with -DUseManualAlignment you may add 
                                                                   * \code
                                                                   #pragma vector aligned
                                                                   #pragma simd
                                                                   \endcode to this for loop to enforce your compiler to use SSE/AVX.
                                                                   * 
                                                                   * The alignment is tied to the unpacked records, i.e. for packed class
                                                                   * variants the machine's natural alignment is switched off to recude the  
                                                                   * memory footprint. Do not use any SSE/AVX operations or 
                                                                   * vectorisation on the result for the packed variants, as the data is misaligned. 
                                                                   * If you rely on vectorisation, convert the underlying record 
                                                                   * into the unpacked version first. 
                                                                   * 
                                                                   * @see convert()
                                                                   */
                                                                  inline tarch::la::Vector<DIMENSIONS,double> getCentreOfMass() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                                     return _persistentRecords._centreOfMass;
                                                                  }
                                                                  
                                                                  
                                                                  
                                                                  /**
                                                                   * Generated and optimized
                                                                   * 
                                                                   * If you realise a for loop using exclusively arrays (vectors) and compile 
                                                                   * with -DUseManualAlignment you may add 
                                                                   * \code
                                                                   #pragma vector aligned
                                                                   #pragma simd
                                                                   \endcode to this for loop to enforce your compiler to use SSE/AVX.
                                                                   * 
                                                                   * The alignment is tied to the unpacked records, i.e. for packed class
                                                                   * variants the machine's natural alignment is switched off to recude the  
                                                                   * memory footprint. Do not use any SSE/AVX operations or 
                                                                   * vectorisation on the result for the packed variants, as the data is misaligned. 
                                                                   * If you rely on vectorisation, convert the underlying record 
                                                                   * into the unpacked version first. 
                                                                   * 
                                                                   * @see convert()
                                                                   */
                                                                  inline void setCentreOfMass(const tarch::la::Vector<DIMENSIONS,double>& centreOfMass) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                                     _persistentRecords._centreOfMass = (centreOfMass);
                                                                  }
                                                                  
                                                                  
                                                                  
                                                                  inline double getCentreOfMass(int elementIndex) const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                                     assertion(elementIndex>=0);
                                                                     assertion(elementIndex<DIMENSIONS);
                                                                     return _persistentRecords._centreOfMass[elementIndex];
                                                                     
                                                                  }
                                                                  
                                                                  
                                                                  
                                                                  inline void setCentreOfMass(int elementIndex, const double& centreOfMass) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                                     assertion(elementIndex>=0);
                                                                     assertion(elementIndex<DIMENSIONS);
                                                                     _persistentRecords._centreOfMass[elementIndex]= centreOfMass;
                                                                     
                                                                  }
                                                                  
                                                                  
                                                                  
                                                                  inline int getGlobalParticleNumber() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                                     return _persistentRecords._globalParticleNumber;
                                                                  }
                                                                  
                                                                  
                                                                  
                                                                  inline void setGlobalParticleNumber(const int& globalParticleNumber) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                                     _persistentRecords._globalParticleNumber = globalParticleNumber;
                                                                  }
                                                                  
                                                                  
                                                                  
                                                                  /**
                                                                   * Generated and optimized
                                                                   * 
                                                                   * If you realise a for loop using exclusively arrays (vectors) and compile 
                                                                   * with -DUseManualAlignment you may add 
                                                                   * \code
                                                                   #pragma vector aligned
                                                                   #pragma simd
                                                                   \endcode to this for loop to enforce your compiler to use SSE/AVX.
                                                                   * 
                                                                   * The alignment is tied to the unpacked records, i.e. for packed class
                                                                   * variants the machine's natural alignment is switched off to recude the  
                                                                   * memory footprint. Do not use any SSE/AVX operations or 
                                                                   * vectorisation on the result for the packed variants, as the data is misaligned. 
                                                                   * If you rely on vectorisation, convert the underlying record 
                                                                   * into the unpacked version first. 
                                                                   * 
                                                                   * @see convert()
                                                                   */
                                                                  inline tarch::la::Vector<DIMENSIONS,double> getAngularVelocity() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                                     return _persistentRecords._angularVelocity;
                                                                  }
                                                                  
                                                                  
                                                                  
                                                                  /**
                                                                   * Generated and optimized
                                                                   * 
                                                                   * If you realise a for loop using exclusively arrays (vectors) and compile 
                                                                   * with -DUseManualAlignment you may add 
                                                                   * \code
                                                                   #pragma vector aligned
                                                                   #pragma simd
                                                                   \endcode to this for loop to enforce your compiler to use SSE/AVX.
                                                                   * 
                                                                   * The alignment is tied to the unpacked records, i.e. for packed class
                                                                   * variants the machine's natural alignment is switched off to recude the  
                                                                   * memory footprint. Do not use any SSE/AVX operations or 
                                                                   * vectorisation on the result for the packed variants, as the data is misaligned. 
                                                                   * If you rely on vectorisation, convert the underlying record 
                                                                   * into the unpacked version first. 
                                                                   * 
                                                                   * @see convert()
                                                                   */
                                                                  inline void setAngularVelocity(const tarch::la::Vector<DIMENSIONS,double>& angularVelocity) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                                     _persistentRecords._angularVelocity = (angularVelocity);
                                                                  }
                                                                  
                                                                  
                                                                  
                                                                  inline double getAngularVelocity(int elementIndex) const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                                     assertion(elementIndex>=0);
                                                                     assertion(elementIndex<DIMENSIONS);
                                                                     return _persistentRecords._angularVelocity[elementIndex];
                                                                     
                                                                  }
                                                                  
                                                                  
                                                                  
                                                                  inline void setAngularVelocity(int elementIndex, const double& angularVelocity) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                                     assertion(elementIndex>=0);
                                                                     assertion(elementIndex<DIMENSIONS);
                                                                     _persistentRecords._angularVelocity[elementIndex]= angularVelocity;
                                                                     
                                                                  }
                                                                  
                                                                  
                                                                  
                                                                  inline int getNumberOfTriangles() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                                     return _persistentRecords._numberOfTriangles;
                                                                  }
                                                                  
                                                                  
                                                                  
                                                                  inline void setNumberOfTriangles(const int& numberOfTriangles) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                                     _persistentRecords._numberOfTriangles = numberOfTriangles;
                                                                  }
                                                                  
                                                                  
                                                                  
                                                                  /**
                                                                   * Generated and optimized
                                                                   * 
                                                                   * If you realise a for loop using exclusively arrays (vectors) and compile 
                                                                   * with -DUseManualAlignment you may add 
                                                                   * \code
                                                                   #pragma vector aligned
                                                                   #pragma simd
                                                                   \endcode to this for loop to enforce your compiler to use SSE/AVX.
                                                                   * 
                                                                   * The alignment is tied to the unpacked records, i.e. for packed class
                                                                   * variants the machine's natural alignment is switched off to recude the  
                                                                   * memory footprint. Do not use any SSE/AVX operations or 
                                                                   * vectorisation on the result for the packed variants, as the data is misaligned. 
                                                                   * If you rely on vectorisation, convert the underlying record 
                                                                   * into the unpacked version first. 
                                                                   * 
                                                                   * @see convert()
                                                                   */
                                                                  inline tarch::la::Vector<DIMENSIONS,int> getVertices() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                                     return _persistentRecords._vertices;
                                                                  }
                                                                  
                                                                  
                                                                  
                                                                  /**
                                                                   * Generated and optimized
                                                                   * 
                                                                   * If you realise a for loop using exclusively arrays (vectors) and compile 
                                                                   * with -DUseManualAlignment you may add 
                                                                   * \code
                                                                   #pragma vector aligned
                                                                   #pragma simd
                                                                   \endcode to this for loop to enforce your compiler to use SSE/AVX.
                                                                   * 
                                                                   * The alignment is tied to the unpacked records, i.e. for packed class
                                                                   * variants the machine's natural alignment is switched off to recude the  
                                                                   * memory footprint. Do not use any SSE/AVX operations or 
                                                                   * vectorisation on the result for the packed variants, as the data is misaligned. 
                                                                   * If you rely on vectorisation, convert the underlying record 
                                                                   * into the unpacked version first. 
                                                                   * 
                                                                   * @see convert()
                                                                   */
                                                                  inline void setVertices(const tarch::la::Vector<DIMENSIONS,int>& vertices) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                                     _persistentRecords._vertices = (vertices);
                                                                  }
                                                                  
                                                                  
                                                                  
                                                                  inline int getVertices(int elementIndex) const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                                     assertion(elementIndex>=0);
                                                                     assertion(elementIndex<DIMENSIONS);
                                                                     return _persistentRecords._vertices[elementIndex];
                                                                     
                                                                  }
                                                                  
                                                                  
                                                                  
                                                                  inline void setVertices(int elementIndex, const int& vertices) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                                                                     assertion(elementIndex>=0);
                                                                     assertion(elementIndex<DIMENSIONS);
                                                                     _persistentRecords._vertices[elementIndex]= vertices;
                                                                     
                                                                  }
                                                                  
                                                                  
                                                                  /**
                                                                   * Generated
                                                                   */
                                                                  std::string toString() const;
                                                                  
                                                                  /**
                                                                   * Generated
                                                                   */
                                                                  void toString(std::ostream& out) const;
                                                                  
                                                                  
                                                                  PersistentRecords getPersistentRecords() const;
                                                                  /**
                                                                   * Generated
                                                                   */
                                                                  Particle convert() const;
                                                                  
                                                                  
                                                               #ifdef Parallel
                                                                  protected:
                                                                     static tarch::logging::Log _log;
                                                                     
                                                                  public:
                                                                     
                                                                     /**
                                                                      * Global that represents the mpi datatype.
                                                                      * There are two variants: Datatype identifies only those attributes marked with
                                                                      * parallelise. FullDatatype instead identifies the whole record with all fields.
                                                                      */
                                                                     static MPI_Datatype Datatype;
                                                                     static MPI_Datatype FullDatatype;
                                                                     
                                                                     /**
                                                                      * Initializes the data type for the mpi operations. Has to be called
                                                                      * before the very first send or receive operation is called.
                                                                      */
                                                                     static void initDatatype();
                                                                     
                                                                     static void shutdownDatatype();
                                                                     
                                                                     /**
                                                                      * @param communicateSleep -1 Data exchange through blocking mpi
                                                                      * @param communicateSleep  0 Data exchange through non-blocking mpi, i.e. pending messages are received via polling until MPI_Test succeeds
                                                                      * @param communicateSleep >0 Same as 0 but in addition, each unsuccessful MPI_Test is follows by an usleep
                                                                      */
                                                                     void send(int destination, int tag, bool exchangeOnlyAttributesMarkedWithParallelise, int communicateSleep);
                                                                     
                                                                     void receive(int source, int tag, bool exchangeOnlyAttributesMarkedWithParallelise, int communicateSleep);
                                                                     
                                                                     static bool isMessageInQueue(int tag, bool exchangeOnlyAttributesMarkedWithParallelise);
                                                                     
                                                                     #endif
                                                                        
                                                                     };
                                                                     
                                                                     #ifdef PackedRecords
                                                                     #pragma pack (pop)
                                                                     #endif
                                                                     
                                                                     
                                                                     
                                                                  
                                                               #endif
                                                               
                                                               #endif
                                                               
