Intel(R) Advisor can now assist with vectorization and show optimization
  report messages with your source code.
See "https://software.intel.com/en-us/intel-advisor-xe" for details.

Intel(R) C++ Intel(R) 64 Compiler for applications running on Intel(R) 64, Version 17.0.0.098 Build 20160721

Compiler options: -I. --std=c++11 -DDim3 -DiREAL=double -DbyteAlignment=32 -DTrackGridStatistics -fast -qopt-report=5 -fstrict-aliasing -restrict -fno-rtti -no-ipo -ip -xHost -c -o delta/collision/gjk.o

    Report from: Interprocedural optimizations [ipo]

  WHOLE PROGRAM (SAFE) [EITHER METHOD]: false
  WHOLE PROGRAM (SEEN) [TABLE METHOD]: false
  WHOLE PROGRAM (READ) [OBJECT READER METHOD]: false

INLINING OPTION VALUES:
  -inline-factor: 100
  -inline-min-size: 30
  -inline-max-size: 230
  -inline-max-total-size: 2000
  -inline-max-per-routine: disabled
  -inline-max-per-compile: disabled

In the inlining report below:
   "sz" refers to the "size" of the routine. The smaller a routine's size,
      the more likely it is to be inlined.
   "isz" refers to the "inlined size" of the routine. This is the amount
      the calling routine will grow if the called routine is inlined into it.
      The compiler generally limits the amount a routine can grow by having
      routines inlined into it.

Begin optimization report for: operator new(std::size_t, void *)

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (operator new(std::size_t, void *)) /usr/include/c++/6/new(147,1)

===========================================================================

Begin optimization report for: minimal_support_point(double *, int, double *)

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (minimal_support_point(double *, int, double *)) delta/collision/gjk.cpp(144,1)

===========================================================================

Begin optimization report for: maximal_support_point(double *, int, double *)

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (maximal_support_point(double *, int, double *)) delta/collision/gjk.cpp(158,1)

===========================================================================

Begin optimization report for: output_point(point *, int, double (*)[3], short)

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (output_point(point *, int, double (*)[3], short)) delta/collision/gjk.cpp(172,1)

===========================================================================

Begin optimization report for: minimal_sphere_support_point(point *, int, double (*)[3], double *, double, double *)

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (minimal_sphere_support_point(point *, int, double (*)[3], double *, double, double *)) delta/collision/gjk.cpp(200,1)

===========================================================================

Begin optimization report for: maximal_sphere_support_point(point *, int, double (*)[3], double *, double, double *)

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (maximal_sphere_support_point(point *, int, double (*)[3], double *, double, double *)) delta/collision/gjk.cpp(213,1)

===========================================================================

Begin optimization report for: minimal_ellip_support_point(point *, int, double (*)[3], double *, double *, double *, double *)

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (minimal_ellip_support_point(point *, int, double (*)[3], double *, double *, double *, double *)) delta/collision/gjk.cpp(226,1)

===========================================================================

Begin optimization report for: maximal_ellip_support_point(point *, int, double (*)[3], double *, double *, double *, double *)

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (maximal_ellip_support_point(point *, int, double (*)[3], double *, double *, double *, double *)) delta/collision/gjk.cpp(262,1)

===========================================================================

Begin optimization report for: gjk_convex_sphere(double *, int, double *, double, double *, double *)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gjk_convex_sphere(double *, int, double *, double, double *, double *)) [9/68=13.2%] delta/collision/gjk.cpp(464,1)
  -> INLINE (MANUAL): (485,14) minimal_support_point(double *, int, double *) (isz = 29) (sz = 40)
  -> INLINE (MANUAL): (486,14) maximal_sphere_support_point(point *, int, double (*)[3], double *, double, double *) (isz = 128) (sz = 145)
    -> INLINE (MANUAL): (214,17) output_point(point *, int, double (*)[3], short) (isz = 41) (sz = 54)
  -> (493,11) project(point *, int, double *, double *) (isz = 337) (sz = 352)
     [[ Inlining would exceed -inline-max-size value (352>230) <1>]]


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at delta/collision/gjk.cpp(483,3)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at delta/collision/gjk.cpp(147,3) inlined into delta/collision/gjk.cpp(485,14)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization   [ delta/collision/gjk.cpp(150,38) ]
      remark #15346: vector dependence: assumed ANTI dependence between dotmin (150:5) and dotmin (150:24)   [ delta/collision/gjk.cpp(150,38) ]
      remark #15346: vector dependence: assumed FLOW dependence between dotmin (150:24) and dotmin (150:5)   [ delta/collision/gjk.cpp(150,38) ]
      remark #15346: vector dependence: assumed FLOW dependence between dot (149:5) and dot (150:5)   [ delta/collision/gjk.cpp(150,38) ]
   LOOP END

   LOOP BEGIN at delta/collision/gjk.cpp(178,3) inlined into delta/collision/gjk.cpp(486,14)
      remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ delta/collision/gjk.cpp(186,5) ]

      LOOP BEGIN at delta/collision/gjk.cpp(180,5) inlined into delta/collision/gjk.cpp(486,14)
         remark #15524: loop was not vectorized: search loop cannot be vectorized unless all memory references can be aligned vector load
         remark #15328: vectorization support: non-unit strided load was emulated for the variable <w[0]->b[i]>, stride is 5   [ delta/collision/gjk.cpp(182,22) ]
         remark #15305: vectorization support: vector length 2
         remark #15452: unmasked strided loads: 1 
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at delta/collision/gjk.cpp(502,5)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between *p (504:7) and q[2] (505:7)
   remark #15346: vector dependence: assumed OUTPUT dependence between q[2] (505:7) and *p (504:7)
   remark #25015: Estimate of max trip count of loop=4
LOOP END

    Report from: Code generation optimizations [cg]

delta/collision/gjk.cpp(464,1):remark #34051: REGISTER ALLOCATION : [_Z17gjk_convex_spherePdiS_dS_S_] delta/collision/gjk.cpp:464

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   30[ rax rdx rcx rbx rbp rsi rdi r8-r15 zmm0-zmm14]
        
    Routine temporaries
        Total         :     140
            Global    :      47
            Local     :      93
        Regenerable   :      12
        Spilled       :      13
        
    Routine stack
        Variables     :     312 bytes*
            Reads     :      13 [1.28e+01 ~ 3.8%]
            Writes    :      11 [1.04e+01 ~ 3.1%]
        Spills        :     104 bytes*
            Reads     :      27 [7.08e+00 ~ 2.1%]
            Writes    :      13 [5.24e+00 ~ 1.5%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: project(point *, int, double *, double *)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (project(point *, int, double *, double *)) [10/68=14.7%] delta/collision/gjk.cpp(302,1)


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at delta/collision/gjk.cpp(316,3)
   remark #15542: loop was not vectorized: inner loop was already vectorized
   remark #25015: Estimate of max trip count of loop=4

   LOOP BEGIN at delta/collision/gjk.cpp(318,5)
      remark #15389: vectorization support: reference dot[i][j] has unaligned access   [ delta/collision/gjk.cpp(320,7) ]
      remark #15389: vectorization support: reference dot[i][j] has unaligned access   [ delta/collision/gjk.cpp(321,20) ]
      remark #15381: vectorization support: unaligned access used inside loop body
      remark #15328: vectorization support: non-unit strided load was emulated for the variable <w->w[j][0]>, stride is 5   [ delta/collision/gjk.cpp(320,20) ]
      remark #15328: vectorization support: non-unit strided load was emulated for the variable <w->w[j][1]>, stride is 5   [ delta/collision/gjk.cpp(320,20) ]
      remark #15328: vectorization support: non-unit strided load was emulated for the variable <w->w[j][2]>, stride is 5   [ delta/collision/gjk.cpp(320,20) ]
      remark #15329: vectorization support: non-unit strided store was emulated for the variable <dot[j][i]>, stride is 4   [ delta/collision/gjk.cpp(321,7) ]
      remark #15305: vectorization support: vector length 2
      remark #15399: vectorization support: unroll factor set to 2
      remark #15309: vectorization support: normalized vectorization overhead 0.214
      remark #15300: LOOP WAS VECTORIZED
      remark #15450: unmasked unaligned unit stride loads: 1 
      remark #15451: unmasked unaligned unit stride stores: 1 
      remark #15452: unmasked strided loads: 3 
      remark #15453: unmasked strided stores: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 20 
      remark #15477: vector cost: 14.000 
      remark #15478: estimated potential speedup: 1.170 
      remark #15488: --- end vector cost summary ---
      remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
      remark #25015: Estimate of max trip count of loop=1
   LOOP END

   LOOP BEGIN at delta/collision/gjk.cpp(318,5)
   <Remainder loop for vectorization>
      remark #25015: Estimate of max trip count of loop=4
   LOOP END
LOOP END

LOOP BEGIN at delta/collision/gjk.cpp(336,7)
   remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ delta/collision/gjk.cpp(336,26) ]
   remark #25015: Estimate of max trip count of loop=4
LOOP END

LOOP BEGIN at delta/collision/gjk.cpp(345,7)
   remark #15388: vectorization support: reference delta[s][j] has aligned access   [ delta/collision/gjk.cpp(349,4) ]
   remark #15388: vectorization support: reference dot[i][j] has aligned access   [ delta/collision/gjk.cpp(349,31) ]
   remark #15335: loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
   remark #15305: vectorization support: vector length 2
   remark #15309: vectorization support: normalized vectorization overhead 0.067
   remark #15456: masked unaligned unit stride loads: 2 
   remark #15457: masked unaligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 35 
   remark #15477: vector cost: 67.000 
   remark #15478: estimated potential speedup: 0.500 
   remark #15488: --- end vector cost summary ---
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=4
LOOP END

LOOP BEGIN at delta/collision/gjk.cpp(345,7)
<Remainder>
   remark #25015: Estimate of max trip count of loop=4
LOOP END

LOOP BEGIN at delta/collision/gjk.cpp(356,7)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between k (362:4) and k (362:15)
   remark #15346: vector dependence: assumed FLOW dependence between k (362:15) and k (362:4)
   remark #15346: vector dependence: assumed ANTI dependence between k (362:4) and k (362:15)
   remark #25439: unrolled with remainder by 2  
   remark #25015: Estimate of max trip count of loop=4
LOOP END

LOOP BEGIN at delta/collision/gjk.cpp(356,7)
<Remainder>
   remark #25015: Estimate of max trip count of loop=4
LOOP END

LOOP BEGIN at delta/collision/gjk.cpp(367,7)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between delta[s][j] (371:4) and delta[s][i] (376:8)
   remark #15346: vector dependence: assumed ANTI dependence between delta[s][i] (376:8) and delta[s][j] (371:4)
   remark #25015: Estimate of max trip count of loop=4

   LOOP BEGIN at delta/collision/gjk.cpp(372,4)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization
      remark #15346: vector dependence: assumed FLOW dependence between delta[s][j] (376:8) and delta[s][j] (376:8)
      remark #15346: vector dependence: assumed ANTI dependence between delta[s][j] (376:8) and delta[s][j] (376:8)
      remark #25439: unrolled with remainder by 2  
      remark #25015: Estimate of max trip count of loop=4
   LOOP END

   LOOP BEGIN at delta/collision/gjk.cpp(372,4)
   <Remainder>
      remark #25015: Estimate of max trip count of loop=4
   LOOP END
LOOP END

LOOP BEGIN at delta/collision/gjk.cpp(392,7)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between w[0] (396:11) and w->w[o] (396:11)
   remark #15346: vector dependence: assumed ANTI dependence between w->w[o] (396:11) and w[0] (396:11)
   remark #25015: Estimate of max trip count of loop=4
LOOP END

LOOP BEGIN at delta/collision/gjk.cpp(403,7)
<Peeled loop for vectorization, Distributed chunk1>
   remark #25015: Estimate of max trip count of loop=1
LOOP END

LOOP BEGIN at delta/collision/gjk.cpp(403,7)
<Distributed chunk1>
   remark #25084: Preprocess Loopnests: Moving Out Store    [ delta/collision/gjk.cpp(406,2) ]
   remark #25426: Loop Distributed (2 way) 
   remark #15388: vectorization support: reference l[i] has aligned access   [ delta/collision/gjk.cpp(405,2) ]
   remark #15388: vectorization support: reference l[i] has aligned access   [ delta/collision/gjk.cpp(405,2) ]
   remark #15305: vectorization support: vector length 2
   remark #15399: vectorization support: unroll factor set to 4
   remark #15309: vectorization support: normalized vectorization overhead 0.600
   remark #15301: PARTIAL LOOP WAS VECTORIZED
   remark #15448: unmasked aligned unit stride loads: 1 
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 34 
   remark #15477: vector cost: 2.500 
   remark #15478: estimated potential speedup: 11.480 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at delta/collision/gjk.cpp(403,7)
<Remainder loop for vectorization, Distributed chunk1>
   remark #15388: vectorization support: reference l[i] has aligned access   [ delta/collision/gjk.cpp(405,2) ]
   remark #15388: vectorization support: reference l[i] has aligned access   [ delta/collision/gjk.cpp(405,2) ]
   remark #15305: vectorization support: vector length 2
   remark #15309: vectorization support: normalized vectorization overhead 2.400
   remark #15301: REMAINDER LOOP WAS VECTORIZED
LOOP END

LOOP BEGIN at delta/collision/gjk.cpp(403,7)
<Remainder loop for vectorization, Distributed chunk1>
LOOP END

LOOP BEGIN at delta/collision/gjk.cpp(403,7)
<Distributed chunk2>
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed FLOW dependence between v[1] (406:2) and v[1] (406:2)
   remark #15346: vector dependence: assumed ANTI dependence between v[1] (406:2) and v[1] (406:2)
   remark #25439: unrolled with remainder by 2  
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25457: Number of partial sums replaced: 1
LOOP END

LOOP BEGIN at delta/collision/gjk.cpp(403,7)
<Remainder, Distributed chunk2>
LOOP END


Non-optimizable loops:


LOOP BEGIN at delta/collision/gjk.cpp(329,3)
   remark #15522: loop was not vectorized: loop control flow is too complex. Try using canonical loop form from OpenMP specification
LOOP END

    Report from: Code generation optimizations [cg]

delta/collision/gjk.cpp(320,20):remark #34069: optimization of adjacent sparse (strided) loads seems unprofitable. Details: stride { 40 }, types { F64-V128, F64-V128 }, number of elements { 2 }, select mask { 0x000000003 }.
delta/collision/gjk.cpp(320,20):remark #34069: optimization of adjacent sparse (strided) loads seems unprofitable. Details: stride { 40 }, types { F64-V128, F64-V128 }, number of elements { 2 }, select mask { 0x000000003 }.
delta/collision/gjk.cpp(302,1):remark #34051: REGISTER ALLOCATION : [_ZN45_INTERNAL_23_delta_collision_gjk_cpp_05cf27627projectEP5pointiPdS2_] delta/collision/gjk.cpp:302

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   27[ rax rdx rcx rbx rbp rsi rdi r8-r15 zmm0-zmm11]
        
    Routine temporaries
        Total         :     319
            Global    :     105
            Local     :     214
        Regenerable   :      15
        Spilled       :      14
        
    Routine stack
        Variables     :     640 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :      56 bytes*
            Reads     :      23 [1.40e+01 ~ 0.8%]
            Writes    :      12 [1.50e+01 ~ 0.8%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: gjk_convex_ellip(double *, int, double *, double *, double *, double *, double *)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gjk_convex_ellip(double *, int, double *, double *, double *, double *, double *)) [11/68=16.2%] delta/collision/gjk.cpp(520,1)
  -> INLINE (MANUAL): (544,14) minimal_support_point(double *, int, double *) (isz = 29) (sz = 40)
  -> INLINE (MANUAL): (545,14) maximal_ellip_support_point(point *, int, double (*)[3], double *, double *, double *, double *) (isz = 286) (sz = 305)
    -> INLINE (MANUAL): (279,17) output_point(point *, int, double (*)[3], short) (isz = 41) (sz = 54)
  -> (552,11) project(point *, int, double *, double *) (isz = 337) (sz = 352)
     [[ Inlining would exceed -inline-max-size value (352>230) <1>]]


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at delta/collision/gjk.cpp(542,3)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at delta/collision/gjk.cpp(147,3) inlined into delta/collision/gjk.cpp(544,14)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization   [ delta/collision/gjk.cpp(150,38) ]
      remark #15346: vector dependence: assumed ANTI dependence between dotmin (150:5) and dotmin (150:24)   [ delta/collision/gjk.cpp(150,38) ]
      remark #15346: vector dependence: assumed FLOW dependence between dotmin (150:24) and dotmin (150:5)   [ delta/collision/gjk.cpp(150,38) ]
      remark #15346: vector dependence: assumed FLOW dependence between dot (149:5) and dot (150:5)   [ delta/collision/gjk.cpp(150,38) ]
   LOOP END

   LOOP BEGIN at delta/collision/gjk.cpp(178,3) inlined into delta/collision/gjk.cpp(545,14)
      remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ delta/collision/gjk.cpp(186,5) ]

      LOOP BEGIN at delta/collision/gjk.cpp(180,5) inlined into delta/collision/gjk.cpp(545,14)
         remark #15524: loop was not vectorized: search loop cannot be vectorized unless all memory references can be aligned vector load
         remark #15328: vectorization support: non-unit strided load was emulated for the variable <w[0]->b[i]>, stride is 5   [ delta/collision/gjk.cpp(182,22) ]
         remark #15305: vectorization support: vector length 2
         remark #15452: unmasked strided loads: 1 
      LOOP END
   LOOP END

   LOOP BEGIN at delta/collision/gjk.cpp(282,3) inlined into delta/collision/gjk.cpp(545,14)
      remark #15388: vectorization support: reference T[_2] has aligned access
      remark #15389: vectorization support: reference brot[_2] has unaligned access
      remark #15381: vectorization support: unaligned access used inside loop body
      remark #15335: loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
      remark #15305: vectorization support: vector length 2
      remark #15399: vectorization support: unroll factor set to 4
      remark #15309: vectorization support: normalized vectorization overhead 1.050
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15450: unmasked unaligned unit stride loads: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 4 
      remark #15477: vector cost: 2.500 
      remark #15478: estimated potential speedup: 0.800 
      remark #15488: --- end vector cost summary ---
      remark #25436: completely unrolled by 9  
   LOOP END
LOOP END

LOOP BEGIN at delta/collision/gjk.cpp(561,5)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between *p (563:7) and q[2] (564:7)
   remark #15346: vector dependence: assumed OUTPUT dependence between q[2] (564:7) and *p (563:7)
   remark #25015: Estimate of max trip count of loop=4
LOOP END

    Report from: Code generation optimizations [cg]

delta/collision/gjk.cpp(520,1):remark #34051: REGISTER ALLOCATION : [_Z16gjk_convex_ellipPdiS_S_S_S_S_] delta/collision/gjk.cpp:520

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   31[ rax rdx rcx rbx rbp rsi rdi r8-r15 zmm0-zmm15]
        
    Routine temporaries
        Total         :     196
            Global    :      62
            Local     :     134
        Regenerable   :      14
        Spilled       :      23
        
    Routine stack
        Variables     :     312 bytes*
            Reads     :      11 [1.36e+01 ~ 3.2%]
            Writes    :      11 [1.04e+01 ~ 2.5%]
        Spills        :     184 bytes*
            Reads     :      37 [1.76e+01 ~ 4.2%]
            Writes    :      24 [1.16e+01 ~ 2.8%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: gjk_convex_point(double *, int, double *, double *)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gjk_convex_point(double *, int, double *, double *)) [12/68=17.6%] delta/collision/gjk.cpp(579,1)
  -> INLINE (MANUAL): (597,14) minimal_support_point(double *, int, double *) (isz = 29) (sz = 40)
  -> (605,11) project(point *, int, double *, double *) (isz = 337) (sz = 352)
     [[ Inlining would exceed -inline-max-size value (352>230) <1>]]


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at delta/collision/gjk.cpp(595,3)
   remark #15523: loop was not vectorized: loop control variable j was found, but loop iteration count cannot be computed before executing the loop

   LOOP BEGIN at delta/collision/gjk.cpp(147,3) inlined into delta/collision/gjk.cpp(597,14)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization   [ delta/collision/gjk.cpp(150,38) ]
      remark #15346: vector dependence: assumed ANTI dependence between dotmin (150:5) and dotmin (150:24)   [ delta/collision/gjk.cpp(150,38) ]
      remark #15346: vector dependence: assumed FLOW dependence between dotmin (150:24) and dotmin (150:5)   [ delta/collision/gjk.cpp(150,38) ]
      remark #15346: vector dependence: assumed FLOW dependence between dot (149:5) and dot (150:5)   [ delta/collision/gjk.cpp(150,38) ]
   LOOP END
LOOP END

LOOP BEGIN at delta/collision/gjk.cpp(613,5)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between *w.a[n] (615:7) and q[2] (615:7)
   remark #15346: vector dependence: assumed FLOW dependence between q[2] (615:7) and *w.a[n] (615:7)
   remark #25015: Estimate of max trip count of loop=4
LOOP END

    Report from: Code generation optimizations [cg]

delta/collision/gjk.cpp(579,1):remark #34051: REGISTER ALLOCATION : [_Z16gjk_convex_pointPdiS_S_] delta/collision/gjk.cpp:579

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   26[ rax rdx rcx rbx rbp rsi rdi r8-r15 zmm0-zmm10]
        
    Routine temporaries
        Total         :      97
            Global    :      36
            Local     :      61
        Regenerable   :      10
        Spilled       :      10
        
    Routine stack
        Variables     :     216 bytes*
            Reads     :       5 [5.44e+00 ~ 2.3%]
            Writes    :       8 [7.41e+00 ~ 3.1%]
        Spills        :      80 bytes*
            Reads     :      26 [3.85e+00 ~ 1.6%]
            Writes    :      10 [4.04e+00 ~ 1.7%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: gjk_sphere_sphere(double *, double, double *, double, double *, double *)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gjk_sphere_sphere(double *, double, double *, double, double *, double *)) [13/68=19.1%] delta/collision/gjk.cpp(629,1)


    Report from: Code generation optimizations [cg]

delta/collision/gjk.cpp(629,1):remark #34051: REGISTER ALLOCATION : [_Z17gjk_sphere_spherePddS_dS_S_] delta/collision/gjk.cpp:629

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   20[ rax rdx rcx rsi rdi r8-r9 zmm0-zmm12]
        
    Routine temporaries
        Total         :      69
            Global    :      20
            Local     :      49
        Regenerable   :       3
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: gjk_sphere_ellip(double *, double, double *, double *, double *, double *, double *)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gjk_sphere_ellip(double *, double, double *, double *, double *, double *, double *)) [14/68=20.6%] delta/collision/gjk.cpp(657,1)
  -> INLINE (MANUAL): (685,14) minimal_sphere_support_point(point *, int, double (*)[3], double *, double, double *) (isz = 131) (sz = 148)
    -> INLINE (MANUAL): (201,17) output_point(point *, int, double (*)[3], short) (isz = 41) (sz = 54)
  -> INLINE (MANUAL): (686,14) maximal_ellip_support_point(point *, int, double (*)[3], double *, double *, double *, double *) (isz = 286) (sz = 305)
    -> INLINE (MANUAL): (279,17) output_point(point *, int, double (*)[3], short) (isz = 41) (sz = 54)
  -> (693,11) project(point *, int, double *, double *) (isz = 337) (sz = 352)
     [[ Inlining would exceed -inline-max-size value (352>230) <1>]]


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at delta/collision/gjk.cpp(683,3)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at delta/collision/gjk.cpp(178,3) inlined into delta/collision/gjk.cpp(685,14)
      remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ delta/collision/gjk.cpp(186,5) ]

      LOOP BEGIN at delta/collision/gjk.cpp(180,5) inlined into delta/collision/gjk.cpp(685,14)
         remark #15524: loop was not vectorized: search loop cannot be vectorized unless all memory references can be aligned vector load
         remark #15328: vectorization support: non-unit strided load was emulated for the variable <w[0]->a[i]>, stride is 5   [ delta/collision/gjk.cpp(183,28) ]
         remark #15305: vectorization support: vector length 2
         remark #15452: unmasked strided loads: 1 
      LOOP END
   LOOP END

   LOOP BEGIN at delta/collision/gjk.cpp(178,3) inlined into delta/collision/gjk.cpp(686,14)
      remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ delta/collision/gjk.cpp(186,5) ]

      LOOP BEGIN at delta/collision/gjk.cpp(180,5) inlined into delta/collision/gjk.cpp(686,14)
         remark #15524: loop was not vectorized: search loop cannot be vectorized unless all memory references can be aligned vector load
         remark #15328: vectorization support: non-unit strided load was emulated for the variable <w[0]->b[i]>, stride is 5   [ delta/collision/gjk.cpp(182,22) ]
         remark #15305: vectorization support: vector length 2
         remark #15452: unmasked strided loads: 1 
      LOOP END
   LOOP END

   LOOP BEGIN at delta/collision/gjk.cpp(282,3) inlined into delta/collision/gjk.cpp(686,14)
      remark #15388: vectorization support: reference T[_2] has aligned access
      remark #15389: vectorization support: reference brot[_2] has unaligned access
      remark #15381: vectorization support: unaligned access used inside loop body
      remark #15335: loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
      remark #15305: vectorization support: vector length 2
      remark #15399: vectorization support: unroll factor set to 4
      remark #15309: vectorization support: normalized vectorization overhead 1.050
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15450: unmasked unaligned unit stride loads: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 4 
      remark #15477: vector cost: 2.500 
      remark #15478: estimated potential speedup: 0.800 
      remark #15488: --- end vector cost summary ---
      remark #25436: completely unrolled by 9  
   LOOP END
LOOP END

LOOP BEGIN at delta/collision/gjk.cpp(702,5)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between *p (704:7) and q[2] (705:7)
   remark #15346: vector dependence: assumed OUTPUT dependence between q[2] (705:7) and *p (704:7)
   remark #25015: Estimate of max trip count of loop=4
LOOP END

    Report from: Code generation optimizations [cg]

delta/collision/gjk.cpp(657,1):remark #34051: REGISTER ALLOCATION : [_Z16gjk_sphere_ellipPddS_S_S_S_S_] delta/collision/gjk.cpp:657

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   28[ rax rdx rcx rbx rbp rsi rdi r8-r11 r15 zmm0-zmm15]
        
    Routine temporaries
        Total         :     205
            Global    :      64
            Local     :     141
        Regenerable   :      11
        Spilled       :      24
        
    Routine stack
        Variables     :     408 bytes*
            Reads     :      13 [1.10e+01 ~ 2.8%]
            Writes    :      14 [1.34e+01 ~ 3.4%]
        Spills        :     192 bytes*
            Reads     :      31 [2.01e+01 ~ 5.1%]
            Writes    :      25 [1.65e+01 ~ 4.2%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: gjk_ellip_ellip(double *, double *, double *, double *, double *, double *, double *, double *)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gjk_ellip_ellip(double *, double *, double *, double *, double *, double *, double *, double *)) [15/68=22.1%] delta/collision/gjk.cpp(720,1)
  -> INLINE (MANUAL): (750,14) minimal_ellip_support_point(point *, int, double (*)[3], double *, double *, double *, double *) (isz = 298) (sz = 317)
    -> INLINE (MANUAL): (243,17) output_point(point *, int, double (*)[3], short) (isz = 41) (sz = 54)
  -> INLINE (MANUAL): (751,14) maximal_ellip_support_point(point *, int, double (*)[3], double *, double *, double *, double *) (isz = 286) (sz = 305)
    -> INLINE (MANUAL): (279,17) output_point(point *, int, double (*)[3], short) (isz = 41) (sz = 54)
  -> (758,11) project(point *, int, double *, double *) (isz = 337) (sz = 352)
     [[ Inlining would exceed -inline-max-size value (352>230) <1>]]


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at delta/collision/gjk.cpp(748,3)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at delta/collision/gjk.cpp(178,3) inlined into delta/collision/gjk.cpp(750,14)
      remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ delta/collision/gjk.cpp(186,5) ]

      LOOP BEGIN at delta/collision/gjk.cpp(180,5) inlined into delta/collision/gjk.cpp(750,14)
         remark #15524: loop was not vectorized: search loop cannot be vectorized unless all memory references can be aligned vector load
         remark #15328: vectorization support: non-unit strided load was emulated for the variable <w[0]->a[i]>, stride is 5   [ delta/collision/gjk.cpp(183,28) ]
         remark #15305: vectorization support: vector length 2
         remark #15452: unmasked strided loads: 1 
      LOOP END
   LOOP END

   LOOP BEGIN at delta/collision/gjk.cpp(246,3) inlined into delta/collision/gjk.cpp(750,14)
      remark #15388: vectorization support: reference T[_2] has aligned access
      remark #15389: vectorization support: reference arot[_2] has unaligned access
      remark #15381: vectorization support: unaligned access used inside loop body
      remark #15335: loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
      remark #15305: vectorization support: vector length 2
      remark #15399: vectorization support: unroll factor set to 4
      remark #15309: vectorization support: normalized vectorization overhead 1.050
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15450: unmasked unaligned unit stride loads: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 4 
      remark #15477: vector cost: 2.500 
      remark #15478: estimated potential speedup: 0.800 
      remark #15488: --- end vector cost summary ---
      remark #25436: completely unrolled by 9  
   LOOP END

   LOOP BEGIN at delta/collision/gjk.cpp(178,3) inlined into delta/collision/gjk.cpp(751,14)
      remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ delta/collision/gjk.cpp(186,5) ]

      LOOP BEGIN at delta/collision/gjk.cpp(180,5) inlined into delta/collision/gjk.cpp(751,14)
         remark #15524: loop was not vectorized: search loop cannot be vectorized unless all memory references can be aligned vector load
         remark #15328: vectorization support: non-unit strided load was emulated for the variable <w[0]->b[i]>, stride is 5   [ delta/collision/gjk.cpp(182,22) ]
         remark #15305: vectorization support: vector length 2
         remark #15452: unmasked strided loads: 1 
      LOOP END
   LOOP END

   LOOP BEGIN at delta/collision/gjk.cpp(282,3) inlined into delta/collision/gjk.cpp(751,14)
      remark #15388: vectorization support: reference T[_2] has aligned access
      remark #15389: vectorization support: reference brot[_2] has unaligned access
      remark #15381: vectorization support: unaligned access used inside loop body
      remark #15335: loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
      remark #15305: vectorization support: vector length 2
      remark #15399: vectorization support: unroll factor set to 4
      remark #15309: vectorization support: normalized vectorization overhead 1.050
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15450: unmasked unaligned unit stride loads: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 4 
      remark #15477: vector cost: 2.500 
      remark #15478: estimated potential speedup: 0.800 
      remark #15488: --- end vector cost summary ---
      remark #25436: completely unrolled by 9  
   LOOP END
LOOP END

LOOP BEGIN at delta/collision/gjk.cpp(767,5)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between *p (769:7) and q[2] (770:7)
   remark #15346: vector dependence: assumed OUTPUT dependence between q[2] (770:7) and *p (769:7)
   remark #25015: Estimate of max trip count of loop=4
LOOP END

    Report from: Code generation optimizations [cg]

delta/collision/gjk.cpp(720,1):remark #34051: REGISTER ALLOCATION : [_Z15gjk_ellip_ellipPdS_S_S_S_S_S_S_] delta/collision/gjk.cpp:720

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   28[ rax rdx rcx rbx rbp rsi rdi r8-r11 r15 zmm0-zmm15]
        
    Routine temporaries
        Total         :     257
            Global    :      77
            Local     :     180
        Regenerable   :      13
        Spilled       :      33
        
    Routine stack
        Variables     :     408 bytes*
            Reads     :      13 [1.10e+01 ~ 2.4%]
            Writes    :      14 [1.34e+01 ~ 2.9%]
        Spills        :     264 bytes*
            Reads     :      42 [2.87e+01 ~ 6.3%]
            Writes    :      36 [2.42e+01 ~ 5.3%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: gjk_ellip_point(double *, double *, double *, double *, double *)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gjk_ellip_point(double *, double *, double *, double *, double *)) [16/68=23.5%] delta/collision/gjk.cpp(785,1)
  -> INLINE (MANUAL): (809,14) minimal_ellip_support_point(point *, int, double (*)[3], double *, double *, double *, double *) (isz = 298) (sz = 317)
    -> INLINE (MANUAL): (243,17) output_point(point *, int, double (*)[3], short) (isz = 41) (sz = 54)
  -> (817,11) project(point *, int, double *, double *) (isz = 337) (sz = 352)
     [[ Inlining would exceed -inline-max-size value (352>230) <1>]]


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at delta/collision/gjk.cpp(807,3)
   remark #15541: outer loop was not auto-vectorized: consider using SIMD directive

   LOOP BEGIN at delta/collision/gjk.cpp(178,3) inlined into delta/collision/gjk.cpp(809,14)
      remark #15520: loop was not vectorized: loop with multiple exits cannot be vectorized unless it meets search loop idiom criteria   [ delta/collision/gjk.cpp(186,5) ]

      LOOP BEGIN at delta/collision/gjk.cpp(180,5) inlined into delta/collision/gjk.cpp(809,14)
         remark #15524: loop was not vectorized: search loop cannot be vectorized unless all memory references can be aligned vector load
         remark #15328: vectorization support: non-unit strided load was emulated for the variable <w[0]->a[i]>, stride is 5   [ delta/collision/gjk.cpp(183,28) ]
         remark #15305: vectorization support: vector length 2
         remark #15452: unmasked strided loads: 1 
      LOOP END
   LOOP END

   LOOP BEGIN at delta/collision/gjk.cpp(246,3) inlined into delta/collision/gjk.cpp(809,14)
      remark #15388: vectorization support: reference T[_2] has aligned access
      remark #15389: vectorization support: reference arot[_2] has unaligned access
      remark #15381: vectorization support: unaligned access used inside loop body
      remark #15335: loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
      remark #15305: vectorization support: vector length 2
      remark #15399: vectorization support: unroll factor set to 4
      remark #15309: vectorization support: normalized vectorization overhead 1.050
      remark #15449: unmasked aligned unit stride stores: 1 
      remark #15450: unmasked unaligned unit stride loads: 1 
      remark #15475: --- begin vector cost summary ---
      remark #15476: scalar cost: 4 
      remark #15477: vector cost: 2.500 
      remark #15478: estimated potential speedup: 0.800 
      remark #15488: --- end vector cost summary ---
      remark #25436: completely unrolled by 9  
   LOOP END
LOOP END

LOOP BEGIN at delta/collision/gjk.cpp(825,5)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed ANTI dependence between *w.a[n] (827:7) and q[2] (827:7)
   remark #15346: vector dependence: assumed FLOW dependence between q[2] (827:7) and *w.a[n] (827:7)
   remark #25015: Estimate of max trip count of loop=4
LOOP END

    Report from: Code generation optimizations [cg]

delta/collision/gjk.cpp(785,1):remark #34051: REGISTER ALLOCATION : [_Z15gjk_ellip_pointPdS_S_S_S_] delta/collision/gjk.cpp:785

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   28[ rax rdx rcx rbx rbp rsi rdi r8-r11 r15 zmm0-zmm15]
        
    Routine temporaries
        Total         :     162
            Global    :      52
            Local     :     110
        Regenerable   :      10
        Spilled       :      20
        
    Routine stack
        Variables     :     312 bytes*
            Reads     :       9 [1.00e+01 ~ 3.5%]
            Writes    :      11 [1.04e+01 ~ 3.6%]
        Spills        :     160 bytes*
            Reads     :      29 [1.65e+01 ~ 5.7%]
            Writes    :      21 [1.20e+01 ~ 4.2%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: gjk_convex_convex_gap(double *, int, double *, int, double *)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gjk_convex_convex_gap(double *, int, double *, int, double *)) [17/68=25.0%] delta/collision/gjk.cpp(841,1)
  -> INLINE (MANUAL): (844,7) maximal_support_point(double *, int, double *) (isz = 29) (sz = 40)
  -> INLINE (MANUAL): (845,7) minimal_support_point(double *, int, double *) (isz = 29) (sz = 40)


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at delta/collision/gjk.cpp(161,3) inlined into delta/collision/gjk.cpp(844,7)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization   [ delta/collision/gjk.cpp(164,38) ]
   remark #15346: vector dependence: assumed ANTI dependence between dotmax (164:5) and dotmax (164:24)   [ delta/collision/gjk.cpp(164,38) ]
   remark #15346: vector dependence: assumed FLOW dependence between dotmax (164:24) and dotmax (164:5)   [ delta/collision/gjk.cpp(164,38) ]
   remark #15346: vector dependence: assumed FLOW dependence between dot (163:5) and dot (164:5)   [ delta/collision/gjk.cpp(164,38) ]
LOOP END

LOOP BEGIN at delta/collision/gjk.cpp(147,3) inlined into delta/collision/gjk.cpp(845,7)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization   [ delta/collision/gjk.cpp(150,38) ]
   remark #15346: vector dependence: assumed ANTI dependence between dotmin (150:5) and dotmin (150:24)   [ delta/collision/gjk.cpp(150,38) ]
   remark #15346: vector dependence: assumed FLOW dependence between dotmin (150:24) and dotmin (150:5)   [ delta/collision/gjk.cpp(150,38) ]
   remark #15346: vector dependence: assumed FLOW dependence between dot (149:5) and dot (150:5)   [ delta/collision/gjk.cpp(150,38) ]
LOOP END

    Report from: Code generation optimizations [cg]

delta/collision/gjk.cpp(841,1):remark #34051: REGISTER ALLOCATION : [_Z21gjk_convex_convex_gapPdiS_iS_] delta/collision/gjk.cpp:841

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   17[ rax rdx rcx rsi rdi r8-r10 zmm0-zmm8]
        
    Routine temporaries
        Total         :      59
            Global    :      23
            Local     :      36
        Regenerable   :       2
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: gjk_convex_sphere_gap(double *, int, double *, double, double *)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gjk_convex_sphere_gap(double *, int, double *, double, double *)) [18/68=26.5%] delta/collision/gjk.cpp(852,1)
  -> INLINE (MANUAL): (855,7) maximal_support_point(double *, int, double *) (isz = 29) (sz = 40)
  -> INLINE (MANUAL): (856,7) minimal_sphere_support_point(point *, int, double (*)[3], double *, double, double *) (isz = 131) (sz = 148)
    -> INLINE (MANUAL): (201,17) output_point(point *, int, double (*)[3], short) (isz = 41) (sz = 54)


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at delta/collision/gjk.cpp(161,3) inlined into delta/collision/gjk.cpp(855,7)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization   [ delta/collision/gjk.cpp(164,38) ]
   remark #15346: vector dependence: assumed ANTI dependence between dotmax (164:5) and dotmax (164:24)   [ delta/collision/gjk.cpp(164,38) ]
   remark #15346: vector dependence: assumed FLOW dependence between dotmax (164:24) and dotmax (164:5)   [ delta/collision/gjk.cpp(164,38) ]
   remark #15346: vector dependence: assumed FLOW dependence between dot (163:5) and dot (164:5)   [ delta/collision/gjk.cpp(164,38) ]
LOOP END

    Report from: Code generation optimizations [cg]

delta/collision/gjk.cpp(852,1):remark #34051: REGISTER ALLOCATION : [_Z21gjk_convex_sphere_gapPdiS_dS_] delta/collision/gjk.cpp:852

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   16[ rax rdx rcx rsi rdi zmm0-zmm10]
        
    Routine temporaries
        Total         :      62
            Global    :      18
            Local     :      44
        Regenerable   :       1
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: gjk_convex_ellip_gap(double *, int, double *, double *, double *, double *)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gjk_convex_ellip_gap(double *, int, double *, double *, double *, double *)) [19/68=27.9%] delta/collision/gjk.cpp(863,1)
  -> INLINE (MANUAL): (866,7) maximal_support_point(double *, int, double *) (isz = 29) (sz = 40)
  -> INLINE (MANUAL): (867,7) minimal_ellip_support_point(point *, int, double (*)[3], double *, double *, double *, double *) (isz = 298) (sz = 317)
    -> INLINE (MANUAL): (243,17) output_point(point *, int, double (*)[3], short) (isz = 41) (sz = 54)


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at delta/collision/gjk.cpp(161,3) inlined into delta/collision/gjk.cpp(866,7)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization   [ delta/collision/gjk.cpp(164,38) ]
   remark #15346: vector dependence: assumed ANTI dependence between dotmax (164:5) and dotmax (164:24)   [ delta/collision/gjk.cpp(164,38) ]
   remark #15346: vector dependence: assumed FLOW dependence between dotmax (164:24) and dotmax (164:5)   [ delta/collision/gjk.cpp(164,38) ]
   remark #15346: vector dependence: assumed FLOW dependence between dot (163:5) and dot (164:5)   [ delta/collision/gjk.cpp(164,38) ]
LOOP END

LOOP BEGIN at delta/collision/gjk.cpp(246,3) inlined into delta/collision/gjk.cpp(867,7)
   remark #15388: vectorization support: reference T[_2] has aligned access
   remark #15389: vectorization support: reference brot[_2] has unaligned access
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 2
   remark #15399: vectorization support: unroll factor set to 4
   remark #15309: vectorization support: normalized vectorization overhead 0.150
   remark #15301: MATERIALIZED LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15450: unmasked unaligned unit stride loads: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 4 
   remark #15477: vector cost: 2.500 
   remark #15478: estimated potential speedup: 1.330 
   remark #15488: --- end vector cost summary ---
   remark #25015: Estimate of max trip count of loop=1
LOOP END

LOOP BEGIN at delta/collision/gjk.cpp(246,3) inlined into delta/collision/gjk.cpp(867,7)
<Remainder loop for vectorization>
   remark #25436: completely unrolled by 1  
LOOP END

    Report from: Code generation optimizations [cg]

delta/collision/gjk.cpp(863,1):remark #34051: REGISTER ALLOCATION : [_Z20gjk_convex_ellip_gapPdiS_S_S_S_] delta/collision/gjk.cpp:863

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   24[ rax rdx rcx rsi rdi r8-r10 zmm0-zmm15]
        
    Routine temporaries
        Total         :     115
            Global    :      18
            Local     :      97
        Regenerable   :       1
        Spilled       :       1
        
    Routine stack
        Variables     :      72 bytes*
            Reads     :       4 [0.00e+00 ~ 0.0%]
            Writes    :      13 [0.00e+00 ~ 0.0%]
        Spills        :       8 bytes*
            Reads     :       1 [0.00e+00 ~ 0.0%]
            Writes    :       1 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: gjk_sphere_sphere_gap(double *, double, double *, double, double *)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gjk_sphere_sphere_gap(double *, double, double *, double, double *)) [20/68=29.4%] delta/collision/gjk.cpp(874,1)
  -> INLINE (MANUAL): (877,7) maximal_sphere_support_point(point *, int, double (*)[3], double *, double, double *) (isz = 128) (sz = 145)
    -> INLINE (MANUAL): (214,17) output_point(point *, int, double (*)[3], short) (isz = 41) (sz = 54)
  -> INLINE (MANUAL): (878,7) minimal_sphere_support_point(point *, int, double (*)[3], double *, double, double *) (isz = 131) (sz = 148)
    -> INLINE (MANUAL): (201,17) output_point(point *, int, double (*)[3], short) (isz = 41) (sz = 54)


    Report from: Code generation optimizations [cg]

delta/collision/gjk.cpp(874,1):remark #34051: REGISTER ALLOCATION : [_Z21gjk_sphere_sphere_gapPddS_dS_] delta/collision/gjk.cpp:874

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   15[ rdx rsi rdi zmm0-zmm11]
        
    Routine temporaries
        Total         :      56
            Global    :       0
            Local     :      56
        Regenerable   :       1
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: gjk_sphere_ellip_gap(double *, double, double *, double *, double *, double *)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gjk_sphere_ellip_gap(double *, double, double *, double *, double *, double *)) [21/68=30.9%] delta/collision/gjk.cpp(885,1)
  -> INLINE (MANUAL): (888,7) maximal_sphere_support_point(point *, int, double (*)[3], double *, double, double *) (isz = 128) (sz = 145)
    -> INLINE (MANUAL): (214,17) output_point(point *, int, double (*)[3], short) (isz = 41) (sz = 54)
  -> INLINE (MANUAL): (889,7) minimal_ellip_support_point(point *, int, double (*)[3], double *, double *, double *, double *) (isz = 298) (sz = 317)
    -> INLINE (MANUAL): (243,17) output_point(point *, int, double (*)[3], short) (isz = 41) (sz = 54)


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at delta/collision/gjk.cpp(246,3) inlined into delta/collision/gjk.cpp(889,7)
   remark #15388: vectorization support: reference T[_2] has aligned access
   remark #15389: vectorization support: reference brot[_2] has unaligned access
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 2
   remark #15399: vectorization support: unroll factor set to 4
   remark #15309: vectorization support: normalized vectorization overhead 0.150
   remark #15301: MATERIALIZED LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15450: unmasked unaligned unit stride loads: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 4 
   remark #15477: vector cost: 2.500 
   remark #15478: estimated potential speedup: 1.330 
   remark #15488: --- end vector cost summary ---
   remark #25015: Estimate of max trip count of loop=1
LOOP END

LOOP BEGIN at delta/collision/gjk.cpp(246,3) inlined into delta/collision/gjk.cpp(889,7)
<Remainder loop for vectorization>
   remark #25436: completely unrolled by 1  
LOOP END

    Report from: Code generation optimizations [cg]

delta/collision/gjk.cpp(885,1):remark #34051: REGISTER ALLOCATION : [_Z20gjk_sphere_ellip_gapPddS_S_S_S_] delta/collision/gjk.cpp:885

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   21[ rdx rcx rsi rdi r8 zmm0-zmm15]
        
    Routine temporaries
        Total         :     120
            Global    :       0
            Local     :     120
        Regenerable   :       1
        Spilled       :       5
        
    Routine stack
        Variables     :      72 bytes*
            Reads     :       4 [0.00e+00 ~ -nan%]
            Writes    :      13 [0.00e+00 ~ -nan%]
        Spills        :      40 bytes*
            Reads     :       5 [0.00e+00 ~ -nan%]
            Writes    :       5 [0.00e+00 ~ -nan%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: gjk_ellip_ellip_gap(double *, double *, double *, double *, double *, double *, double *)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gjk_ellip_ellip_gap(double *, double *, double *, double *, double *, double *, double *)) [22/68=32.4%] delta/collision/gjk.cpp(896,1)
  -> INLINE (MANUAL): (899,7) maximal_ellip_support_point(point *, int, double (*)[3], double *, double *, double *, double *) (isz = 286) (sz = 305)
    -> INLINE (MANUAL): (279,17) output_point(point *, int, double (*)[3], short) (isz = 41) (sz = 54)
  -> INLINE (MANUAL): (900,7) minimal_ellip_support_point(point *, int, double (*)[3], double *, double *, double *, double *) (isz = 298) (sz = 317)
    -> INLINE (MANUAL): (243,17) output_point(point *, int, double (*)[3], short) (isz = 41) (sz = 54)


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at delta/collision/gjk.cpp(282,3) inlined into delta/collision/gjk.cpp(899,7)
   remark #15388: vectorization support: reference T[_2] has aligned access
   remark #15389: vectorization support: reference arot[_2] has unaligned access
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 2
   remark #15399: vectorization support: unroll factor set to 4
   remark #15309: vectorization support: normalized vectorization overhead 0.150
   remark #15301: MATERIALIZED LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15450: unmasked unaligned unit stride loads: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 4 
   remark #15477: vector cost: 2.500 
   remark #15478: estimated potential speedup: 1.330 
   remark #15488: --- end vector cost summary ---
   remark #25015: Estimate of max trip count of loop=1
LOOP END

LOOP BEGIN at delta/collision/gjk.cpp(282,3) inlined into delta/collision/gjk.cpp(899,7)
<Remainder loop for vectorization>
   remark #25436: completely unrolled by 1  
LOOP END

LOOP BEGIN at delta/collision/gjk.cpp(246,3) inlined into delta/collision/gjk.cpp(900,7)
   remark #15388: vectorization support: reference T[_2] has aligned access
   remark #15389: vectorization support: reference brot[_2] has unaligned access
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 2
   remark #15399: vectorization support: unroll factor set to 4
   remark #15309: vectorization support: normalized vectorization overhead 0.150
   remark #15301: MATERIALIZED LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15450: unmasked unaligned unit stride loads: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 4 
   remark #15477: vector cost: 2.500 
   remark #15478: estimated potential speedup: 1.330 
   remark #15488: --- end vector cost summary ---
   remark #25015: Estimate of max trip count of loop=1
LOOP END

LOOP BEGIN at delta/collision/gjk.cpp(246,3) inlined into delta/collision/gjk.cpp(900,7)
<Remainder loop for vectorization>
   remark #25436: completely unrolled by 1  
LOOP END

    Report from: Code generation optimizations [cg]

delta/collision/gjk.cpp(896,1):remark #34051: REGISTER ALLOCATION : [_Z19gjk_ellip_ellip_gapPdS_S_S_S_S_S_] delta/collision/gjk.cpp:896

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   23[ rax rdx rcx rsi rdi r8-r9 zmm0-zmm15]
        
    Routine temporaries
        Total         :     171
            Global    :       0
            Local     :     171
        Regenerable   :       2
        Spilled       :       5
        
    Routine stack
        Variables     :     144 bytes*
            Reads     :       8 [0.00e+00 ~ -nan%]
            Writes    :      26 [0.00e+00 ~ -nan%]
        Spills        :      40 bytes*
            Reads     :      11 [0.00e+00 ~ -nan%]
            Writes    :       5 [0.00e+00 ~ -nan%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: gjk_ellip_support_point(double *, double *, double *, double *, short, double *)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (gjk_ellip_support_point(double *, double *, double *, double *, short, double *)) [23/68=33.8%] delta/collision/gjk.cpp(908,1)
  -> INLINE (MANUAL): (909,13) minimal_ellip_support_point(point *, int, double (*)[3], double *, double *, double *, double *) (isz = 298) (sz = 317)
    -> INLINE (MANUAL): (243,17) output_point(point *, int, double (*)[3], short) (isz = 41) (sz = 54)
  -> INLINE (MANUAL): (910,8) maximal_ellip_support_point(point *, int, double (*)[3], double *, double *, double *, double *) (isz = 286) (sz = 305)
    -> INLINE (MANUAL): (279,17) output_point(point *, int, double (*)[3], short) (isz = 41) (sz = 54)


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at delta/collision/gjk.cpp(246,3) inlined into delta/collision/gjk.cpp(909,13)
   remark #15388: vectorization support: reference T[_2] has aligned access
   remark #15389: vectorization support: reference rot[_2] has unaligned access
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 2
   remark #15399: vectorization support: unroll factor set to 4
   remark #15309: vectorization support: normalized vectorization overhead 0.150
   remark #15301: MATERIALIZED LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15450: unmasked unaligned unit stride loads: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 4 
   remark #15477: vector cost: 2.500 
   remark #15478: estimated potential speedup: 1.330 
   remark #15488: --- end vector cost summary ---
   remark #25015: Estimate of max trip count of loop=1
LOOP END

LOOP BEGIN at delta/collision/gjk.cpp(246,3) inlined into delta/collision/gjk.cpp(909,13)
<Remainder loop for vectorization>
   remark #25436: completely unrolled by 1  
LOOP END

LOOP BEGIN at delta/collision/gjk.cpp(282,3) inlined into delta/collision/gjk.cpp(910,8)
   remark #15388: vectorization support: reference T[_2] has aligned access
   remark #15389: vectorization support: reference rot[_2] has unaligned access
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 2
   remark #15399: vectorization support: unroll factor set to 4
   remark #15309: vectorization support: normalized vectorization overhead 0.150
   remark #15301: MATERIALIZED LOOP WAS VECTORIZED
   remark #15449: unmasked aligned unit stride stores: 1 
   remark #15450: unmasked unaligned unit stride loads: 1 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 4 
   remark #15477: vector cost: 2.500 
   remark #15478: estimated potential speedup: 1.330 
   remark #15488: --- end vector cost summary ---
   remark #25015: Estimate of max trip count of loop=1
LOOP END

LOOP BEGIN at delta/collision/gjk.cpp(282,3) inlined into delta/collision/gjk.cpp(910,8)
<Remainder loop for vectorization>
   remark #25436: completely unrolled by 1  
LOOP END

    Report from: Code generation optimizations [cg]

delta/collision/gjk.cpp(908,1):remark #34051: REGISTER ALLOCATION : [_Z23gjk_ellip_support_pointPdS_S_S_sS_] delta/collision/gjk.cpp:908

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   23[ rax rdx rcx rsi rdi r8-r9 zmm0-zmm15]
        
    Routine temporaries
        Total         :     173
            Global    :      11
            Local     :     162
        Regenerable   :       2
        Spilled       :       0
        
    Routine stack
        Variables     :     144 bytes*
            Reads     :       8 [0.00e+00 ~ 0.0%]
            Writes    :      26 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: std::_Destroy_aux<true>::__destroy<std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::pointer>(std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::pointer, std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::pointer)

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (std::_Destroy_aux<true>::__destroy<std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::pointer>(std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::pointer, std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::pointer)) /usr/include/c++/6/bits/stl_construct.h(112,55)

===========================================================================

Begin optimization report for: std::allocator_traits<std::allocator<delta::collision::contactpoint>>::allocate(std::allocator_traits<std::allocator<delta::collision::contactpoint>>::allocator_type &, std::allocator_traits<std::allocator<delta::collision::contactpoint>>::size_type)

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (std::allocator_traits<std::allocator<delta::collision::contactpoint>>::allocate(std::allocator_traits<std::allocator<delta::collision::contactpoint>>::allocator_type &, std::allocator_traits<std::allocator<delta::collision::contactpoint>>::size_type)) /usr/include/c++/6/bits/alloc_traits.h(416,7)

===========================================================================

Begin optimization report for: std::allocator_traits<std::allocator<delta::collision::contactpoint>>::deallocate(std::allocator_traits<std::allocator<delta::collision::contactpoint>>::allocator_type &, std::allocator_traits<std::allocator<delta::collision::contactpoint>>::pointer, std::allocator_traits<std::allocator<delta::collision::contactpoint>>::size_type)

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (std::allocator_traits<std::allocator<delta::collision::contactpoint>>::deallocate(std::allocator_traits<std::allocator<delta::collision::contactpoint>>::allocator_type &, std::allocator_traits<std::allocator<delta::collision::contactpoint>>::pointer, std::allocator_traits<std::allocator<delta::collision::contactpoint>>::size_type)) /usr/include/c++/6/bits/alloc_traits.h(442,7)

===========================================================================

Begin optimization report for: std::allocator_traits<std::allocator<delta::collision::contactpoint>>::max_size(const std::allocator_traits<std::allocator<delta::collision::contactpoint>>::allocator_type &)

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (std::allocator_traits<std::allocator<delta::collision::contactpoint>>::max_size(const std::allocator_traits<std::allocator<delta::collision::contactpoint>>::allocator_type &)) /usr/include/c++/6/bits/alloc_traits.h(476,7)

===========================================================================

Begin optimization report for: std::allocator_traits<std::allocator<delta::collision::contactpoint>>::construct<delta::collision::contactpoint, const std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::value_type &>(std::allocator_traits<std::allocator<delta::collision::contactpoint>>::allocator_type &, delta::collision::contactpoint *, const std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::value_type &)

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (std::allocator_traits<std::allocator<delta::collision::contactpoint>>::construct<delta::collision::contactpoint, const std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::value_type &>(std::allocator_traits<std::allocator<delta::collision::contactpoint>>::allocator_type &, delta::collision::contactpoint *, const std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::value_type &)) /usr/include/c++/6/bits/alloc_traits.h(455,2)

===========================================================================

Begin optimization report for: std::allocator<delta::collision::contactpoint>::allocator(std::allocator<delta::collision::contactpoint> *)

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (std::allocator<delta::collision::contactpoint>::allocator(std::allocator<delta::collision::contactpoint> *)) /usr/include/c++/6/bits/allocator.h(118,27)

===========================================================================

Begin optimization report for: std::allocator<delta::collision::contactpoint>::allocator(std::allocator<delta::collision::contactpoint> *const)

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (std::allocator<delta::collision::contactpoint>::allocator(std::allocator<delta::collision::contactpoint> *const)) /usr/include/c++/6/bits/allocator.h(118,7)

===========================================================================

Begin optimization report for: std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::_M_get_Tp_allocator(const std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>> *) const

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::_M_get_Tp_allocator(const std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>> *) const) /usr/include/c++/6/bits/stl_vector.h(118,7)

===========================================================================

Begin optimization report for: std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::_Vector_base(std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>> *)

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::_Vector_base(std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>> *)) /usr/include/c++/6/bits/stl_vector.h(125,19)

===========================================================================

Begin optimization report for: std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::_Vector_base(std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>> *const)

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::_Vector_base(std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>> *const)) /usr/include/c++/6/bits/stl_vector.h(124,7)

===========================================================================

Begin optimization report for: std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::~_Vector_base(std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>> *)

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::~_Vector_base(std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>> *)) /usr/include/c++/6/bits/stl_vector.h(160,7)

===========================================================================

Begin optimization report for: std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::_M_allocate(std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>> *, std::size_t)

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::_M_allocate(std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>> *, std::size_t)) /usr/include/c++/6/bits/stl_vector.h(168,7)

===========================================================================

Begin optimization report for: std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::_Vector_impl::_Vector_impl(std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::_Vector_impl *)

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::_Vector_impl::_Vector_impl(std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::_Vector_impl *)) /usr/include/c++/6/bits/stl_vector.h(88,2)

===========================================================================

Begin optimization report for: std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::max_size(const std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>> *) const

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::max_size(const std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>> *) const) /usr/include/c++/6/bits/stl_vector.h(661,7)

===========================================================================

Begin optimization report for: std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::push_back(std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>> *, const std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::value_type &)

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::push_back(std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>> *, const std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::value_type &)) /usr/include/c++/6/bits/stl_vector.h(915,7)

===========================================================================

Begin optimization report for: std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::_M_check_len(const std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>> *, std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::size_type, const char *) const

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::_M_check_len(const std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>> *, std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::size_type, const char *) const) /usr/include/c++/6/bits/stl_vector.h(1421,7)

===========================================================================

Begin optimization report for: std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::_M_emplace_back_aux<const std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::value_type &>(std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>> *, const std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::value_type &)

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::_M_emplace_back_aux<const std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::value_type &>(std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>> *, const std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::value_type &)) /usr/include/c++/6/bits/vector.tcc(409,7)

===========================================================================

Begin optimization report for: __gnu_cxx::new_allocator<delta::collision::contactpoint>::new_allocator(__gnu_cxx::new_allocator<delta::collision::contactpoint> *)

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (__gnu_cxx::new_allocator<delta::collision::contactpoint>::new_allocator(__gnu_cxx::new_allocator<delta::collision::contactpoint> *)) /usr/include/c++/6/ext/new_allocator.h(79,45)

===========================================================================

Begin optimization report for: __gnu_cxx::new_allocator<delta::collision::contactpoint>::allocate(__gnu_cxx::new_allocator<delta::collision::contactpoint> *, __gnu_cxx::new_allocator<delta::collision::contactpoint>::size_type, const void *)

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (__gnu_cxx::new_allocator<delta::collision::contactpoint>::allocate(__gnu_cxx::new_allocator<delta::collision::contactpoint> *, __gnu_cxx::new_allocator<delta::collision::contactpoint>::size_type, const void *)) /usr/include/c++/6/ext/new_allocator.h(100,7)

===========================================================================

Begin optimization report for: __gnu_cxx::new_allocator<delta::collision::contactpoint>::deallocate(__gnu_cxx::new_allocator<delta::collision::contactpoint> *, __gnu_cxx::new_allocator<delta::collision::contactpoint>::pointer, __gnu_cxx::new_allocator<delta::collision::contactpoint>::size_type)

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (__gnu_cxx::new_allocator<delta::collision::contactpoint>::deallocate(__gnu_cxx::new_allocator<delta::collision::contactpoint> *, __gnu_cxx::new_allocator<delta::collision::contactpoint>::pointer, __gnu_cxx::new_allocator<delta::collision::contactpoint>::size_type)) /usr/include/c++/6/ext/new_allocator.h(110,7)

===========================================================================

Begin optimization report for: __gnu_cxx::new_allocator<delta::collision::contactpoint>::construct<delta::collision::contactpoint, const std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::value_type &>(__gnu_cxx::new_allocator<delta::collision::contactpoint> *, delta::collision::contactpoint *, const std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::value_type &)

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (__gnu_cxx::new_allocator<delta::collision::contactpoint>::construct<delta::collision::contactpoint, const std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::value_type &>(__gnu_cxx::new_allocator<delta::collision::contactpoint> *, delta::collision::contactpoint *, const std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::value_type &)) /usr/include/c++/6/ext/new_allocator.h(120,2)

===========================================================================

Begin optimization report for: __gnu_cxx::new_allocator<delta::collision::contactpoint>::destroy<delta::collision::contactpoint>(__gnu_cxx::new_allocator<delta::collision::contactpoint> *, delta::collision::contactpoint *)

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (__gnu_cxx::new_allocator<delta::collision::contactpoint>::destroy<delta::collision::contactpoint>(__gnu_cxx::new_allocator<delta::collision::contactpoint> *, delta::collision::contactpoint *)) /usr/include/c++/6/ext/new_allocator.h(124,27)

===========================================================================

Begin optimization report for: std::_Destroy<std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::pointer>(std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::pointer, std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::pointer)

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (std::_Destroy<std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::pointer>(std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::pointer, std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::pointer)) /usr/include/c++/6/bits/stl_construct.h(123,5)

===========================================================================

Begin optimization report for: std::forward<const std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::value_type &>(std::remove_reference<const std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::value_type &>::type &)

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (std::forward<const std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::value_type &>(std::remove_reference<const std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::value_type &>::type &)) /usr/include/c++/6/bits/move.h(77,5)

===========================================================================

Begin optimization report for: std::max<std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::size_type>(const std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::size_type &, const std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::size_type &)

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (std::max<std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::size_type>(const std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::size_type &, const std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::size_type &)) /usr/include/c++/6/bits/stl_algobase.h(220,5)

===========================================================================

Begin optimization report for: std::__make_move_if_noexcept_iterator<delta::collision::contactpoint, const delta::collision::contactpoint *>(delta::collision::contactpoint *)

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (std::__make_move_if_noexcept_iterator<delta::collision::contactpoint, const delta::collision::contactpoint *>(delta::collision::contactpoint *)) /usr/include/c++/6/bits/stl_iterator.h(1224,5)

===========================================================================

Begin optimization report for: std::__addressof<delta::collision::contactpoint>(delta::collision::contactpoint &)

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (std::__addressof<delta::collision::contactpoint>(delta::collision::contactpoint &)) /usr/include/c++/6/bits/move.h(48,5)

===========================================================================

Begin optimization report for: std::_Construct<delta::collision::contactpoint, const delta::collision::contactpoint &>(delta::collision::contactpoint *, const delta::collision::contactpoint &)

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (std::_Construct<delta::collision::contactpoint, const delta::collision::contactpoint &>(delta::collision::contactpoint *, const delta::collision::contactpoint &)) /usr/include/c++/6/bits/stl_construct.h(75,5)

===========================================================================

Begin optimization report for: delta::collision::gjk(std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>> *, int, double *, double *, double *, double, int, int, double *, double *, double *, double, int)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (delta::collision::gjk(std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>> *, int, double *, double *, double *, double, int, int, double *, double *, double *, double, int)) [52/68=76.5%] delta/collision/gjk.cpp(40,3)
  -> (41,29) std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::~vector(std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>> *) (isz = 40) (sz = 45)
     [[ Callee not marked with inlining pragma  <2>]]
  -> (41,29) std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::vector(std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>> *) (isz = 18) (sz = 23)
     [[ Called routine is noinline  <3>]]
  -> EXTERN: (44,16) delta::collision::contactpoint::contactpoint(delta::collision::contactpoint *)
  -> EXTERN: (52,55) __cxa_throw_bad_array_new_length()
  -> EXTERN: (52,55) operator new[](std::size_t)
  -> EXTERN: (53,55) __cxa_throw_bad_array_new_length()
  -> EXTERN: (53,55) operator new[](std::size_t)
  -> INLINE: (74,3) delta::collision::gjk(double *, int, double *, int, double *, double *) (isz = 324) (sz = 341)
    -> INLINE (MANUAL): (429,14) minimal_support_point(double *, int, double *) (isz = 29) (sz = 40)
    -> INLINE (MANUAL): (430,14) maximal_support_point(double *, int, double *) (isz = 29) (sz = 40)
    -> (437,11) project(point *, int, double *, double *) (isz = 337) (sz = 352)
       [[ Inlining would exceed -inline-max-size value (352>230) <1>]]
  -> EXTERN: (84,3) operator delete(void *)
  -> EXTERN: (85,3) operator delete(void *)
  -> EXTERN: (87,82) delta::collision::contactpoint::contactpoint(delta::collision::contactpoint *, const double &, const double &, const double &, const double &, const double &, const double &, const double &, const double &, const int &)
  -> EXTERN: (88,3) printf(const char *, ...)
  -> EXTERN: (88,44) delta::collision::contactpoint::getDistance(const delta::collision::contactpoint *) const
  -> EXTERN: (89,22) delta::collision::contactpoint::getDistance(const delta::collision::contactpoint *) const
  -> EXTERN: (91,27) memcpy()
  -> EXTERN: (92,43) delta::collision::contactpoint::getDistance(const delta::collision::contactpoint *) const
  -> EXTERN: (94,27) delta::collision::contactpoint::getDistance(const delta::collision::contactpoint *) const
  -> INLINE (MANUAL): (95,12) std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::push_back(std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>> *, const std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::value_type &) (isz = 339) (sz = 346)
    -> INLINE (MANUAL): /usr/include/c++/6/bits/stl_vector.h:(918,6) std::allocator_traits<std::allocator<delta::collision::contactpoint>>::construct<delta::collision::contactpoint, const std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::value_type &>(std::allocator_traits<std::allocator<delta::collision::contactpoint>>::allocator_type &, delta::collision::contactpoint *, const std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::value_type &) (isz = 24) (sz = 33)
      -> INLINE (MANUAL): /usr/include/c++/6/bits/alloc_traits.h:(455,8) __gnu_cxx::new_allocator<delta::collision::contactpoint>::construct<delta::collision::contactpoint, const std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::value_type &>(__gnu_cxx::new_allocator<delta::collision::contactpoint> *, delta::collision::contactpoint *, const std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::value_type &) (isz = 21) (sz = 30)
        -> DELETED: /usr/include/c++/6/ext/new_allocator.h:(120,4) operator delete(void *, void *) (isz = 0) (sz = 4)
        -> INLINE (MANUAL): /usr/include/c++/6/ext/new_allocator.h:(120,18) operator new(std::size_t, void *) (isz = 0) (sz = 7)
        -> INLINE (MANUAL): /usr/include/c++/6/ext/new_allocator.h:(120,27) std::forward<const std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::value_type &>(std::remove_reference<const std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::value_type &>::type &) (isz = 0) (sz = 6)
        -> EXTERN: /usr/include/c++/6/ext/new_allocator.h:(120,27) delta::collision::contactpoint::contactpoint(delta::collision::contactpoint *, const delta::collision::contactpoint &)
      -> INLINE (MANUAL): /usr/include/c++/6/bits/alloc_traits.h:(455,23) std::forward<const std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::value_type &>(std::remove_reference<const std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::value_type &>::type &) (isz = 0) (sz = 6)
    -> INLINE (MANUAL): /usr/include/c++/6/bits/stl_vector.h:(924,4) std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::_M_emplace_back_aux<const std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::value_type &>(std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>> *, const std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::value_type &) (isz = 300) (sz = 307)
      -> INLINE (MANUAL): /usr/include/c++/6/bits/vector.tcc:(411,4) std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::_M_check_len(const std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>> *, std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::size_type, const char *) const (isz = 88) (sz = 99)
        -> INLINE (MANUAL): /usr/include/c++/6/bits/stl_vector.h:(1422,6) std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::max_size(const std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>> *) const (isz = 8) (sz = 15)
          -> INLINE (MANUAL): (661,16) std::allocator_traits<std::allocator<delta::collision::contactpoint>>::max_size(const std::allocator_traits<std::allocator<delta::collision::contactpoint>>::allocator_type &) (isz = 2) (sz = 9)
            -> DELETED: /usr/include/c++/6/bits/alloc_traits.h:(476,20) __gnu_cxx::new_allocator<delta::collision::contactpoint>::max_size(const __gnu_cxx::new_allocator<delta::collision::contactpoint> *) const (isz = 0) (sz = 5)
          -> INLINE (MANUAL): (661,40) std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::_M_get_Tp_allocator(const std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>> *) const (isz = 1) (sz = 8)
        -> INLINE (MANUAL): /usr/include/c++/6/bits/stl_vector.h:(1422,19) std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::size(const std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>> *) const (isz = 5) (sz = 12)
        -> EXTERN: /usr/include/c++/6/bits/stl_vector.h:(1423,4) std::__throw_length_error(const char *)
        -> INLINE (MANUAL): /usr/include/c++/6/bits/stl_vector.h:(1425,26) std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::size(const std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>> *) const (isz = 5) (sz = 12)
        -> INLINE (MANUAL): /usr/include/c++/6/bits/stl_vector.h:(1425,35) std::max<std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::size_type>(const std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::size_type &, const std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::size_type &) (isz = 2) (sz = 12)
        -> INLINE (MANUAL): /usr/include/c++/6/bits/stl_vector.h:(1425,44) std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::size(const std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>> *) const (isz = 5) (sz = 12)
        -> INLINE (MANUAL): /usr/include/c++/6/bits/stl_vector.h:(1426,18) std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::size(const std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>> *) const (isz = 5) (sz = 12)
        -> INLINE (MANUAL): /usr/include/c++/6/bits/stl_vector.h:(1426,36) std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::max_size(const std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>> *) const (isz = 8) (sz = 15)
          -> INLINE (MANUAL): (661,16) std::allocator_traits<std::allocator<delta::collision::contactpoint>>::max_size(const std::allocator_traits<std::allocator<delta::collision::contactpoint>>::allocator_type &) (isz = 2) (sz = 9)
            -> DELETED: /usr/include/c++/6/bits/alloc_traits.h:(476,20) __gnu_cxx::new_allocator<delta::collision::contactpoint>::max_size(const __gnu_cxx::new_allocator<delta::collision::contactpoint> *) const (isz = 0) (sz = 5)
          -> INLINE (MANUAL): (661,40) std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::_M_get_Tp_allocator(const std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>> *) const (isz = 1) (sz = 8)
        -> INLINE (MANUAL): /usr/include/c++/6/bits/stl_vector.h:(1426,50) std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::max_size(const std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>> *) const (isz = 8) (sz = 15)
          -> INLINE (MANUAL): (661,16) std::allocator_traits<std::allocator<delta::collision::contactpoint>>::max_size(const std::allocator_traits<std::allocator<delta::collision::contactpoint>>::allocator_type &) (isz = 2) (sz = 9)
            -> DELETED: /usr/include/c++/6/bits/alloc_traits.h:(476,20) __gnu_cxx::new_allocator<delta::collision::contactpoint>::max_size(const __gnu_cxx::new_allocator<delta::collision::contactpoint> *) const (isz = 0) (sz = 5)
          -> INLINE (MANUAL): (661,40) std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::_M_get_Tp_allocator(const std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>> *) const (isz = 1) (sz = 8)
      -> INLINE (MANUAL): /usr/include/c++/6/bits/vector.tcc:(412,28) std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::_M_allocate(std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>> *, std::size_t) (isz = 16) (sz = 25)
        -> INLINE (MANUAL): /usr/include/c++/6/bits/stl_vector.h:(170,20) std::allocator_traits<std::allocator<delta::collision::contactpoint>>::allocate(std::allocator_traits<std::allocator<delta::collision::contactpoint>>::allocator_type &, std::allocator_traits<std::allocator<delta::collision::contactpoint>>::size_type) (isz = 9) (sz = 18)
          -> INLINE (MANUAL): /usr/include/c++/6/bits/alloc_traits.h:(416,20) __gnu_cxx::new_allocator<delta::collision::contactpoint>::allocate(__gnu_cxx::new_allocator<delta::collision::contactpoint> *, __gnu_cxx::new_allocator<delta::collision::contactpoint>::size_type, const void *) (isz = 7) (sz = 18)
            -> DELETED: /usr/include/c++/6/ext/new_allocator.h:(101,18) __gnu_cxx::new_allocator<delta::collision::contactpoint>::max_size(const __gnu_cxx::new_allocator<delta::collision::contactpoint> *) const (isz = 0) (sz = 5)
            -> EXTERN: /usr/include/c++/6/ext/new_allocator.h:(102,4) std::__throw_bad_alloc()
            -> EXTERN: /usr/include/c++/6/ext/new_allocator.h:(104,27) operator new(std::size_t)
      -> INLINE (MANUAL): /usr/include/c++/6/bits/vector.tcc:(416,6) std::allocator_traits<std::allocator<delta::collision::contactpoint>>::construct<delta::collision::contactpoint, const std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::value_type &>(std::allocator_traits<std::allocator<delta::collision::contactpoint>>::allocator_type &, delta::collision::contactpoint *, const std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::value_type &) (isz = 24) (sz = 33)
        -> INLINE (MANUAL): /usr/include/c++/6/bits/alloc_traits.h:(455,8) __gnu_cxx::new_allocator<delta::collision::contactpoint>::construct<delta::collision::contactpoint, const std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::value_type &>(__gnu_cxx::new_allocator<delta::collision::contactpoint> *, delta::collision::contactpoint *, const std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::value_type &) (isz = 21) (sz = 30)
          -> DELETED: /usr/include/c++/6/ext/new_allocator.h:(120,4) operator delete(void *, void *) (isz = 0) (sz = 4)
          -> INLINE (MANUAL): /usr/include/c++/6/ext/new_allocator.h:(120,18) operator new(std::size_t, void *) (isz = 0) (sz = 7)
          -> EXTERN: /usr/include/c++/6/ext/new_allocator.h:(120,27) delta::collision::contactpoint::contactpoint(delta::collision::contactpoint *, const delta::collision::contactpoint &)
          -> INLINE (MANUAL): /usr/include/c++/6/ext/new_allocator.h:(120,27) std::forward<const std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::value_type &>(std::remove_reference<const std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::value_type &>::type &) (isz = 0) (sz = 6)
        -> INLINE (MANUAL): /usr/include/c++/6/bits/alloc_traits.h:(455,23) std::forward<const std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::value_type &>(std::remove_reference<const std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::value_type &>::type &) (isz = 0) (sz = 6)
      -> INLINE (MANUAL): /usr/include/c++/6/bits/vector.tcc:(416,60) std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::size(const std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>> *) const (isz = 5) (sz = 12)
      -> INLINE (MANUAL): /usr/include/c++/6/bits/vector.tcc:(417,10) std::forward<const std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::value_type &>(std::remove_reference<const std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::value_type &>::type &) (isz = 0) (sz = 6)
      -> INLINE (MANUAL): /usr/include/c++/6/bits/vector.tcc:(421,10) std::__uninitialized_move_if_noexcept_a<std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::pointer, std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::pointer, std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::_Tp_alloc_type>(std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::pointer, std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::pointer, std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::pointer, std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::_Tp_alloc_type &) (isz = 59) (sz = 72)
        -> INLINE (MANUAL): /usr/include/c++/6/bits/stl_uninitialized.h:(302,14) std::__uninitialized_copy_a<const delta::collision::contactpoint *, std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::pointer, delta::collision::contactpoint>(const delta::collision::contactpoint *, const delta::collision::contactpoint *, std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::pointer, std::allocator<delta::collision::contactpoint> &) (isz = 52) (sz = 65)
          -> INLINE (MANUAL): (281,14) std::uninitialized_copy<const delta::collision::contactpoint *, std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::pointer>(const delta::collision::contactpoint *, const delta::collision::contactpoint *, std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::pointer) (isz = 52) (sz = 63)
            -> INLINE (MANUAL): (123,14) std::__uninitialized_copy<false>::__uninit_copy<const delta::collision::contactpoint *, std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::pointer>(const delta::collision::contactpoint *, const delta::collision::contactpoint *, std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::pointer) (isz = 51) (sz = 62)
              -> INLINE (MANUAL): (75,3) std::_Construct<delta::collision::contactpoint, const delta::collision::contactpoint &>(delta::collision::contactpoint *, const delta::collision::contactpoint &) (isz = 22) (sz = 29)
                -> DELETED: /usr/include/c++/6/bits/stl_construct.h:(75,7) operator delete(void *, void *) (isz = 0) (sz = 4)
                -> INLINE (MANUAL): /usr/include/c++/6/bits/stl_construct.h:(75,32) operator new(std::size_t, void *) (isz = 0) (sz = 7)
                -> INLINE (MANUAL): /usr/include/c++/6/bits/stl_construct.h:(75,42) std::forward<const std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::value_type &>(std::remove_reference<const std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::value_type &>::type &) (isz = 0) (sz = 6)
                -> EXTERN: /usr/include/c++/6/bits/stl_construct.h:(75,42) delta::collision::contactpoint::contactpoint(delta::collision::contactpoint *, const delta::collision::contactpoint &)
              -> INLINE (MANUAL): (75,19) std::__addressof<delta::collision::contactpoint>(delta::collision::contactpoint &) (isz = 0) (sz = 6)
              -> EXTERN: (78,4) __cxa_begin_catch
              -> EXTERN: (79,6) __cxa_end_catch
              -> DELETED: (80,8) std::_Destroy<std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::pointer>(std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::pointer, std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::pointer) (isz = 0) (sz = 7)
              -> EXTERN: (81,8) __cxa_rethrow
        -> INLINE (MANUAL): /usr/include/c++/6/bits/stl_uninitialized.h:(303,3) std::__make_move_if_noexcept_iterator<delta::collision::contactpoint, const delta::collision::contactpoint *>(delta::collision::contactpoint *) (isz = 0) (sz = 5)
        -> INLINE (MANUAL): /usr/include/c++/6/bits/stl_uninitialized.h:(304,3) std::__make_move_if_noexcept_iterator<delta::collision::contactpoint, const delta::collision::contactpoint *>(delta::collision::contactpoint *) (isz = 0) (sz = 5)
      -> INLINE (MANUAL): /usr/include/c++/6/bits/vector.tcc:(423,22) std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::_M_get_Tp_allocator(std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>> *) (isz = 1) (sz = 8)
      -> EXTERN: /usr/include/c++/6/bits/vector.tcc:(427,2) __cxa_begin_catch
      -> EXTERN: /usr/include/c++/6/bits/vector.tcc:(428,4) __cxa_end_catch
      -> DELETED: /usr/include/c++/6/bits/vector.tcc:(430,8) std::allocator_traits<std::allocator<delta::collision::contactpoint>>::destroy<delta::collision::contactpoint>(std::allocator_traits<std::allocator<delta::collision::contactpoint>>::allocator_type &, delta::collision::contactpoint *) (isz = 0) (sz = 7)
      -> /usr/include/c++/6/bits/vector.tcc:(430,60) std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::size(const std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>> *) const (isz = 5) (sz = 12)
         [[ Callee not marked with inlining pragma  <2>]]
      -> DELETED: /usr/include/c++/6/bits/vector.tcc:(432,8) std::_Destroy<std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::pointer, delta::collision::contactpoint>(std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::pointer, std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::pointer, std::allocator<delta::collision::contactpoint> &) (isz = 0) (sz = 8)
      -> /usr/include/c++/6/bits/vector.tcc:(432,49) std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::_M_get_Tp_allocator(std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>> *) (isz = 1) (sz = 8)
         [[ Callee not marked with inlining pragma  <2>]]
      -> /usr/include/c++/6/bits/vector.tcc:(433,6) std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::_M_deallocate(std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>> *, std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::pointer, std::size_t) (isz = 4) (sz = 13)
         [[ Callee not marked with inlining pragma  <2>]]
      -> EXTERN: /usr/include/c++/6/bits/vector.tcc:(434,6) __cxa_rethrow
      -> DELETED: /usr/include/c++/6/bits/vector.tcc:(436,2) std::_Destroy<std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::pointer, delta::collision::contactpoint>(std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::pointer, std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::pointer, std::allocator<delta::collision::contactpoint> &) (isz = 0) (sz = 8)
      -> INLINE (MANUAL): /usr/include/c++/6/bits/vector.tcc:(437,9) std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::_M_get_Tp_allocator(std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>> *) (isz = 1) (sz = 8)
      -> INLINE (MANUAL): /usr/include/c++/6/bits/vector.tcc:(438,2) std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::_M_deallocate(std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>> *, std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::pointer, std::size_t) (isz = 4) (sz = 13)
        -> INLINE (MANUAL): /usr/include/c++/6/bits/stl_vector.h:(178,4) std::allocator_traits<std::allocator<delta::collision::contactpoint>>::deallocate(std::allocator_traits<std::allocator<delta::collision::contactpoint>>::allocator_type &, std::allocator_traits<std::allocator<delta::collision::contactpoint>>::pointer, std::allocator_traits<std::allocator<delta::collision::contactpoint>>::size_type) (isz = 0) (sz = 9)
          -> INLINE (MANUAL): /usr/include/c++/6/bits/alloc_traits.h:(442,13) __gnu_cxx::new_allocator<delta::collision::contactpoint>::deallocate(__gnu_cxx::new_allocator<delta::collision::contactpoint> *, __gnu_cxx::new_allocator<delta::collision::contactpoint>::pointer, __gnu_cxx::new_allocator<delta::collision::contactpoint>::size_type) (isz = 0) (sz = 7)
            -> EXTERN: /usr/include/c++/6/ext/new_allocator.h:(110,9) operator delete(void *)


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at delta/collision/gjk.cpp(57,3)
<Peeled loop for vectorization>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=1
LOOP END

LOOP BEGIN at delta/collision/gjk.cpp(57,3)
   remark #15389: vectorization support: reference xCoordinatesOfPointsOfGeometryA[i] has unaligned access   [ delta/collision/gjk.cpp(59,13) ]
   remark #15388: vectorization support: reference yCoordinatesOfPointsOfGeometryA[i] has aligned access   [ delta/collision/gjk.cpp(60,15) ]
   remark #15388: vectorization support: reference zCoordinatesOfPointsOfGeometryA[i] has aligned access   [ delta/collision/gjk.cpp(61,15) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15329: vectorization support: non-unit strided store was emulated for the variable <a[na]>, stride is 3   [ delta/collision/gjk.cpp(59,5) ]
   remark #15329: vectorization support: non-unit strided store was emulated for the variable <a[na+1]>, stride is 3   [ delta/collision/gjk.cpp(60,5) ]
   remark #15329: vectorization support: non-unit strided store was emulated for the variable <a[na+2]>, stride is 3   [ delta/collision/gjk.cpp(61,5) ]
   remark #15305: vectorization support: vector length 2
   remark #15399: vectorization support: unroll factor set to 4
   remark #15309: vectorization support: normalized vectorization overhead 0.226
   remark #15300: LOOP WAS VECTORIZED
   remark #15442: entire loop may be executed in remainder
   remark #15448: unmasked aligned unit stride loads: 2 
   remark #15450: unmasked unaligned unit stride loads: 1 
   remark #15453: unmasked strided stores: 3 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 15 
   remark #15477: vector cost: 10.500 
   remark #15478: estimated potential speedup: 1.410 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at delta/collision/gjk.cpp(57,3)
<Alternate Alignment Vectorized Loop>
LOOP END

LOOP BEGIN at delta/collision/gjk.cpp(57,3)
<Remainder loop for vectorization>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at delta/collision/gjk.cpp(66,3)
<Peeled loop for vectorization>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
   remark #25015: Estimate of max trip count of loop=1
LOOP END

LOOP BEGIN at delta/collision/gjk.cpp(66,3)
   remark #15389: vectorization support: reference xCoordinatesOfPointsOfGeometryB[i] has unaligned access   [ delta/collision/gjk.cpp(68,13) ]
   remark #15388: vectorization support: reference yCoordinatesOfPointsOfGeometryB[i] has aligned access   [ delta/collision/gjk.cpp(69,15) ]
   remark #15388: vectorization support: reference zCoordinatesOfPointsOfGeometryB[i] has aligned access   [ delta/collision/gjk.cpp(70,15) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15329: vectorization support: non-unit strided store was emulated for the variable <b[nb]>, stride is 3   [ delta/collision/gjk.cpp(68,5) ]
   remark #15329: vectorization support: non-unit strided store was emulated for the variable <b[nb+1]>, stride is 3   [ delta/collision/gjk.cpp(69,5) ]
   remark #15329: vectorization support: non-unit strided store was emulated for the variable <b[nb+2]>, stride is 3   [ delta/collision/gjk.cpp(70,5) ]
   remark #15305: vectorization support: vector length 2
   remark #15399: vectorization support: unroll factor set to 4
   remark #15309: vectorization support: normalized vectorization overhead 0.226
   remark #15300: LOOP WAS VECTORIZED
   remark #15442: entire loop may be executed in remainder
   remark #15448: unmasked aligned unit stride loads: 2 
   remark #15450: unmasked unaligned unit stride loads: 1 
   remark #15453: unmasked strided stores: 3 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 15 
   remark #15477: vector cost: 10.500 
   remark #15478: estimated potential speedup: 1.410 
   remark #15488: --- end vector cost summary ---
LOOP END

LOOP BEGIN at delta/collision/gjk.cpp(66,3)
<Alternate Alignment Vectorized Loop>
LOOP END

LOOP BEGIN at delta/collision/gjk.cpp(66,3)
<Remainder loop for vectorization>
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 1
LOOP END

LOOP BEGIN at delta/collision/gjk.cpp(427,3) inlined into delta/collision/gjk.cpp(74,3)
   remark #15523: loop was not vectorized: loop control variable j was found, but loop iteration count cannot be computed before executing the loop

   LOOP BEGIN at delta/collision/gjk.cpp(147,3) inlined into delta/collision/gjk.cpp(74,3)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization   [ delta/collision/gjk.cpp(150,38) ]
      remark #15346: vector dependence: assumed ANTI dependence between dotmin (150:5) and dotmin (150:24)   [ delta/collision/gjk.cpp(150,38) ]
      remark #15346: vector dependence: assumed FLOW dependence between dotmin (150:24) and dotmin (150:5)   [ delta/collision/gjk.cpp(150,38) ]
      remark #15346: vector dependence: assumed FLOW dependence between dot (149:5) and dot (150:5)   [ delta/collision/gjk.cpp(150,38) ]
   LOOP END

   LOOP BEGIN at delta/collision/gjk.cpp(161,3) inlined into delta/collision/gjk.cpp(74,3)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization   [ delta/collision/gjk.cpp(164,38) ]
      remark #15346: vector dependence: assumed ANTI dependence between dotmax (164:5) and dotmax (164:24)   [ delta/collision/gjk.cpp(164,38) ]
      remark #15346: vector dependence: assumed FLOW dependence between dotmax (164:24) and dotmax (164:5)   [ delta/collision/gjk.cpp(164,38) ]
      remark #15346: vector dependence: assumed FLOW dependence between dot (163:5) and dot (164:5)   [ delta/collision/gjk.cpp(164,38) ]
   LOOP END
LOOP END

LOOP BEGIN at delta/collision/gjk.cpp(446,5) inlined into delta/collision/gjk.cpp(74,3)
   remark #25453: Loop Reversed
   remark #15388: vectorization support: reference l[n] has aligned access   [ delta/collision/gjk.cpp(448,7) ]
   remark #15388: vectorization support: reference l[n] has aligned access   [ delta/collision/gjk.cpp(448,7) ]
   remark #15388: vectorization support: reference l[n] has aligned access   [ delta/collision/gjk.cpp(448,7) ]
   remark #15388: vectorization support: reference l[n] has aligned access   [ delta/collision/gjk.cpp(449,7) ]
   remark #15388: vectorization support: reference l[n] has aligned access   [ delta/collision/gjk.cpp(449,7) ]
   remark #15388: vectorization support: reference l[n] has aligned access   [ delta/collision/gjk.cpp(449,7) ]
   remark #15335: loop was not vectorized: vectorization possible but seems inefficient. Use vector always directive or -vec-threshold0 to override 
   remark #15328: vectorization support: non-unit strided load was emulated for the variable <w.a[n]>, stride is 5   [ delta/collision/gjk.cpp(448,7) ]
   remark #15328: vectorization support: indirect load was emulated for the variable <*w.a[n]>, 64-bit indexed, part of address is read from memory   [ delta/collision/gjk.cpp(448,7) ]
   remark #15328: vectorization support: non-unit strided load was emulated for the variable <w.a[n]>, stride is 5   [ delta/collision/gjk.cpp(448,7) ]
   remark #15328: vectorization support: indirect load was emulated for the variable <*(w.a[n]+8)>, 64-bit indexed, part of address is read from memory   [ delta/collision/gjk.cpp(448,7) ]
   remark #15328: vectorization support: non-unit strided load was emulated for the variable <w.a[n]>, stride is 5   [ delta/collision/gjk.cpp(448,7) ]
   remark #15328: vectorization support: indirect load was emulated for the variable <*(w.a[n]+16)>, 64-bit indexed, part of address is read from memory   [ delta/collision/gjk.cpp(448,7) ]
   remark #15328: vectorization support: non-unit strided load was emulated for the variable <w.b[n]>, stride is 5   [ delta/collision/gjk.cpp(449,7) ]
   remark #15328: vectorization support: indirect load was emulated for the variable <*w.b[n]>, 64-bit indexed, part of address is read from memory   [ delta/collision/gjk.cpp(449,7) ]
   remark #15328: vectorization support: non-unit strided load was emulated for the variable <w.b[n]>, stride is 5   [ delta/collision/gjk.cpp(449,7) ]
   remark #15328: vectorization support: indirect load was emulated for the variable <*(w.b[n]+8)>, 64-bit indexed, part of address is read from memory   [ delta/collision/gjk.cpp(449,7) ]
   remark #15328: vectorization support: non-unit strided load was emulated for the variable <w.b[n]>, stride is 5   [ delta/collision/gjk.cpp(449,7) ]
   remark #15328: vectorization support: indirect load was emulated for the variable <*(w.b[n]+16)>, 64-bit indexed, part of address is read from memory   [ delta/collision/gjk.cpp(449,7) ]
   remark #15305: vectorization support: vector length 2
   remark #15309: vectorization support: normalized vectorization overhead 0.983
   remark #15448: unmasked aligned unit stride loads: 1 
   remark #15452: unmasked strided loads: 6 
   remark #15462: unmasked indexed (or gather) loads: 6 
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 60 
   remark #15477: vector cost: 58.000 
   remark #15478: estimated potential speedup: 0.690 
   remark #15488: --- end vector cost summary ---
   remark #25456: Number of Array Refs Scalar Replaced In Loop: 5
   remark #25015: Estimate of max trip count of loop=4
LOOP END

LOOP BEGIN at /usr/include/c++/6/bits/stl_uninitialized.h(74,8) inlined into delta/collision/gjk.cpp(95,12)
   remark #15523: loop was not vectorized: loop control variable __cur was found, but loop iteration count cannot be computed before executing the loop
LOOP END

    Report from: Code generation optimizations [cg]

delta/collision/gjk.cpp(60,5):remark #34033: adjacent sparse (strided) stores are not optimized. Details: stride { 24 }, types { F64-V128, F64-V128 }, number of elements { 2 }, select mask { 0x000000003 }.
delta/collision/gjk.cpp(60,5):remark #34033: adjacent sparse (strided) stores are not optimized. Details: stride { 24 }, types { F64-V128, F64-V128 }, number of elements { 2 }, select mask { 0x000000003 }.
delta/collision/gjk.cpp(60,5):remark #34033: adjacent sparse (strided) stores are not optimized. Details: stride { 24 }, types { F64-V128, F64-V128 }, number of elements { 2 }, select mask { 0x000000003 }.
delta/collision/gjk.cpp(60,5):remark #34033: adjacent sparse (strided) stores are not optimized. Details: stride { 24 }, types { F64-V128, F64-V128 }, number of elements { 2 }, select mask { 0x000000003 }.
delta/collision/gjk.cpp(60,5):remark #34033: adjacent sparse (strided) stores are not optimized. Details: stride { 24 }, types { F64-V128, F64-V128 }, number of elements { 2 }, select mask { 0x000000003 }.
delta/collision/gjk.cpp(60,5):remark #34033: adjacent sparse (strided) stores are not optimized. Details: stride { 24 }, types { F64-V128, F64-V128 }, number of elements { 2 }, select mask { 0x000000003 }.
delta/collision/gjk.cpp(60,5):remark #34033: adjacent sparse (strided) stores are not optimized. Details: stride { 24 }, types { F64-V128, F64-V128 }, number of elements { 2 }, select mask { 0x000000003 }.
delta/collision/gjk.cpp(60,5):remark #34033: adjacent sparse (strided) stores are not optimized. Details: stride { 24 }, types { F64-V128, F64-V128 }, number of elements { 2 }, select mask { 0x000000003 }.
delta/collision/gjk.cpp(69,5):remark #34033: adjacent sparse (strided) stores are not optimized. Details: stride { 24 }, types { F64-V128, F64-V128 }, number of elements { 2 }, select mask { 0x000000003 }.
delta/collision/gjk.cpp(69,5):remark #34033: adjacent sparse (strided) stores are not optimized. Details: stride { 24 }, types { F64-V128, F64-V128 }, number of elements { 2 }, select mask { 0x000000003 }.
delta/collision/gjk.cpp(69,5):remark #34033: adjacent sparse (strided) stores are not optimized. Details: stride { 24 }, types { F64-V128, F64-V128 }, number of elements { 2 }, select mask { 0x000000003 }.
delta/collision/gjk.cpp(69,5):remark #34033: adjacent sparse (strided) stores are not optimized. Details: stride { 24 }, types { F64-V128, F64-V128 }, number of elements { 2 }, select mask { 0x000000003 }.
delta/collision/gjk.cpp(69,5):remark #34033: adjacent sparse (strided) stores are not optimized. Details: stride { 24 }, types { F64-V128, F64-V128 }, number of elements { 2 }, select mask { 0x000000003 }.
delta/collision/gjk.cpp(69,5):remark #34033: adjacent sparse (strided) stores are not optimized. Details: stride { 24 }, types { F64-V128, F64-V128 }, number of elements { 2 }, select mask { 0x000000003 }.
delta/collision/gjk.cpp(69,5):remark #34033: adjacent sparse (strided) stores are not optimized. Details: stride { 24 }, types { F64-V128, F64-V128 }, number of elements { 2 }, select mask { 0x000000003 }.
delta/collision/gjk.cpp(69,5):remark #34033: adjacent sparse (strided) stores are not optimized. Details: stride { 24 }, types { F64-V128, F64-V128 }, number of elements { 2 }, select mask { 0x000000003 }.
delta/collision/gjk.cpp(91,27):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
delta/collision/gjk.cpp(40,3):remark #34051: REGISTER ALLOCATION : [_ZN5delta9collision3gjkEiPdS1_S1_diiS1_S1_S1_di] delta/collision/gjk.cpp:40

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   29[ rax rdx rcx rbx rbp rsi rdi r8-r15 zmm0-zmm13]
        
    Routine temporaries
        Total         :     393
            Global    :     101
            Local     :     292
        Regenerable   :      49
        Spilled       :      23
        
    Routine stack
        Variables     :     564 bytes*
            Reads     :      17 [1.53e+01 ~ 0.9%]
            Writes    :      28 [2.09e+01 ~ 1.3%]
        Spills        :     136 bytes*
            Reads     :      42 [2.06e+01 ~ 1.3%]
            Writes    :      17 [1.10e+01 ~ 0.7%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: __gnu_cxx::new_allocator<delta::collision::contactpoint>::max_size(const __gnu_cxx::new_allocator<delta::collision::contactpoint> *) const

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (__gnu_cxx::new_allocator<delta::collision::contactpoint>::max_size(const __gnu_cxx::new_allocator<delta::collision::contactpoint> *) const) /usr/include/c++/6/ext/new_allocator.h(114,7)

===========================================================================

Begin optimization report for: operator delete(void *, void *)

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (operator delete(void *, void *)) /usr/include/c++/6/new(152,67)

===========================================================================

Begin optimization report for: std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::vector(std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>> *)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::vector(std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>> *)) [55/68=80.9%] /usr/include/c++/6/bits/stl_vector.h(259,17)
  -> INLINE (MANUAL): (255,7) std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::_Vector_base(std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>> *const) (isz = 13) (sz = 18)
    -> INLINE (MANUAL): (124,7) std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::_Vector_base(std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>> *) (isz = 13) (sz = 18)
      -> INLINE (MANUAL): (124,7) std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::_Vector_impl::_Vector_impl(std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::_Vector_impl *) (isz = 11) (sz = 16)
        -> INLINE (MANUAL): (86,2) std::allocator<delta::collision::contactpoint>::allocator(std::allocator<delta::collision::contactpoint> *const) (isz = 5) (sz = 10)
          -> INLINE (MANUAL): /usr/include/c++/6/bits/allocator.h:(118,7) std::allocator<delta::collision::contactpoint>::allocator(std::allocator<delta::collision::contactpoint> *) (isz = 5) (sz = 10)
            -> DELETED: (118,7) __gnu_cxx::new_allocator<delta::collision::contactpoint>::new_allocator(__gnu_cxx::new_allocator<delta::collision::contactpoint> *const) (isz = 0) (sz = 5)
            -> EXTERN: (118,27) __cxa_call_unexpected
  -> EXTERN: (259,17) __cxa_call_unexpected


    Report from: Code generation optimizations [cg]

/usr/include/c++/6/bits/stl_vector.h(259,17):remark #34051: REGISTER ALLOCATION : [_ZNSt6vectorIN5delta9collision12contactpointESaIS2_EEC1Ev] /usr/include/c++/6/bits/stl_vector.h:259

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    2[ rax rdi]
        
    Routine temporaries
        Total         :       9
            Global    :       0
            Local     :       9
        Regenerable   :       1
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: __gnu_cxx::new_allocator<delta::collision::contactpoint>::new_allocator(__gnu_cxx::new_allocator<delta::collision::contactpoint> *const)

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (__gnu_cxx::new_allocator<delta::collision::contactpoint>::new_allocator(__gnu_cxx::new_allocator<delta::collision::contactpoint> *const)) /usr/include/c++/6/ext/new_allocator.h(79,7)

===========================================================================

Begin optimization report for: std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::~vector(std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>> *)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::~vector(std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>> *)) [57/68=83.8%] /usr/include/c++/6/bits/stl_vector.h(426,7)
  -> EXTERN: (426,7) __cxa_call_unexpected
  -> (426,7) std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::~_Vector_base(std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>> *const) (isz = 18) (sz = 23)
     [[ Callee not marked with inlining pragma  <2>]]
  -> DELETED: (426,9) std::_Destroy<std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::pointer, delta::collision::contactpoint>(std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::pointer, std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::pointer, std::allocator<delta::collision::contactpoint> &) (isz = 0) (sz = 8)
  -> INLINE (MANUAL): (427,9) std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::_M_get_Tp_allocator(std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>> *) (isz = 1) (sz = 8)
  -> INLINE (MANUAL): (427,33) std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::~_Vector_base(std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>> *const) (isz = 18) (sz = 23)
    -> INLINE (MANUAL): (159,7) std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::~_Vector_base(std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>> *) (isz = 18) (sz = 23)
      -> EXTERN: (160,7) __cxa_call_unexpected
      -> INLINE (MANUAL): (160,9) std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::_M_deallocate(std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>> *, std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::pointer, std::size_t) (isz = 4) (sz = 13)
        -> INLINE (MANUAL): (178,4) std::allocator_traits<std::allocator<delta::collision::contactpoint>>::deallocate(std::allocator_traits<std::allocator<delta::collision::contactpoint>>::allocator_type &, std::allocator_traits<std::allocator<delta::collision::contactpoint>>::pointer, std::allocator_traits<std::allocator<delta::collision::contactpoint>>::size_type) (isz = 0) (sz = 9)
          -> INLINE (MANUAL): /usr/include/c++/6/bits/alloc_traits.h:(442,13) __gnu_cxx::new_allocator<delta::collision::contactpoint>::deallocate(__gnu_cxx::new_allocator<delta::collision::contactpoint> *, __gnu_cxx::new_allocator<delta::collision::contactpoint>::pointer, __gnu_cxx::new_allocator<delta::collision::contactpoint>::size_type) (isz = 0) (sz = 7)
            -> EXTERN: /usr/include/c++/6/ext/new_allocator.h:(110,9) operator delete(void *)


    Report from: Code generation optimizations [cg]

/usr/include/c++/6/bits/stl_vector.h(426,7):remark #34051: REGISTER ALLOCATION : [_ZNSt6vectorIN5delta9collision12contactpointESaIS2_EED1Ev] /usr/include/c++/6/bits/stl_vector.h:426

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    1[ rdi]
        
    Routine temporaries
        Total         :      10
            Global    :       7
            Local     :       3
        Regenerable   :       0
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::~_Vector_base(std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>> *const)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::~_Vector_base(std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>> *const)) [58/68=85.3%] /usr/include/c++/6/bits/stl_vector.h(159,7)
  -> INLINE (MANUAL): (159,7) std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::~_Vector_base(std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>> *) (isz = 18) (sz = 23)
    -> EXTERN: (160,7) __cxa_call_unexpected
    -> INLINE (MANUAL): (160,9) std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::_M_deallocate(std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>> *, std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::pointer, std::size_t) (isz = 4) (sz = 13)
      -> INLINE (MANUAL): (178,4) std::allocator_traits<std::allocator<delta::collision::contactpoint>>::deallocate(std::allocator_traits<std::allocator<delta::collision::contactpoint>>::allocator_type &, std::allocator_traits<std::allocator<delta::collision::contactpoint>>::pointer, std::allocator_traits<std::allocator<delta::collision::contactpoint>>::size_type) (isz = 0) (sz = 9)
        -> INLINE (MANUAL): /usr/include/c++/6/bits/alloc_traits.h:(442,13) __gnu_cxx::new_allocator<delta::collision::contactpoint>::deallocate(__gnu_cxx::new_allocator<delta::collision::contactpoint> *, __gnu_cxx::new_allocator<delta::collision::contactpoint>::pointer, __gnu_cxx::new_allocator<delta::collision::contactpoint>::size_type) (isz = 0) (sz = 7)
          -> EXTERN: /usr/include/c++/6/ext/new_allocator.h:(110,9) operator delete(void *)


    Report from: Code generation optimizations [cg]

/usr/include/c++/6/bits/stl_vector.h(159,7):remark #34051: REGISTER ALLOCATION : [_ZNSt12_Vector_baseIN5delta9collision12contactpointESaIS2_EED2Ev] /usr/include/c++/6/bits/stl_vector.h:159

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    1[ rdi]
        
    Routine temporaries
        Total         :      10
            Global    :       7
            Local     :       3
        Regenerable   :       0
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: std::allocator_traits<std::allocator<delta::collision::contactpoint>>::destroy<delta::collision::contactpoint>(std::allocator_traits<std::allocator<delta::collision::contactpoint>>::allocator_type &, delta::collision::contactpoint *)

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (std::allocator_traits<std::allocator<delta::collision::contactpoint>>::destroy<delta::collision::contactpoint>(std::allocator_traits<std::allocator<delta::collision::contactpoint>>::allocator_type &, delta::collision::contactpoint *)) /usr/include/c++/6/bits/alloc_traits.h(467,2)

===========================================================================

Begin optimization report for: std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::_M_deallocate(std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>> *, std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::pointer, std::size_t)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::_M_deallocate(std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>> *, std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::pointer, std::size_t)) [60/68=88.2%] /usr/include/c++/6/bits/stl_vector.h(175,7)
  -> INLINE (MANUAL): (178,4) std::allocator_traits<std::allocator<delta::collision::contactpoint>>::deallocate(std::allocator_traits<std::allocator<delta::collision::contactpoint>>::allocator_type &, std::allocator_traits<std::allocator<delta::collision::contactpoint>>::pointer, std::allocator_traits<std::allocator<delta::collision::contactpoint>>::size_type) (isz = 0) (sz = 9)
    -> INLINE (MANUAL): /usr/include/c++/6/bits/alloc_traits.h:(442,13) __gnu_cxx::new_allocator<delta::collision::contactpoint>::deallocate(__gnu_cxx::new_allocator<delta::collision::contactpoint> *, __gnu_cxx::new_allocator<delta::collision::contactpoint>::pointer, __gnu_cxx::new_allocator<delta::collision::contactpoint>::size_type) (isz = 0) (sz = 7)
      -> EXTERN: /usr/include/c++/6/ext/new_allocator.h:(110,9) operator delete(void *)


    Report from: Code generation optimizations [cg]

/usr/include/c++/6/bits/stl_vector.h(175,7):remark #34051: REGISTER ALLOCATION : [_ZNSt12_Vector_baseIN5delta9collision12contactpointESaIS2_EE13_M_deallocateEPS2_m] /usr/include/c++/6/bits/stl_vector.h:175

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    3[ rdx rsi rdi]
        
    Routine temporaries
        Total         :      11
            Global    :       7
            Local     :       4
        Regenerable   :       0
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::_M_get_Tp_allocator(std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>> *)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::_M_get_Tp_allocator(std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>> *)) [61/68=89.7%] /usr/include/c++/6/bits/stl_vector.h(114,7)


    Report from: Code generation optimizations [cg]

/usr/include/c++/6/bits/stl_vector.h(114,7):remark #34051: REGISTER ALLOCATION : [_ZNSt12_Vector_baseIN5delta9collision12contactpointESaIS2_EE19_M_get_Tp_allocatorEv] /usr/include/c++/6/bits/stl_vector.h:114

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    2[ rax rdi]
        
    Routine temporaries
        Total         :       9
            Global    :       0
            Local     :       9
        Regenerable   :       0
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::size(const std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>> *) const

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::size(const std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>> *) const) [62/68=91.2%] /usr/include/c++/6/bits/stl_vector.h(656,7)


    Report from: Code generation optimizations [cg]

/usr/include/c++/6/bits/stl_vector.h(656,7):remark #34051: REGISTER ALLOCATION : [_ZNKSt6vectorIN5delta9collision12contactpointESaIS2_EE4sizeEv] /usr/include/c++/6/bits/stl_vector.h:656

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    4[ rax rdx rcx rdi]
        
    Routine temporaries
        Total         :      19
            Global    :       0
            Local     :      19
        Regenerable   :       2
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: std::_Destroy<std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::pointer, delta::collision::contactpoint>(std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::pointer, std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::pointer, std::allocator<delta::collision::contactpoint> &)

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (std::_Destroy<std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::pointer, delta::collision::contactpoint>(std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::pointer, std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::pointer, std::allocator<delta::collision::contactpoint> &)) /usr/include/c++/6/bits/stl_construct.h(150,5)

===========================================================================

Begin optimization report for: delta::collision::gjk(double *, int, double *, int, double *, double *)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (delta::collision::gjk(double *, int, double *, int, double *, double *)) [64/68=94.1%] delta/collision/gjk.cpp(418,1)
  -> INLINE (MANUAL): (429,14) minimal_support_point(double *, int, double *) (isz = 29) (sz = 40)
  -> INLINE (MANUAL): (430,14) maximal_support_point(double *, int, double *) (isz = 29) (sz = 40)
  -> (437,11) project(point *, int, double *, double *) (isz = 337) (sz = 352)
     [[ Inlining would exceed -inline-max-size value (352>230) <1>]]


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at delta/collision/gjk.cpp(427,3)
   remark #15523: loop was not vectorized: loop control variable j was found, but loop iteration count cannot be computed before executing the loop

   LOOP BEGIN at delta/collision/gjk.cpp(147,3) inlined into delta/collision/gjk.cpp(429,14)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization   [ delta/collision/gjk.cpp(150,38) ]
      remark #15346: vector dependence: assumed ANTI dependence between dotmin (150:5) and dotmin (150:24)   [ delta/collision/gjk.cpp(150,38) ]
      remark #15346: vector dependence: assumed FLOW dependence between dotmin (150:24) and dotmin (150:5)   [ delta/collision/gjk.cpp(150,38) ]
      remark #15346: vector dependence: assumed FLOW dependence between dot (149:5) and dot (150:5)   [ delta/collision/gjk.cpp(150,38) ]
   LOOP END

   LOOP BEGIN at delta/collision/gjk.cpp(161,3) inlined into delta/collision/gjk.cpp(430,14)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization   [ delta/collision/gjk.cpp(164,38) ]
      remark #15346: vector dependence: assumed ANTI dependence between dotmax (164:5) and dotmax (164:24)   [ delta/collision/gjk.cpp(164,38) ]
      remark #15346: vector dependence: assumed FLOW dependence between dotmax (164:24) and dotmax (164:5)   [ delta/collision/gjk.cpp(164,38) ]
      remark #15346: vector dependence: assumed FLOW dependence between dot (163:5) and dot (164:5)   [ delta/collision/gjk.cpp(164,38) ]
   LOOP END
LOOP END

LOOP BEGIN at delta/collision/gjk.cpp(446,5)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization
   remark #15346: vector dependence: assumed OUTPUT dependence between *p (448:7) and q[2] (449:7)
   remark #15346: vector dependence: assumed OUTPUT dependence between q[2] (449:7) and *p (448:7)
   remark #25015: Estimate of max trip count of loop=4
LOOP END

    Report from: Code generation optimizations [cg]

delta/collision/gjk.cpp(418,1):remark #34051: REGISTER ALLOCATION : [_ZN5delta9collision3gjkEPdiS1_iS1_S1_] delta/collision/gjk.cpp:418

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   26[ rax rdx rcx rbx rbp rsi rdi r8-r15 zmm0-zmm10]
        
    Routine temporaries
        Total         :     129
            Global    :      43
            Local     :      86
        Regenerable   :      12
        Spilled       :      11
        
    Routine stack
        Variables     :     216 bytes*
            Reads     :       7 [8.75e+00 ~ 2.4%]
            Writes    :       8 [7.41e+00 ~ 2.0%]
        Spills        :      88 bytes*
            Reads     :      29 [4.16e+00 ~ 1.1%]
            Writes    :      11 [4.44e+00 ~ 1.2%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: std::uninitialized_copy<const delta::collision::contactpoint *, std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::pointer>(const delta::collision::contactpoint *, const delta::collision::contactpoint *, std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::pointer)

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (std::uninitialized_copy<const delta::collision::contactpoint *, std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::pointer>(const delta::collision::contactpoint *, const delta::collision::contactpoint *, std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::pointer)) /usr/include/c++/6/bits/stl_uninitialized.h(109,5)

===========================================================================

Begin optimization report for: std::__uninitialized_copy_a<const delta::collision::contactpoint *, std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::pointer, delta::collision::contactpoint>(const delta::collision::contactpoint *, const delta::collision::contactpoint *, std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::pointer, std::allocator<delta::collision::contactpoint> &)

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (std::__uninitialized_copy_a<const delta::collision::contactpoint *, std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::pointer, delta::collision::contactpoint>(const delta::collision::contactpoint *, const delta::collision::contactpoint *, std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::pointer, std::allocator<delta::collision::contactpoint> &)) /usr/include/c++/6/bits/stl_uninitialized.h(281,5)

===========================================================================

Begin optimization report for: std::__uninitialized_move_if_noexcept_a<std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::pointer, std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::pointer, std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::_Tp_alloc_type>(std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::pointer, std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::pointer, std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::pointer, std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::_Tp_alloc_type &)

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (std::__uninitialized_move_if_noexcept_a<std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::pointer, std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::pointer, std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::_Tp_alloc_type>(std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::pointer, std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::pointer, std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::pointer, std::_Vector_base<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::_Tp_alloc_type &)) /usr/include/c++/6/bits/stl_uninitialized.h(301,5)

===========================================================================

Begin optimization report for: std::__uninitialized_copy<false>::__uninit_copy<const delta::collision::contactpoint *, std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::pointer>(const delta::collision::contactpoint *, const delta::collision::contactpoint *, std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::pointer)

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (std::__uninitialized_copy<false>::__uninit_copy<const delta::collision::contactpoint *, std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::pointer>(const delta::collision::contactpoint *, const delta::collision::contactpoint *, std::vector<delta::collision::contactpoint, std::allocator<delta::collision::contactpoint>>::pointer)) /usr/include/c++/6/bits/stl_uninitialized.h(70,9)

===========================================================================

    Report from: Interprocedural optimizations [ipo]

INLINING FOOTNOTES:

<1> The function is larger than the inliner would normally inline.  Use the
    option -inline-max-size to increase the size of any function that would
    normally be inlined, add "inline __attribute__((always_inline))" to the
    declaration of the called function, or add "#pragma forceinline" before
    the call site.

<2> The compiler's heuristics indicate that the function is not profitable to 
    inline.  Override this decision by adding "inline 
    __attribute__((always_inline))" to the declaration of the called function, 
    or add "#pragma forceinline" before the call site.

<3> The routine declaration is annotated with "__attribute__((noinline))".  
    Remove this annotation to permit the compiler to inline this routine.

